// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	/// <summary>
	/// Record the chunk in the png_struct <br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct PngStruct
	{
		/// <summary>
		/// New name in 1.6.0 for jmp_buf in png_struct <br/>
		/// </summary>
		public JmpBuf JmpBufLocal;

		/// <summary>
		/// setjmp non-local goto function. <br/>
		/// </summary>
		public unsafe void* LongjmpFn;

		/// <summary>
		/// passed to longjmp_fn <br/>
		/// </summary>
		public unsafe JmpBuf* JmpBufPtr;

		/// <summary>
		/// size of the above, if allocated <br/>
		/// </summary>
		public nuint JmpBufSize;

		/// <summary>
		/// function for printing errors and aborting <br/>
		/// </summary>
		public unsafe void* ErrorFn;

		/// <summary>
		/// function for printing warnings <br/>
		/// </summary>
		public unsafe void* WarningFn;

		/// <summary>
		/// user supplied struct for error functions <br/>
		/// </summary>
		public unsafe void* ErrorPtr;

		/// <summary>
		/// function for writing output data <br/>
		/// </summary>
		public unsafe void* WriteDataFn;

		/// <summary>
		/// function for reading input data <br/>
		/// </summary>
		public unsafe void* ReadDataFn;

		/// <summary>
		/// ptr to application struct for I/O functions <br/>
		/// </summary>
		public unsafe void* IoPtr;

		/// <summary>
		/// user read transform <br/>
		/// </summary>
		public unsafe void* ReadUserTransformFn;

		/// <summary>
		/// user write transform <br/>
		/// </summary>
		public unsafe void* WriteUserTransformFn;

		/// <summary>
		/// user supplied struct for user transform <br/>
		/// </summary>
		public unsafe void* UserTransformPtr;

		/// <summary>
		/// bit depth of user transformed pixels <br/>
		/// </summary>
		public byte UserTransformDepth;

		/// <summary>
		/// channels in user transformed pixels <br/>
		/// </summary>
		public byte UserTransformChannels;

		/// <summary>
		/// tells us where we are in the PNG file <br/>
		/// </summary>
		public uint Mode;

		/// <summary>
		/// flags indicating various things to libpng <br/>
		/// </summary>
		public uint Flags;

		/// <summary>
		/// which transformations to perform <br/>
		/// </summary>
		public uint Transformations;

		/// <summary>
		/// ID (chunk type) of zstream owner, 0 if none <br/>
		/// </summary>
		public uint Zowner;

		/// <summary>
		/// decompression structure <br/>
		/// </summary>
		public ZStream Zstream;

		/// <summary>
		/// Created on demand during write <br/>
		/// </summary>
		public unsafe PngCompressionBuffer* ZbufferList;

		/// <summary>
		/// size of the actual buffer <br/>
		/// </summary>
		public uint ZbufferSize;

		/// <summary>
		/// holds zlib compression level <br/>
		/// </summary>
		public int ZlibLevel;

		/// <summary>
		/// holds zlib compression method <br/>
		/// </summary>
		public int ZlibMethod;

		/// <summary>
		/// holds zlib compression window bits <br/>
		/// </summary>
		public int ZlibWindowBits;

		/// <summary>
		/// holds zlib compression memory level <br/>
		/// </summary>
		public int ZlibMemLevel;

		/// <summary>
		/// holds zlib compression strategy <br/>
		/// </summary>
		public int ZlibStrategy;

		/// <summary>
		/// holds zlib compression level <br/>
		/// </summary>
		public int ZlibTextLevel;

		/// <summary>
		/// holds zlib compression method <br/>
		/// </summary>
		public int ZlibTextMethod;

		/// <summary>
		/// holds zlib compression window bits <br/>
		/// </summary>
		public int ZlibTextWindowBits;

		/// <summary>
		/// holds zlib compression memory level <br/>
		/// </summary>
		public int ZlibTextMemLevel;

		/// <summary>
		/// holds zlib compression strategy <br/>
		/// </summary>
		public int ZlibTextStrategy;

		/// <summary>
		/// Actual values set into the zstream on write <br/>
		/// </summary>
		public int ZlibSetLevel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ZlibSetMethod;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ZlibSetWindowBits;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ZlibSetMemLevel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ZlibSetStrategy;

		/// <summary>
		/// PNG_CF_ for every chunk read or (NYI) written <br/>
		/// </summary>
		public uint Chunks;

		/// <summary>
		/// width of image in pixels <br/>
		/// </summary>
		public uint Width;

		/// <summary>
		/// height of image in pixels <br/>
		/// </summary>
		public uint Height;

		/// <summary>
		/// number of rows in current pass <br/>
		/// </summary>
		public uint NumRows;

		/// <summary>
		/// width of row at start of write <br/>
		/// </summary>
		public uint UsrWidth;

		/// <summary>
		/// size of row in bytes <br/>
		/// </summary>
		public nuint Rowbytes;

		/// <summary>
		/// width of current interlaced row in pixels <br/>
		/// </summary>
		public uint Iwidth;

		/// <summary>
		/// current row in interlace pass <br/>
		/// </summary>
		public uint RowNumber;

		/// <summary>
		/// PNG_CHUNK() id of current chunk <br/>
		/// </summary>
		public uint ChunkName;

		/// <summary>
		/// buffer to save previous (unfiltered) row.<br/>
		/// While reading this is a pointer into<br/>
		/// big_prev_row; while writing it is separately<br/>
		/// allocated if needed.<br/>
		/// </summary>
		public unsafe byte* PrevRow;

		/// <summary>
		/// buffer to save current (unfiltered) row.<br/>
		/// While reading, this is a pointer into<br/>
		/// big_row_buf; while writing it is separately<br/>
		/// allocated.<br/>
		/// </summary>
		public unsafe byte* RowBuf;

		/// <summary>
		/// buffer to save trial row when filtering <br/>
		/// </summary>
		public unsafe byte* TryRow;

		/// <summary>
		/// buffer to save best trial row when filtering <br/>
		/// </summary>
		public unsafe byte* TstRow;

		/// <summary>
		/// Added in 1.5.4: cache of updated row bytes <br/>
		/// </summary>
		public nuint InfoRowbytes;

		/// <summary>
		/// current IDAT size for read <br/>
		/// </summary>
		public uint IdatSize;

		/// <summary>
		/// current chunk CRC value <br/>
		/// </summary>
		public uint Crc;

		/// <summary>
		/// palette from the input file <br/>
		/// </summary>
		public unsafe PngColor* Palette;

		/// <summary>
		/// number of color entries in palette <br/>
		/// </summary>
		public ushort NumPalette;

		/// <summary>
		/// maximum palette index found in IDAT <br/>
		/// </summary>
		public int NumPaletteMax;

		/// <summary>
		/// number of transparency values <br/>
		/// </summary>
		public ushort NumTrans;

		/// <summary>
		/// file compression type (always 0) <br/>
		/// </summary>
		public byte Compression;

		/// <summary>
		/// file filter type (always 0) <br/>
		/// </summary>
		public byte Filter;

		/// <summary>
		/// PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 <br/>
		/// </summary>
		public byte Interlaced;

		/// <summary>
		/// current interlace pass (0 - 6) <br/>
		/// </summary>
		public byte Pass;

		/// <summary>
		/// row filter flags (see PNG_FILTER_ in png.h ) <br/>
		/// </summary>
		public byte DoFilter;

		/// <summary>
		/// color type of file <br/>
		/// </summary>
		public byte ColorType;

		/// <summary>
		/// bit depth of file <br/>
		/// </summary>
		public byte BitDepth;

		/// <summary>
		/// bit depth of users row: write only <br/>
		/// </summary>
		public byte UsrBitDepth;

		/// <summary>
		/// number of bits per pixel <br/>
		/// </summary>
		public byte PixelDepth;

		/// <summary>
		/// number of channels in file <br/>
		/// </summary>
		public byte Channels;

		/// <summary>
		/// channels at start of write: write only <br/>
		/// </summary>
		public byte UsrChannels;

		/// <summary>
		/// magic bytes read/written from start of file <br/>
		/// </summary>
		public byte SigBytes;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MaximumPixelDepth;

		/// <summary>
		/// pixel depth used for the row buffers <br/>
		/// </summary>
		public byte TransformedPixelDepth;

		/// <summary>
		/// at start of an input zlib stream <br/>
		/// </summary>
		public byte ZstreamStart;

		/// <summary>
		/// filler bytes for pixel expansion <br/>
		/// </summary>
		public ushort Filler;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackgroundGammaType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BackgroundGamma;

		/// <summary>
		/// background color in screen gamma space <br/>
		/// </summary>
		public PngColor16 Background;

		/// <summary>
		/// background normalized to gamma 1.0 <br/>
		/// </summary>
		public PngColor16 Background1;

		/// <summary>
		/// Function for flushing output <br/>
		/// </summary>
		public unsafe void* OutputFlushFn;

		/// <summary>
		/// how many rows apart to flush, 0 - no flush <br/>
		/// </summary>
		public uint FlushDist;

		/// <summary>
		/// number of rows written since last flush <br/>
		/// </summary>
		public uint FlushRows;

		/// <summary>
		/// From mDVC, cICP, [iCCP], sRGB or cHRM <br/>
		/// </summary>
		public PngXy Chromaticities;

		/// <summary>
		/// number of "insignificant" bits in 16-bit gamma <br/>
		/// </summary>
		public int GammaShift;

		/// <summary>
		/// screen gamma value (display exponent) <br/>
		/// </summary>
		public int ScreenGamma;

		/// <summary>
		/// file gamma value (encoding exponent) <br/>
		/// </summary>
		public int FileGamma;

		/// <summary>
		/// from cICP, iCCP, sRGB or gAMA <br/>
		/// </summary>
		public int ChunkGamma;

		/// <summary>
		/// from png_set_alpha_mode <br/>
		/// </summary>
		public int DefaultGamma;

		/// <summary>
		/// gamma table for 8-bit depth files <br/>
		/// </summary>
		public unsafe byte* GammaTable;

		/// <summary>
		/// gamma table for 16-bit depth files <br/>
		/// </summary>
		public unsafe ushort** Gamma16Table;

		/// <summary>
		/// converts from 1.0 to screen <br/>
		/// </summary>
		public unsafe byte* GammaFrom1;

		/// <summary>
		/// converts from file to 1.0 <br/>
		/// </summary>
		public unsafe byte* GammaTo1;

		/// <summary>
		/// converts from 1.0 to screen <br/>
		/// </summary>
		public unsafe ushort** Gamma16From1;

		/// <summary>
		/// converts from file to 1.0 <br/>
		/// </summary>
		public unsafe ushort** Gamma16To1;

		/// <summary>
		/// significant bits in each available channel <br/>
		/// </summary>
		public PngColor8 SigBit;

		/// <summary>
		/// shift for significant bit transformation <br/>
		/// </summary>
		public PngColor8 Shift;

		/// <summary>
		/// alpha values for paletted files <br/>
		/// </summary>
		public unsafe byte* TransAlpha;

		/// <summary>
		/// transparent color for non-paletted files <br/>
		/// </summary>
		public PngColor16 TransColor;

		/// <summary>
		/// called after each row is decoded <br/>
		/// </summary>
		public unsafe void* ReadRowFn;

		/// <summary>
		/// called after each row is encoded <br/>
		/// </summary>
		public unsafe void* WriteRowFn;

		/// <summary>
		/// called after header data fully read <br/>
		/// </summary>
		public unsafe void* InfoFn;

		/// <summary>
		/// called after a prog. row is decoded <br/>
		/// </summary>
		public unsafe void* RowFn;

		/// <summary>
		/// called after image is complete <br/>
		/// </summary>
		public unsafe void* EndFn;

		/// <summary>
		/// current location in save_buffer <br/>
		/// </summary>
		public unsafe byte* SaveBufferPtr;

		/// <summary>
		/// buffer for previously read data <br/>
		/// </summary>
		public unsafe byte* SaveBuffer;

		/// <summary>
		/// current location in current_buffer <br/>
		/// </summary>
		public unsafe byte* CurrentBufferPtr;

		/// <summary>
		/// buffer for recently used data <br/>
		/// </summary>
		public unsafe byte* CurrentBuffer;

		/// <summary>
		/// size of current input chunk <br/>
		/// </summary>
		public uint PushLength;

		/// <summary>
		/// bytes to skip in input data <br/>
		/// </summary>
		public uint SkipLength;

		/// <summary>
		/// amount of data now in save_buffer <br/>
		/// </summary>
		public nuint SaveBufferSize;

		/// <summary>
		/// total size of save_buffer <br/>
		/// </summary>
		public nuint SaveBufferMax;

		/// <summary>
		/// total amount of available input data <br/>
		/// </summary>
		public nuint BufferSize;

		/// <summary>
		/// amount of data now in current_buffer <br/>
		/// </summary>
		public nuint CurrentBufferSize;

		/// <summary>
		/// what push library is currently doing <br/>
		/// </summary>
		public int ProcessMode;

		/// <summary>
		/// current push library palette index <br/>
		/// </summary>
		public int CurPalette;

		/// <summary>
		/// lookup table for quantizing <br/>
		/// </summary>
		public unsafe byte* PaletteLookup;

		/// <summary>
		/// index translation for palette files <br/>
		/// </summary>
		public unsafe byte* QuantizeIndex;

		/// <summary>
		/// On/off state (up to 16 options) <br/>
		/// </summary>
		public uint Options;

		/// <summary>
		/// String to hold RFC 1123 time text <br/>
		/// </summary>
		public byte TimeBuffer_0;
		public byte TimeBuffer_1;
		public byte TimeBuffer_2;
		public byte TimeBuffer_3;
		public byte TimeBuffer_4;
		public byte TimeBuffer_5;
		public byte TimeBuffer_6;
		public byte TimeBuffer_7;
		public byte TimeBuffer_8;
		public byte TimeBuffer_9;
		public byte TimeBuffer_10;
		public byte TimeBuffer_11;
		public byte TimeBuffer_12;
		public byte TimeBuffer_13;
		public byte TimeBuffer_14;
		public byte TimeBuffer_15;
		public byte TimeBuffer_16;
		public byte TimeBuffer_17;
		public byte TimeBuffer_18;
		public byte TimeBuffer_19;
		public byte TimeBuffer_20;
		public byte TimeBuffer_21;
		public byte TimeBuffer_22;
		public byte TimeBuffer_23;
		public byte TimeBuffer_24;
		public byte TimeBuffer_25;
		public byte TimeBuffer_26;
		public byte TimeBuffer_27;
		public byte TimeBuffer_28;

		/// <summary>
		/// flags items libpng is responsible for freeing <br/>
		/// </summary>
		public uint FreeMe;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserChunkPtr;

		/// <summary>
		/// user read chunk handler <br/>
		/// </summary>
		public unsafe void* ReadUserChunkFn;

		/// <summary>
		/// As PNG_HANDLE_* <br/>
		/// </summary>
		public int UnknownDefault;

		/// <summary>
		/// Number of entries in the list <br/>
		/// </summary>
		public uint NumChunkList;

		/// <summary>
		/// List of png_byte[5]; the textual chunk name<br/>
		/// followed by a PNG_HANDLE_* byte <br/>
		/// </summary>
		public unsafe byte* ChunkList;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte RgbToGrayStatus;

		/// <summary>
		/// Added in libpng 1.5.5 to record setting of coefficients: <br/>
		/// </summary>
		public byte RgbToGrayCoefficientsSet;

		/// <summary>
		/// These were changed from png_byte in libpng-1.0.6 <br/>
		/// </summary>
		public ushort RgbToGrayRedCoeff;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort RgbToGrayGreenCoeff;

		/// <summary>
		/// buffer for accelerated palette expansion <br/>
		/// </summary>
		public unsafe byte* RiffledPalette;

		/// <summary>
		/// Changed from png_byte to png_uint_32 at version 1.2.0 <br/>
		/// </summary>
		public uint MngFeaturesPermitted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte FilterType;

		/// <summary>
		/// user supplied struct for mem functions <br/>
		/// </summary>
		public unsafe void* MemPtr;

		/// <summary>
		/// function for allocating memory <br/>
		/// </summary>
		public unsafe void* MallocFn;

		/// <summary>
		/// function for freeing memory <br/>
		/// </summary>
		public unsafe void* FreeFn;

		/// <summary>
		/// buffer to save current (unfiltered) row <br/>
		/// </summary>
		public unsafe byte* BigRowBuf;

		/// <summary>
		/// working sort array <br/>
		/// </summary>
		public unsafe byte* QuantizeSort;

		/// <summary>
		/// where the original index currently is<br/>
		/// in the palette <br/>
		/// </summary>
		public unsafe byte* IndexToPalette;

		/// <summary>
		/// which original index points to this<br/>
		/// palette color <br/>
		/// </summary>
		public unsafe byte* PaletteToIndex;

		/// <summary>
		/// New members added in libpng-1.0.16 and 1.2.6 <br/>
		/// </summary>
		public byte CompressionType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint UserWidthMax;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint UserHeightMax;

		/// <summary>
		/// Added in libpng-1.4.0: Total number of sPLT, text, and unknown<br/>
		/// chunks that can be stored (0 means unlimited).<br/>
		/// </summary>
		public uint UserChunkCacheMax;

		/// <summary>
		/// Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk<br/>
		/// can occupy when decompressed.  0 means unlimited.<br/>
		/// </summary>
		public nint UserChunkMallocMax;

		/// <summary>
		/// Temporary storage for unknown chunk that the library doesn't recognize,<br/>
		/// used while reading the chunk.<br/>
		/// </summary>
		public PngUnknownChunk UnknownChunk;

		/// <summary>
		/// New member added in libpng-1.2.26 <br/>
		/// </summary>
		public nuint OldBigRowBufSize;

		/// <summary>
		/// buffer for reading chunk data <br/>
		/// </summary>
		public unsafe byte* ReadBuffer;

		/// <summary>
		/// current size of the buffer <br/>
		/// </summary>
		public nint ReadBufferSize;

		/// <summary>
		/// limit on read buffer size for IDAT <br/>
		/// </summary>
		public uint IDATReadSize;

		/// <summary>
		/// New member added in libpng-1.4.0 <br/>
		/// </summary>
		public uint IoState;

		/// <summary>
		/// New member added in libpng-1.5.6 <br/>
		/// </summary>
		public unsafe byte* BigPrevRow;

		/// <summary>
		/// New member added in libpng-1.5.7 <br/>
		/// </summary>
		public nint ReadFilter_0;
		public nint ReadFilter_1;
		public nint ReadFilter_2;
		public nint ReadFilter_3;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe PngStruct(JmpBuf jmpBufLocal = default, delegate*<void> longjmpFn = default, JmpBuf* jmpBufPtr = default, nuint jmpBufSize = default, delegate*<void> errorFn = default, delegate*<void> warningFn = default, void* errorPtr = default, delegate*<void> writeDataFn = default, delegate*<void> readDataFn = default, void* ioPtr = default, delegate*<void> readUserTransformFn = default, delegate*<void> writeUserTransformFn = default, void* userTransformPtr = default, byte userTransformDepth = default, byte userTransformChannels = default, uint mode = default, uint flags = default, uint transformations = default, uint zowner = default, ZStream zstream = default, PngCompressionBuffer* zbufferList = default, uint zbufferSize = default, int zlibLevel = default, int zlibMethod = default, int zlibWindowBits = default, int zlibMemLevel = default, int zlibStrategy = default, int zlibTextLevel = default, int zlibTextMethod = default, int zlibTextWindowBits = default, int zlibTextMemLevel = default, int zlibTextStrategy = default, int zlibSetLevel = default, int zlibSetMethod = default, int zlibSetWindowBits = default, int zlibSetMemLevel = default, int zlibSetStrategy = default, uint chunks = default, uint width = default, uint height = default, uint numRows = default, uint usrWidth = default, nuint rowbytes = default, uint iwidth = default, uint rowNumber = default, uint chunkName = default, byte* prevRow = default, byte* rowBuf = default, byte* tryRow = default, byte* tstRow = default, nuint infoRowbytes = default, uint idatSize = default, uint crc = default, PngColor* palette = default, ushort numPalette = default, int numPaletteMax = default, ushort numTrans = default, byte compression = default, byte filter = default, byte interlaced = default, byte pass = default, byte doFilter = default, byte colorType = default, byte bitDepth = default, byte usrBitDepth = default, byte pixelDepth = default, byte channels = default, byte usrChannels = default, byte sigBytes = default, byte maximumPixelDepth = default, byte transformedPixelDepth = default, byte zstreamStart = default, ushort filler = default, byte backgroundGammaType = default, int backgroundGamma = default, PngColor16 background = default, PngColor16 background1 = default, delegate*<void> outputFlushFn = default, uint flushDist = default, uint flushRows = default, PngXy chromaticities = default, int gammaShift = default, int screenGamma = default, int fileGamma = default, int chunkGamma = default, int defaultGamma = default, byte* gammaTable = default, ushort** gamma16Table = default, byte* gammaFrom1 = default, byte* gammaTo1 = default, ushort** gamma16From1 = default, ushort** gamma16To1 = default, PngColor8 sigBit = default, PngColor8 shift = default, byte* transAlpha = default, PngColor16 transColor = default, delegate*<void> readRowFn = default, delegate*<void> writeRowFn = default, delegate*<void> infoFn = default, delegate*<void> rowFn = default, delegate*<void> endFn = default, byte* saveBufferPtr = default, byte* saveBuffer = default, byte* currentBufferPtr = default, byte* currentBuffer = default, uint pushLength = default, uint skipLength = default, nuint saveBufferSize = default, nuint saveBufferMax = default, nuint bufferSize = default, nuint currentBufferSize = default, int processMode = default, int curPalette = default, byte* paletteLookup = default, byte* quantizeIndex = default, uint options = default, byte* timeBuffer = default, uint freeMe = default, void* userChunkPtr = default, delegate*<int> readUserChunkFn = default, int unknownDefault = default, uint numChunkList = default, byte* chunkList = default, byte rgbToGrayStatus = default, byte rgbToGrayCoefficientsSet = default, ushort rgbToGrayRedCoeff = default, ushort rgbToGrayGreenCoeff = default, byte* riffledPalette = default, uint mngFeaturesPermitted = default, byte filterType = default, void* memPtr = default, delegate*<void*> mallocFn = default, delegate*<void> freeFn = default, byte* bigRowBuf = default, byte* quantizeSort = default, byte* indexToPalette = default, byte* paletteToIndex = default, byte compressionType = default, uint userWidthMax = default, uint userHeightMax = default, uint userChunkCacheMax = default, nint userChunkMallocMax = default, PngUnknownChunk unknownChunk = default, nuint oldBigRowBufSize = default, byte* readBuffer = default, nint readBufferSize = default, uint idatReadSize = default, uint ioState = default, byte* bigPrevRow = default, nint* readFilter = default)
		{
			JmpBufLocal = jmpBufLocal;
			LongjmpFn = (delegate*<void>*)longjmpFn;
			JmpBufPtr = jmpBufPtr;
			JmpBufSize = jmpBufSize;
			ErrorFn = (delegate*<void>*)errorFn;
			WarningFn = (delegate*<void>*)warningFn;
			ErrorPtr = errorPtr;
			WriteDataFn = (delegate*<void>*)writeDataFn;
			ReadDataFn = (delegate*<void>*)readDataFn;
			IoPtr = ioPtr;
			ReadUserTransformFn = (delegate*<void>*)readUserTransformFn;
			WriteUserTransformFn = (delegate*<void>*)writeUserTransformFn;
			UserTransformPtr = userTransformPtr;
			UserTransformDepth = userTransformDepth;
			UserTransformChannels = userTransformChannels;
			Mode = mode;
			Flags = flags;
			Transformations = transformations;
			Zowner = zowner;
			Zstream = zstream;
			ZbufferList = zbufferList;
			ZbufferSize = zbufferSize;
			ZlibLevel = zlibLevel;
			ZlibMethod = zlibMethod;
			ZlibWindowBits = zlibWindowBits;
			ZlibMemLevel = zlibMemLevel;
			ZlibStrategy = zlibStrategy;
			ZlibTextLevel = zlibTextLevel;
			ZlibTextMethod = zlibTextMethod;
			ZlibTextWindowBits = zlibTextWindowBits;
			ZlibTextMemLevel = zlibTextMemLevel;
			ZlibTextStrategy = zlibTextStrategy;
			ZlibSetLevel = zlibSetLevel;
			ZlibSetMethod = zlibSetMethod;
			ZlibSetWindowBits = zlibSetWindowBits;
			ZlibSetMemLevel = zlibSetMemLevel;
			ZlibSetStrategy = zlibSetStrategy;
			Chunks = chunks;
			Width = width;
			Height = height;
			NumRows = numRows;
			UsrWidth = usrWidth;
			Rowbytes = rowbytes;
			Iwidth = iwidth;
			RowNumber = rowNumber;
			ChunkName = chunkName;
			PrevRow = prevRow;
			RowBuf = rowBuf;
			TryRow = tryRow;
			TstRow = tstRow;
			InfoRowbytes = infoRowbytes;
			IdatSize = idatSize;
			Crc = crc;
			Palette = palette;
			NumPalette = numPalette;
			NumPaletteMax = numPaletteMax;
			NumTrans = numTrans;
			Compression = compression;
			Filter = filter;
			Interlaced = interlaced;
			Pass = pass;
			DoFilter = doFilter;
			ColorType = colorType;
			BitDepth = bitDepth;
			UsrBitDepth = usrBitDepth;
			PixelDepth = pixelDepth;
			Channels = channels;
			UsrChannels = usrChannels;
			SigBytes = sigBytes;
			MaximumPixelDepth = maximumPixelDepth;
			TransformedPixelDepth = transformedPixelDepth;
			ZstreamStart = zstreamStart;
			Filler = filler;
			BackgroundGammaType = backgroundGammaType;
			BackgroundGamma = backgroundGamma;
			Background = background;
			Background1 = background1;
			OutputFlushFn = (delegate*<void>*)outputFlushFn;
			FlushDist = flushDist;
			FlushRows = flushRows;
			Chromaticities = chromaticities;
			GammaShift = gammaShift;
			ScreenGamma = screenGamma;
			FileGamma = fileGamma;
			ChunkGamma = chunkGamma;
			DefaultGamma = defaultGamma;
			GammaTable = gammaTable;
			Gamma16Table = gamma16Table;
			GammaFrom1 = gammaFrom1;
			GammaTo1 = gammaTo1;
			Gamma16From1 = gamma16From1;
			Gamma16To1 = gamma16To1;
			SigBit = sigBit;
			Shift = shift;
			TransAlpha = transAlpha;
			TransColor = transColor;
			ReadRowFn = (delegate*<void>*)readRowFn;
			WriteRowFn = (delegate*<void>*)writeRowFn;
			InfoFn = (delegate*<void>*)infoFn;
			RowFn = (delegate*<void>*)rowFn;
			EndFn = (delegate*<void>*)endFn;
			SaveBufferPtr = saveBufferPtr;
			SaveBuffer = saveBuffer;
			CurrentBufferPtr = currentBufferPtr;
			CurrentBuffer = currentBuffer;
			PushLength = pushLength;
			SkipLength = skipLength;
			SaveBufferSize = saveBufferSize;
			SaveBufferMax = saveBufferMax;
			BufferSize = bufferSize;
			CurrentBufferSize = currentBufferSize;
			ProcessMode = processMode;
			CurPalette = curPalette;
			PaletteLookup = paletteLookup;
			QuantizeIndex = quantizeIndex;
			Options = options;
			if (timeBuffer != default(byte*))
			{
				TimeBuffer_0 = timeBuffer[0];
				TimeBuffer_1 = timeBuffer[1];
				TimeBuffer_2 = timeBuffer[2];
				TimeBuffer_3 = timeBuffer[3];
				TimeBuffer_4 = timeBuffer[4];
				TimeBuffer_5 = timeBuffer[5];
				TimeBuffer_6 = timeBuffer[6];
				TimeBuffer_7 = timeBuffer[7];
				TimeBuffer_8 = timeBuffer[8];
				TimeBuffer_9 = timeBuffer[9];
				TimeBuffer_10 = timeBuffer[10];
				TimeBuffer_11 = timeBuffer[11];
				TimeBuffer_12 = timeBuffer[12];
				TimeBuffer_13 = timeBuffer[13];
				TimeBuffer_14 = timeBuffer[14];
				TimeBuffer_15 = timeBuffer[15];
				TimeBuffer_16 = timeBuffer[16];
				TimeBuffer_17 = timeBuffer[17];
				TimeBuffer_18 = timeBuffer[18];
				TimeBuffer_19 = timeBuffer[19];
				TimeBuffer_20 = timeBuffer[20];
				TimeBuffer_21 = timeBuffer[21];
				TimeBuffer_22 = timeBuffer[22];
				TimeBuffer_23 = timeBuffer[23];
				TimeBuffer_24 = timeBuffer[24];
				TimeBuffer_25 = timeBuffer[25];
				TimeBuffer_26 = timeBuffer[26];
				TimeBuffer_27 = timeBuffer[27];
				TimeBuffer_28 = timeBuffer[28];
			}
			FreeMe = freeMe;
			UserChunkPtr = userChunkPtr;
			ReadUserChunkFn = (delegate*<int>*)readUserChunkFn;
			UnknownDefault = unknownDefault;
			NumChunkList = numChunkList;
			ChunkList = chunkList;
			RgbToGrayStatus = rgbToGrayStatus;
			RgbToGrayCoefficientsSet = rgbToGrayCoefficientsSet;
			RgbToGrayRedCoeff = rgbToGrayRedCoeff;
			RgbToGrayGreenCoeff = rgbToGrayGreenCoeff;
			RiffledPalette = riffledPalette;
			MngFeaturesPermitted = mngFeaturesPermitted;
			FilterType = filterType;
			MemPtr = memPtr;
			MallocFn = (delegate*<void*>*)mallocFn;
			FreeFn = (delegate*<void>*)freeFn;
			BigRowBuf = bigRowBuf;
			QuantizeSort = quantizeSort;
			IndexToPalette = indexToPalette;
			PaletteToIndex = paletteToIndex;
			CompressionType = compressionType;
			UserWidthMax = userWidthMax;
			UserHeightMax = userHeightMax;
			UserChunkCacheMax = userChunkCacheMax;
			UserChunkMallocMax = userChunkMallocMax;
			UnknownChunk = unknownChunk;
			OldBigRowBufSize = oldBigRowBufSize;
			ReadBuffer = readBuffer;
			ReadBufferSize = readBufferSize;
			IDATReadSize = idatReadSize;
			IoState = ioState;
			BigPrevRow = bigPrevRow;
			if (readFilter != default(nint*))
			{
				ReadFilter_0 = readFilter[0];
				ReadFilter_1 = readFilter[1];
				ReadFilter_2 = readFilter[2];
				ReadFilter_3 = readFilter[3];
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe PngStruct(JmpBuf jmpBufLocal = default, delegate*<void> longjmpFn = default, JmpBuf* jmpBufPtr = default, nuint jmpBufSize = default, delegate*<void> errorFn = default, delegate*<void> warningFn = default, void* errorPtr = default, delegate*<void> writeDataFn = default, delegate*<void> readDataFn = default, void* ioPtr = default, delegate*<void> readUserTransformFn = default, delegate*<void> writeUserTransformFn = default, void* userTransformPtr = default, byte userTransformDepth = default, byte userTransformChannels = default, uint mode = default, uint flags = default, uint transformations = default, uint zowner = default, ZStream zstream = default, PngCompressionBuffer* zbufferList = default, uint zbufferSize = default, int zlibLevel = default, int zlibMethod = default, int zlibWindowBits = default, int zlibMemLevel = default, int zlibStrategy = default, int zlibTextLevel = default, int zlibTextMethod = default, int zlibTextWindowBits = default, int zlibTextMemLevel = default, int zlibTextStrategy = default, int zlibSetLevel = default, int zlibSetMethod = default, int zlibSetWindowBits = default, int zlibSetMemLevel = default, int zlibSetStrategy = default, uint chunks = default, uint width = default, uint height = default, uint numRows = default, uint usrWidth = default, nuint rowbytes = default, uint iwidth = default, uint rowNumber = default, uint chunkName = default, byte* prevRow = default, byte* rowBuf = default, byte* tryRow = default, byte* tstRow = default, nuint infoRowbytes = default, uint idatSize = default, uint crc = default, PngColor* palette = default, ushort numPalette = default, int numPaletteMax = default, ushort numTrans = default, byte compression = default, byte filter = default, byte interlaced = default, byte pass = default, byte doFilter = default, byte colorType = default, byte bitDepth = default, byte usrBitDepth = default, byte pixelDepth = default, byte channels = default, byte usrChannels = default, byte sigBytes = default, byte maximumPixelDepth = default, byte transformedPixelDepth = default, byte zstreamStart = default, ushort filler = default, byte backgroundGammaType = default, int backgroundGamma = default, PngColor16 background = default, PngColor16 background1 = default, delegate*<void> outputFlushFn = default, uint flushDist = default, uint flushRows = default, PngXy chromaticities = default, int gammaShift = default, int screenGamma = default, int fileGamma = default, int chunkGamma = default, int defaultGamma = default, byte* gammaTable = default, ushort** gamma16Table = default, byte* gammaFrom1 = default, byte* gammaTo1 = default, ushort** gamma16From1 = default, ushort** gamma16To1 = default, PngColor8 sigBit = default, PngColor8 shift = default, byte* transAlpha = default, PngColor16 transColor = default, delegate*<void> readRowFn = default, delegate*<void> writeRowFn = default, delegate*<void> infoFn = default, delegate*<void> rowFn = default, delegate*<void> endFn = default, byte* saveBufferPtr = default, byte* saveBuffer = default, byte* currentBufferPtr = default, byte* currentBuffer = default, uint pushLength = default, uint skipLength = default, nuint saveBufferSize = default, nuint saveBufferMax = default, nuint bufferSize = default, nuint currentBufferSize = default, int processMode = default, int curPalette = default, byte* paletteLookup = default, byte* quantizeIndex = default, uint options = default, Span<byte> timeBuffer = default, uint freeMe = default, void* userChunkPtr = default, delegate*<int> readUserChunkFn = default, int unknownDefault = default, uint numChunkList = default, byte* chunkList = default, byte rgbToGrayStatus = default, byte rgbToGrayCoefficientsSet = default, ushort rgbToGrayRedCoeff = default, ushort rgbToGrayGreenCoeff = default, byte* riffledPalette = default, uint mngFeaturesPermitted = default, byte filterType = default, void* memPtr = default, delegate*<void*> mallocFn = default, delegate*<void> freeFn = default, byte* bigRowBuf = default, byte* quantizeSort = default, byte* indexToPalette = default, byte* paletteToIndex = default, byte compressionType = default, uint userWidthMax = default, uint userHeightMax = default, uint userChunkCacheMax = default, nint userChunkMallocMax = default, PngUnknownChunk unknownChunk = default, nuint oldBigRowBufSize = default, byte* readBuffer = default, nint readBufferSize = default, uint idatReadSize = default, uint ioState = default, byte* bigPrevRow = default, Span<nint> readFilter = default)
		{
			JmpBufLocal = jmpBufLocal;
			LongjmpFn = (delegate*<void>*)longjmpFn;
			JmpBufPtr = jmpBufPtr;
			JmpBufSize = jmpBufSize;
			ErrorFn = (delegate*<void>*)errorFn;
			WarningFn = (delegate*<void>*)warningFn;
			ErrorPtr = errorPtr;
			WriteDataFn = (delegate*<void>*)writeDataFn;
			ReadDataFn = (delegate*<void>*)readDataFn;
			IoPtr = ioPtr;
			ReadUserTransformFn = (delegate*<void>*)readUserTransformFn;
			WriteUserTransformFn = (delegate*<void>*)writeUserTransformFn;
			UserTransformPtr = userTransformPtr;
			UserTransformDepth = userTransformDepth;
			UserTransformChannels = userTransformChannels;
			Mode = mode;
			Flags = flags;
			Transformations = transformations;
			Zowner = zowner;
			Zstream = zstream;
			ZbufferList = zbufferList;
			ZbufferSize = zbufferSize;
			ZlibLevel = zlibLevel;
			ZlibMethod = zlibMethod;
			ZlibWindowBits = zlibWindowBits;
			ZlibMemLevel = zlibMemLevel;
			ZlibStrategy = zlibStrategy;
			ZlibTextLevel = zlibTextLevel;
			ZlibTextMethod = zlibTextMethod;
			ZlibTextWindowBits = zlibTextWindowBits;
			ZlibTextMemLevel = zlibTextMemLevel;
			ZlibTextStrategy = zlibTextStrategy;
			ZlibSetLevel = zlibSetLevel;
			ZlibSetMethod = zlibSetMethod;
			ZlibSetWindowBits = zlibSetWindowBits;
			ZlibSetMemLevel = zlibSetMemLevel;
			ZlibSetStrategy = zlibSetStrategy;
			Chunks = chunks;
			Width = width;
			Height = height;
			NumRows = numRows;
			UsrWidth = usrWidth;
			Rowbytes = rowbytes;
			Iwidth = iwidth;
			RowNumber = rowNumber;
			ChunkName = chunkName;
			PrevRow = prevRow;
			RowBuf = rowBuf;
			TryRow = tryRow;
			TstRow = tstRow;
			InfoRowbytes = infoRowbytes;
			IdatSize = idatSize;
			Crc = crc;
			Palette = palette;
			NumPalette = numPalette;
			NumPaletteMax = numPaletteMax;
			NumTrans = numTrans;
			Compression = compression;
			Filter = filter;
			Interlaced = interlaced;
			Pass = pass;
			DoFilter = doFilter;
			ColorType = colorType;
			BitDepth = bitDepth;
			UsrBitDepth = usrBitDepth;
			PixelDepth = pixelDepth;
			Channels = channels;
			UsrChannels = usrChannels;
			SigBytes = sigBytes;
			MaximumPixelDepth = maximumPixelDepth;
			TransformedPixelDepth = transformedPixelDepth;
			ZstreamStart = zstreamStart;
			Filler = filler;
			BackgroundGammaType = backgroundGammaType;
			BackgroundGamma = backgroundGamma;
			Background = background;
			Background1 = background1;
			OutputFlushFn = (delegate*<void>*)outputFlushFn;
			FlushDist = flushDist;
			FlushRows = flushRows;
			Chromaticities = chromaticities;
			GammaShift = gammaShift;
			ScreenGamma = screenGamma;
			FileGamma = fileGamma;
			ChunkGamma = chunkGamma;
			DefaultGamma = defaultGamma;
			GammaTable = gammaTable;
			Gamma16Table = gamma16Table;
			GammaFrom1 = gammaFrom1;
			GammaTo1 = gammaTo1;
			Gamma16From1 = gamma16From1;
			Gamma16To1 = gamma16To1;
			SigBit = sigBit;
			Shift = shift;
			TransAlpha = transAlpha;
			TransColor = transColor;
			ReadRowFn = (delegate*<void>*)readRowFn;
			WriteRowFn = (delegate*<void>*)writeRowFn;
			InfoFn = (delegate*<void>*)infoFn;
			RowFn = (delegate*<void>*)rowFn;
			EndFn = (delegate*<void>*)endFn;
			SaveBufferPtr = saveBufferPtr;
			SaveBuffer = saveBuffer;
			CurrentBufferPtr = currentBufferPtr;
			CurrentBuffer = currentBuffer;
			PushLength = pushLength;
			SkipLength = skipLength;
			SaveBufferSize = saveBufferSize;
			SaveBufferMax = saveBufferMax;
			BufferSize = bufferSize;
			CurrentBufferSize = currentBufferSize;
			ProcessMode = processMode;
			CurPalette = curPalette;
			PaletteLookup = paletteLookup;
			QuantizeIndex = quantizeIndex;
			Options = options;
			if (timeBuffer != default(Span<byte>))
			{
				TimeBuffer_0 = timeBuffer[0];
				TimeBuffer_1 = timeBuffer[1];
				TimeBuffer_2 = timeBuffer[2];
				TimeBuffer_3 = timeBuffer[3];
				TimeBuffer_4 = timeBuffer[4];
				TimeBuffer_5 = timeBuffer[5];
				TimeBuffer_6 = timeBuffer[6];
				TimeBuffer_7 = timeBuffer[7];
				TimeBuffer_8 = timeBuffer[8];
				TimeBuffer_9 = timeBuffer[9];
				TimeBuffer_10 = timeBuffer[10];
				TimeBuffer_11 = timeBuffer[11];
				TimeBuffer_12 = timeBuffer[12];
				TimeBuffer_13 = timeBuffer[13];
				TimeBuffer_14 = timeBuffer[14];
				TimeBuffer_15 = timeBuffer[15];
				TimeBuffer_16 = timeBuffer[16];
				TimeBuffer_17 = timeBuffer[17];
				TimeBuffer_18 = timeBuffer[18];
				TimeBuffer_19 = timeBuffer[19];
				TimeBuffer_20 = timeBuffer[20];
				TimeBuffer_21 = timeBuffer[21];
				TimeBuffer_22 = timeBuffer[22];
				TimeBuffer_23 = timeBuffer[23];
				TimeBuffer_24 = timeBuffer[24];
				TimeBuffer_25 = timeBuffer[25];
				TimeBuffer_26 = timeBuffer[26];
				TimeBuffer_27 = timeBuffer[27];
				TimeBuffer_28 = timeBuffer[28];
			}
			FreeMe = freeMe;
			UserChunkPtr = userChunkPtr;
			ReadUserChunkFn = (delegate*<int>*)readUserChunkFn;
			UnknownDefault = unknownDefault;
			NumChunkList = numChunkList;
			ChunkList = chunkList;
			RgbToGrayStatus = rgbToGrayStatus;
			RgbToGrayCoefficientsSet = rgbToGrayCoefficientsSet;
			RgbToGrayRedCoeff = rgbToGrayRedCoeff;
			RgbToGrayGreenCoeff = rgbToGrayGreenCoeff;
			RiffledPalette = riffledPalette;
			MngFeaturesPermitted = mngFeaturesPermitted;
			FilterType = filterType;
			MemPtr = memPtr;
			MallocFn = (delegate*<void*>*)mallocFn;
			FreeFn = (delegate*<void>*)freeFn;
			BigRowBuf = bigRowBuf;
			QuantizeSort = quantizeSort;
			IndexToPalette = indexToPalette;
			PaletteToIndex = paletteToIndex;
			CompressionType = compressionType;
			UserWidthMax = userWidthMax;
			UserHeightMax = userHeightMax;
			UserChunkCacheMax = userChunkCacheMax;
			UserChunkMallocMax = userChunkMallocMax;
			UnknownChunk = unknownChunk;
			OldBigRowBufSize = oldBigRowBufSize;
			ReadBuffer = readBuffer;
			ReadBufferSize = readBufferSize;
			IDATReadSize = idatReadSize;
			IoState = ioState;
			BigPrevRow = bigPrevRow;
			if (readFilter != default(Span<nint>))
			{
				ReadFilter_0 = readFilter[0];
				ReadFilter_1 = readFilter[1];
				ReadFilter_2 = readFilter[2];
				ReadFilter_3 = readFilter[3];
			}
		}


		/// <summary>
		/// New member added in libpng-1.5.7 <br/>
		/// </summary>
		public unsafe Span<nint> ReadFilter
		
		{
			get
			{
				fixed (nint* p = &this.ReadFilter_0)
				{
					return new Span<nint>(p, 4);
				}
			}
		}
	}

}
