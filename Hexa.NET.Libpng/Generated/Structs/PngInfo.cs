// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct PngInfo
	{
		/// <summary>
		/// width of image in pixels (from IHDR) <br/>
		/// </summary>
		public uint Width;

		/// <summary>
		/// height of image in pixels (from IHDR) <br/>
		/// </summary>
		public uint Height;

		/// <summary>
		/// valid chunk data (see PNG_INFO_ below) <br/>
		/// </summary>
		public uint Valid;

		/// <summary>
		/// bytes needed to hold an untransformed row <br/>
		/// </summary>
		public nuint Rowbytes;

		/// <summary>
		/// array of color values (valid <br/>
		/// &<br/>
		/// PNG_INFO_PLTE) <br/>
		/// </summary>
		public unsafe PngColor* Palette;

		/// <summary>
		/// number of color entries in "palette" (PLTE) <br/>
		/// </summary>
		public ushort NumPalette;

		/// <summary>
		/// number of transparent palette color (tRNS) <br/>
		/// </summary>
		public ushort NumTrans;

		/// <summary>
		/// 1, 2, 4, 8, or 16 bits/channel (from IHDR) <br/>
		/// </summary>
		public byte BitDepth;

		/// <summary>
		/// see PNG_COLOR_TYPE_ below (from IHDR) <br/>
		/// </summary>
		public byte ColorType;

		/// <summary>
		/// must be PNG_COMPRESSION_TYPE_BASE (IHDR) <br/>
		/// </summary>
		public byte CompressionType;

		/// <summary>
		/// must be PNG_FILTER_TYPE_BASE (from IHDR) <br/>
		/// </summary>
		public byte FilterType;

		/// <summary>
		/// One of PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 <br/>
		/// </summary>
		public byte InterlaceType;

		/// <summary>
		/// number of data channels per pixel (1, 2, 3, 4) <br/>
		/// </summary>
		public byte Channels;

		/// <summary>
		/// number of bits per pixel <br/>
		/// </summary>
		public byte PixelDepth;

		/// <summary>
		/// to align the data, and for future use <br/>
		/// </summary>
		public byte SpareByte;

		/// <summary>
		/// magic bytes read by libpng from start of file <br/>
		/// </summary>
		public byte Signature_0;
		public byte Signature_1;
		public byte Signature_2;
		public byte Signature_3;
		public byte Signature_4;
		public byte Signature_5;
		public byte Signature_6;
		public byte Signature_7;

		/// <summary>
		/// cICP chunk data <br/>
		/// </summary>
		public byte CicpColourPrimaries;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CicpTransferFunction;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CicpMatrixCoefficients;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CicpVideoFullRangeFlag;

		/// <summary>
		/// profile name <br/>
		/// </summary>
		public unsafe byte* IccpName;

		/// <summary>
		/// International Color Consortium profile data <br/>
		/// </summary>
		public unsafe byte* IccpProfile;

		/// <summary>
		/// ICC profile data length <br/>
		/// </summary>
		public uint IccpProflen;

		/// <summary>
		/// cd/m2 (nits) * 10,000 <br/>
		/// </summary>
		public uint MaxCLL;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint MaxFALL;

		/// <summary>
		/// CIE (xy) x * 50,000 <br/>
		/// </summary>
		public ushort MasteringRedX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringRedY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringGreenX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringGreenY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringBlueX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringBlueY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringWhiteX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MasteringWhiteY;

		/// <summary>
		/// cd/m2 (nits) * 10,000 <br/>
		/// </summary>
		public uint MasteringMaxDL;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint MasteringMinDL;

		/// <summary>
		/// number of comments read or comments to write <br/>
		/// </summary>
		public int NumText;

		/// <summary>
		/// current size of text array <br/>
		/// </summary>
		public int MaxText;

		/// <summary>
		/// array of comments read or comments to write <br/>
		/// </summary>
		public unsafe PngText* Text;

		/// <summary>
		/// The tIME chunk holds the last time the displayed image data was<br/>
		/// modified.  See the png_time struct for the contents of this struct.<br/>
		/// </summary>
		public PngTime ModTime;

		/// <summary>
		/// significant bits in color channels <br/>
		/// </summary>
		public PngColor8 SigBit;

		/// <summary>
		/// alpha values for paletted image <br/>
		/// </summary>
		public unsafe byte* TransAlpha;

		/// <summary>
		/// transparent color for non-palette image <br/>
		/// </summary>
		public PngColor16 TransColor;

		/// <summary>
		/// The bKGD chunk gives the suggested image background color if the<br/>
		/// display program does not have its own background color and the image<br/>
		/// is needs to composited onto a background before display.  The colors<br/>
		/// in "background" are normally in the same color space/depth as the<br/>
		/// pixel data.  Data is valid if (valid <br/>
		/// &<br/>
		/// PNG_INFO_bKGD) is non-zero.<br/>
		/// </summary>
		public PngColor16 Background;

		/// <summary>
		/// x offset on page <br/>
		/// </summary>
		public int XOffset;

		/// <summary>
		/// y offset on page <br/>
		/// </summary>
		public int YOffset;

		/// <summary>
		/// offset units type <br/>
		/// </summary>
		public byte OffsetUnitType;

		/// <summary>
		/// horizontal pixel density <br/>
		/// </summary>
		public uint XPixelsPerUnit;

		/// <summary>
		/// vertical pixel density <br/>
		/// </summary>
		public uint YPixelsPerUnit;

		/// <summary>
		/// resolution type (see PNG_RESOLUTION_ below) <br/>
		/// </summary>
		public byte PhysUnitType;

		/// <summary>
		/// Added at libpng-1.6.31 <br/>
		/// </summary>
		public uint NumExif;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Exif;

		/// <summary>
		/// The hIST chunk contains the relative frequency or importance of the<br/>
		/// various palette entries, so that a viewer can intelligently select a<br/>
		/// reduced-color palette, if required.  Data is an array of "num_palette"<br/>
		/// values in the range [0,65535]. Data valid if (valid <br/>
		/// &<br/>
		/// PNG_INFO_hIST)<br/>
		/// is non-zero.<br/>
		/// </summary>
		public unsafe ushort* Hist;

		/// <summary>
		/// pCAL chunk description string <br/>
		/// </summary>
		public unsafe byte* PcalPurpose;

		/// <summary>
		/// minimum value <br/>
		/// </summary>
		public int PcalX0;

		/// <summary>
		/// maximum value <br/>
		/// </summary>
		public int PcalX1;

		/// <summary>
		/// Latin-1 string giving physical units <br/>
		/// </summary>
		public unsafe byte* PcalUnits;

		/// <summary>
		/// ASCII strings containing parameter values <br/>
		/// </summary>
		public unsafe byte** PcalParams;

		/// <summary>
		/// equation type (see PNG_EQUATION_ below) <br/>
		/// </summary>
		public byte PcalType;

		/// <summary>
		/// number of parameters given in pcal_params <br/>
		/// </summary>
		public byte PcalNparams;

		/// <summary>
		/// flags items libpng is responsible for freeing <br/>
		/// </summary>
		public uint FreeMe;

		/// <summary>
		/// Storage for unknown chunks that the library doesn't recognize. <br/>
		/// </summary>
		public unsafe PngUnknownChunk* UnknownChunks;

		/// <summary>
		/// The type of this field is limited by the type of<br/>
		/// png_struct::user_chunk_cache_max, else overflow can occur.<br/>
		/// </summary>
		public int UnknownChunksNum;

		/// <summary>
		/// Data on sPLT chunks (there may be more than one). <br/>
		/// </summary>
		public unsafe PngSPLT* SpltPalettes;

		/// <summary>
		/// Match type returned by png_get API <br/>
		/// </summary>
		public int SpltPalettesNum;

		/// <summary>
		/// unit of physical scale <br/>
		/// </summary>
		public byte ScalUnit;

		/// <summary>
		/// string containing height <br/>
		/// </summary>
		public unsafe byte* ScalSWidth;

		/// <summary>
		/// string containing width <br/>
		/// </summary>
		public unsafe byte* ScalSHeight;

		/// <summary>
		/// the image bits <br/>
		/// </summary>
		public unsafe byte** RowPointers;

		/// <summary>
		/// To be documented.
		/// </summary>
		public PngXy CHRM;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Gamma;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RenderingIntent;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe PngInfo(uint width = default, uint height = default, uint valid = default, nuint rowbytes = default, PngColor* palette = default, ushort numPalette = default, ushort numTrans = default, byte bitDepth = default, byte colorType = default, byte compressionType = default, byte filterType = default, byte interlaceType = default, byte channels = default, byte pixelDepth = default, byte spareByte = default, byte* signature = default, byte cicpColourPrimaries = default, byte cicpTransferFunction = default, byte cicpMatrixCoefficients = default, byte cicpVideoFullRangeFlag = default, byte* iccpName = default, byte* iccpProfile = default, uint iccpProflen = default, uint maxCLL = default, uint maxFALL = default, ushort masteringRedX = default, ushort masteringRedY = default, ushort masteringGreenX = default, ushort masteringGreenY = default, ushort masteringBlueX = default, ushort masteringBlueY = default, ushort masteringWhiteX = default, ushort masteringWhiteY = default, uint masteringMaxdl = default, uint masteringMindl = default, int numText = default, int maxText = default, PngText* text = default, PngTime modTime = default, PngColor8 sigBit = default, byte* transAlpha = default, PngColor16 transColor = default, PngColor16 background = default, int xOffset = default, int yOffset = default, byte offsetUnitType = default, uint xPixelsPerUnit = default, uint yPixelsPerUnit = default, byte physUnitType = default, uint numExif = default, byte* exif = default, ushort* hist = default, byte* pcalPurpose = default, int pcalX0 = default, int pcalX1 = default, byte* pcalUnits = default, byte** pcalParams = default, byte pcalType = default, byte pcalNparams = default, uint freeMe = default, PngUnknownChunk* unknownChunks = default, int unknownChunksNum = default, PngSPLT* spltPalettes = default, int spltPalettesNum = default, byte scalUnit = default, byte* scalSWidth = default, byte* scalSHeight = default, byte** rowPointers = default, PngXy chRm = default, int gamma = default, int renderingIntent = default)
		{
			Width = width;
			Height = height;
			Valid = valid;
			Rowbytes = rowbytes;
			Palette = palette;
			NumPalette = numPalette;
			NumTrans = numTrans;
			BitDepth = bitDepth;
			ColorType = colorType;
			CompressionType = compressionType;
			FilterType = filterType;
			InterlaceType = interlaceType;
			Channels = channels;
			PixelDepth = pixelDepth;
			SpareByte = spareByte;
			if (signature != default(byte*))
			{
				Signature_0 = signature[0];
				Signature_1 = signature[1];
				Signature_2 = signature[2];
				Signature_3 = signature[3];
				Signature_4 = signature[4];
				Signature_5 = signature[5];
				Signature_6 = signature[6];
				Signature_7 = signature[7];
			}
			CicpColourPrimaries = cicpColourPrimaries;
			CicpTransferFunction = cicpTransferFunction;
			CicpMatrixCoefficients = cicpMatrixCoefficients;
			CicpVideoFullRangeFlag = cicpVideoFullRangeFlag;
			IccpName = iccpName;
			IccpProfile = iccpProfile;
			IccpProflen = iccpProflen;
			MaxCLL = maxCLL;
			MaxFALL = maxFALL;
			MasteringRedX = masteringRedX;
			MasteringRedY = masteringRedY;
			MasteringGreenX = masteringGreenX;
			MasteringGreenY = masteringGreenY;
			MasteringBlueX = masteringBlueX;
			MasteringBlueY = masteringBlueY;
			MasteringWhiteX = masteringWhiteX;
			MasteringWhiteY = masteringWhiteY;
			MasteringMaxDL = masteringMaxdl;
			MasteringMinDL = masteringMindl;
			NumText = numText;
			MaxText = maxText;
			Text = text;
			ModTime = modTime;
			SigBit = sigBit;
			TransAlpha = transAlpha;
			TransColor = transColor;
			Background = background;
			XOffset = xOffset;
			YOffset = yOffset;
			OffsetUnitType = offsetUnitType;
			XPixelsPerUnit = xPixelsPerUnit;
			YPixelsPerUnit = yPixelsPerUnit;
			PhysUnitType = physUnitType;
			NumExif = numExif;
			Exif = exif;
			Hist = hist;
			PcalPurpose = pcalPurpose;
			PcalX0 = pcalX0;
			PcalX1 = pcalX1;
			PcalUnits = pcalUnits;
			PcalParams = pcalParams;
			PcalType = pcalType;
			PcalNparams = pcalNparams;
			FreeMe = freeMe;
			UnknownChunks = unknownChunks;
			UnknownChunksNum = unknownChunksNum;
			SpltPalettes = spltPalettes;
			SpltPalettesNum = spltPalettesNum;
			ScalUnit = scalUnit;
			ScalSWidth = scalSWidth;
			ScalSHeight = scalSHeight;
			RowPointers = rowPointers;
			CHRM = chRm;
			Gamma = gamma;
			RenderingIntent = renderingIntent;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe PngInfo(uint width = default, uint height = default, uint valid = default, nuint rowbytes = default, PngColor* palette = default, ushort numPalette = default, ushort numTrans = default, byte bitDepth = default, byte colorType = default, byte compressionType = default, byte filterType = default, byte interlaceType = default, byte channels = default, byte pixelDepth = default, byte spareByte = default, Span<byte> signature = default, byte cicpColourPrimaries = default, byte cicpTransferFunction = default, byte cicpMatrixCoefficients = default, byte cicpVideoFullRangeFlag = default, byte* iccpName = default, byte* iccpProfile = default, uint iccpProflen = default, uint maxCLL = default, uint maxFALL = default, ushort masteringRedX = default, ushort masteringRedY = default, ushort masteringGreenX = default, ushort masteringGreenY = default, ushort masteringBlueX = default, ushort masteringBlueY = default, ushort masteringWhiteX = default, ushort masteringWhiteY = default, uint masteringMaxdl = default, uint masteringMindl = default, int numText = default, int maxText = default, PngText* text = default, PngTime modTime = default, PngColor8 sigBit = default, byte* transAlpha = default, PngColor16 transColor = default, PngColor16 background = default, int xOffset = default, int yOffset = default, byte offsetUnitType = default, uint xPixelsPerUnit = default, uint yPixelsPerUnit = default, byte physUnitType = default, uint numExif = default, byte* exif = default, ushort* hist = default, byte* pcalPurpose = default, int pcalX0 = default, int pcalX1 = default, byte* pcalUnits = default, byte** pcalParams = default, byte pcalType = default, byte pcalNparams = default, uint freeMe = default, PngUnknownChunk* unknownChunks = default, int unknownChunksNum = default, PngSPLT* spltPalettes = default, int spltPalettesNum = default, byte scalUnit = default, byte* scalSWidth = default, byte* scalSHeight = default, byte** rowPointers = default, PngXy chRm = default, int gamma = default, int renderingIntent = default)
		{
			Width = width;
			Height = height;
			Valid = valid;
			Rowbytes = rowbytes;
			Palette = palette;
			NumPalette = numPalette;
			NumTrans = numTrans;
			BitDepth = bitDepth;
			ColorType = colorType;
			CompressionType = compressionType;
			FilterType = filterType;
			InterlaceType = interlaceType;
			Channels = channels;
			PixelDepth = pixelDepth;
			SpareByte = spareByte;
			if (signature != default(Span<byte>))
			{
				Signature_0 = signature[0];
				Signature_1 = signature[1];
				Signature_2 = signature[2];
				Signature_3 = signature[3];
				Signature_4 = signature[4];
				Signature_5 = signature[5];
				Signature_6 = signature[6];
				Signature_7 = signature[7];
			}
			CicpColourPrimaries = cicpColourPrimaries;
			CicpTransferFunction = cicpTransferFunction;
			CicpMatrixCoefficients = cicpMatrixCoefficients;
			CicpVideoFullRangeFlag = cicpVideoFullRangeFlag;
			IccpName = iccpName;
			IccpProfile = iccpProfile;
			IccpProflen = iccpProflen;
			MaxCLL = maxCLL;
			MaxFALL = maxFALL;
			MasteringRedX = masteringRedX;
			MasteringRedY = masteringRedY;
			MasteringGreenX = masteringGreenX;
			MasteringGreenY = masteringGreenY;
			MasteringBlueX = masteringBlueX;
			MasteringBlueY = masteringBlueY;
			MasteringWhiteX = masteringWhiteX;
			MasteringWhiteY = masteringWhiteY;
			MasteringMaxDL = masteringMaxdl;
			MasteringMinDL = masteringMindl;
			NumText = numText;
			MaxText = maxText;
			Text = text;
			ModTime = modTime;
			SigBit = sigBit;
			TransAlpha = transAlpha;
			TransColor = transColor;
			Background = background;
			XOffset = xOffset;
			YOffset = yOffset;
			OffsetUnitType = offsetUnitType;
			XPixelsPerUnit = xPixelsPerUnit;
			YPixelsPerUnit = yPixelsPerUnit;
			PhysUnitType = physUnitType;
			NumExif = numExif;
			Exif = exif;
			Hist = hist;
			PcalPurpose = pcalPurpose;
			PcalX0 = pcalX0;
			PcalX1 = pcalX1;
			PcalUnits = pcalUnits;
			PcalParams = pcalParams;
			PcalType = pcalType;
			PcalNparams = pcalNparams;
			FreeMe = freeMe;
			UnknownChunks = unknownChunks;
			UnknownChunksNum = unknownChunksNum;
			SpltPalettes = spltPalettes;
			SpltPalettesNum = spltPalettesNum;
			ScalUnit = scalUnit;
			ScalSWidth = scalSWidth;
			ScalSHeight = scalSHeight;
			RowPointers = rowPointers;
			CHRM = chRm;
			Gamma = gamma;
			RenderingIntent = renderingIntent;
		}


	}

}
