// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	public unsafe partial class Libpng
	{
		/// <summary>
		/// Returns the version number of the library <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint AccessVersionNumberNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[0])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// Returns the version number of the library <br/>
		/// </summary>
		public static uint AccessVersionNumber()
		{
			uint ret = AccessVersionNumberNative();
			return ret;
		}

		/// <summary>
		/// Tell lib we have already handled the first <br/>
		/// <num<br/>
		/// _bytes> magic bytes.<br/>
		/// Handling more than 8 bytes from the beginning of the file is an error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSigBytesNative(PngStruct* pngPtr, int numBytes)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[1])(pngPtr, numBytes);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[1])((nint)pngPtr, numBytes);
			#endif
		}

		/// <summary>
		/// Tell lib we have already handled the first <br/>
		/// <num<br/>
		/// _bytes> magic bytes.<br/>
		/// Handling more than 8 bytes from the beginning of the file is an error.<br/>
		/// </summary>
		public static void SetSigBytes(PngStruct* pngPtr, int numBytes)
		{
			SetSigBytesNative(pngPtr, numBytes);
		}

		/// <summary>
		/// Check sig[start] through sig[start + num_to_check - 1] to see if it's a<br/>
		/// PNG file.  Returns zero if the supplied bytes match the 8-byte PNG<br/>
		/// signature, and non-zero otherwise.  Having num_to_check == 0 or<br/>
		/// start > 7 will always fail (i.e. return non-zero).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SigCmpNative(byte* sig, nuint start, nuint numToCheck)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint, int>)funcTable[2])(sig, start, numToCheck);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nuint, int>)funcTable[2])((nint)sig, start, numToCheck);
			#endif
		}

		/// <summary>
		/// Check sig[start] through sig[start + num_to_check - 1] to see if it's a<br/>
		/// PNG file.  Returns zero if the supplied bytes match the 8-byte PNG<br/>
		/// signature, and non-zero otherwise.  Having num_to_check == 0 or<br/>
		/// start > 7 will always fail (i.e. return non-zero).<br/>
		/// </summary>
		public static int SigCmp(byte* sig, nuint start, nuint numToCheck)
		{
			int ret = SigCmpNative(sig, start, numToCheck);
			return ret;
		}

		/// <summary>
		/// Check sig[start] through sig[start + num_to_check - 1] to see if it's a<br/>
		/// PNG file.  Returns zero if the supplied bytes match the 8-byte PNG<br/>
		/// signature, and non-zero otherwise.  Having num_to_check == 0 or<br/>
		/// start > 7 will always fail (i.e. return non-zero).<br/>
		/// </summary>
		public static int SigCmp(ReadOnlySpan<byte> sig, nuint start, nuint numToCheck)
		{
			fixed (byte* psig = sig)
			{
				int ret = SigCmpNative((byte*)psig, start, numToCheck);
				return ret;
			}
		}

		/// <summary>
		/// Check sig[start] through sig[start + num_to_check - 1] to see if it's a<br/>
		/// PNG file.  Returns zero if the supplied bytes match the 8-byte PNG<br/>
		/// signature, and non-zero otherwise.  Having num_to_check == 0 or<br/>
		/// start > 7 will always fail (i.e. return non-zero).<br/>
		/// </summary>
		public static int SigCmp(string sig, nuint start, nuint numToCheck)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sig != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sig);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sig, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SigCmpNative(pStr0, start, numToCheck);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for reading, and any other memory. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngStruct* CreateReadStructNative(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, PngStruct*>)funcTable[3])(userPngVer, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warnFn));
			#else
			return (PngStruct*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[3])((nint)userPngVer, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warnFn));
			#endif
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for reading, and any other memory. <br/>
		/// </summary>
		public static PngStruct* CreateReadStruct(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			PngStruct* ret = CreateReadStructNative(userPngVer, errorPtr, errorFn, warnFn);
			return ret;
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for reading, and any other memory. <br/>
		/// </summary>
		public static PngStruct* CreateReadStruct(ReadOnlySpan<byte> userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				PngStruct* ret = CreateReadStructNative((byte*)puserPngVer, errorPtr, errorFn, warnFn);
				return ret;
			}
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for reading, and any other memory. <br/>
		/// </summary>
		public static PngStruct* CreateReadStruct(string userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PngStruct* ret = CreateReadStructNative(pStr0, errorPtr, errorFn, warnFn);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for writing, and any other memory <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngStruct* CreateWriteStructNative(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, PngStruct*>)funcTable[4])(userPngVer, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warnFn));
			#else
			return (PngStruct*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint>)funcTable[4])((nint)userPngVer, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warnFn));
			#endif
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for writing, and any other memory <br/>
		/// </summary>
		public static PngStruct* CreateWriteStruct(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			PngStruct* ret = CreateWriteStructNative(userPngVer, errorPtr, errorFn, warnFn);
			return ret;
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for writing, and any other memory <br/>
		/// </summary>
		public static PngStruct* CreateWriteStruct(ReadOnlySpan<byte> userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				PngStruct* ret = CreateWriteStructNative((byte*)puserPngVer, errorPtr, errorFn, warnFn);
				return ret;
			}
		}

		/// <summary>
		/// Allocate and initialize png_ptr struct for writing, and any other memory <br/>
		/// </summary>
		public static PngStruct* CreateWriteStruct(string userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PngStruct* ret = CreateWriteStructNative(pStr0, errorPtr, errorFn, warnFn);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint GetCompressionBufferSizeNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nuint>)funcTable[5])(pngPtr);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint>)funcTable[5])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetCompressionBufferSize(PngStruct* pngPtr)
		{
			nuint ret = GetCompressionBufferSizeNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionBufferSizeNative(PngStruct* pngPtr, nuint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, nuint, void>)funcTable[6])(pngPtr, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)funcTable[6])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCompressionBufferSize(PngStruct* pngPtr, nuint size)
		{
			SetCompressionBufferSizeNative(pngPtr, size);
		}

		/// <summary>
		/// This function returns the jmp_buf built in to *png_ptr.  It must be<br/>
		/// supplied with an appropriate 'longjmp' function to use on that jmp_buf<br/>
		/// unless the default error function is overridden in which case NULL is<br/>
		/// acceptable.  The size of the jmp_buf is checked against the actual size<br/>
		/// allocated by the library - the call will return NULL on a mismatch<br/>
		/// indicating an ABI mismatch.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static JmpBuf* SetLongjmpFnNative(PngStruct* pngPtr, PngLongjmpPtr longjmpFn, nuint jmpBufSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, delegate*<JmpBuf, int, void>, nuint, JmpBuf*>)funcTable[7])(pngPtr, (delegate*<JmpBuf, int, void>)Utils.GetFunctionPointerForDelegate(longjmpFn), jmpBufSize);
			#else
			return (JmpBuf*)((delegate* unmanaged[Cdecl]<nint, nint, nuint, nint>)funcTable[7])((nint)pngPtr, (nint)Utils.GetFunctionPointerForDelegate(longjmpFn), jmpBufSize);
			#endif
		}

		/// <summary>
		/// This function returns the jmp_buf built in to *png_ptr.  It must be<br/>
		/// supplied with an appropriate 'longjmp' function to use on that jmp_buf<br/>
		/// unless the default error function is overridden in which case NULL is<br/>
		/// acceptable.  The size of the jmp_buf is checked against the actual size<br/>
		/// allocated by the library - the call will return NULL on a mismatch<br/>
		/// indicating an ABI mismatch.<br/>
		/// </summary>
		public static JmpBuf* SetLongjmpFn(PngStruct* pngPtr, PngLongjmpPtr longjmpFn, nuint jmpBufSize)
		{
			JmpBuf* ret = SetLongjmpFnNative(pngPtr, longjmpFn, jmpBufSize);
			return ret;
		}

		/// <summary>
		/// This function should be used by libpng applications in place of<br/>
		/// longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it<br/>
		/// will use it; otherwise it will call PNG_ABORT().  This function was<br/>
		/// added in libpng-1.5.0.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LongjmpNative(PngStruct* pngPtr, int val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[8])(pngPtr, val);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[8])((nint)pngPtr, val);
			#endif
		}

		/// <summary>
		/// This function should be used by libpng applications in place of<br/>
		/// longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it<br/>
		/// will use it; otherwise it will call PNG_ABORT().  This function was<br/>
		/// added in libpng-1.5.0.<br/>
		/// </summary>
		public static void Longjmp(PngStruct* pngPtr, int val)
		{
			LongjmpNative(pngPtr, val);
		}

		/// <summary>
		/// Reset the compression stream <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ResetZstreamNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int>)funcTable[9])(pngPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[9])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Reset the compression stream <br/>
		/// </summary>
		public static int ResetZstream(PngStruct* pngPtr)
		{
			int ret = ResetZstreamNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngStruct* CreateReadStruct2Native(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, void*, delegate*<PngStruct*, nint, void*>, delegate*<PngStruct*, void*, void>, PngStruct*>)funcTable[10])(userPngVer, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warnFn), memPtr, (delegate*<PngStruct*, nint, void*>)Utils.GetFunctionPointerForDelegate(mallocFn), (delegate*<PngStruct*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFn));
			#else
			return (PngStruct*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, nint, nint>)funcTable[10])((nint)userPngVer, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warnFn), (nint)memPtr, (nint)Utils.GetFunctionPointerForDelegate(mallocFn), (nint)Utils.GetFunctionPointerForDelegate(freeFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateReadStruct2(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			PngStruct* ret = CreateReadStruct2Native(userPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateReadStruct2(ReadOnlySpan<byte> userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				PngStruct* ret = CreateReadStruct2Native((byte*)puserPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateReadStruct2(string userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PngStruct* ret = CreateReadStruct2Native(pStr0, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngStruct* CreateWriteStruct2Native(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, void*, delegate*<PngStruct*, nint, void*>, delegate*<PngStruct*, void*, void>, PngStruct*>)funcTable[11])(userPngVer, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warnFn), memPtr, (delegate*<PngStruct*, nint, void*>)Utils.GetFunctionPointerForDelegate(mallocFn), (delegate*<PngStruct*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFn));
			#else
			return (PngStruct*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, nint, nint>)funcTable[11])((nint)userPngVer, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warnFn), (nint)memPtr, (nint)Utils.GetFunctionPointerForDelegate(mallocFn), (nint)Utils.GetFunctionPointerForDelegate(freeFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateWriteStruct2(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			PngStruct* ret = CreateWriteStruct2Native(userPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateWriteStruct2(ReadOnlySpan<byte> userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				PngStruct* ret = CreateWriteStruct2Native((byte*)puserPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngStruct* CreateWriteStruct2(string userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PngStruct* ret = CreateWriteStruct2Native(pStr0, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Write the PNG file signature. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteSigNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[12])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[12])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Write the PNG file signature. <br/>
		/// </summary>
		public static void WriteSig(PngStruct* pngPtr)
		{
			WriteSigNative(pngPtr);
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteChunkNative(PngStruct* pngPtr, byte* chunkName, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, nuint, void>)funcTable[13])(pngPtr, chunkName, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, void>)funcTable[13])((nint)pngPtr, (nint)chunkName, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, byte* chunkName, byte* data, nuint length)
		{
			WriteChunkNative(pngPtr, chunkName, data, length);
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, ReadOnlySpan<byte> chunkName, byte* data, nuint length)
		{
			fixed (byte* pchunkName = chunkName)
			{
				WriteChunkNative(pngPtr, (byte*)pchunkName, data, length);
			}
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, string chunkName, byte* data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (chunkName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(chunkName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(chunkName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteChunkNative(pngPtr, pStr0, data, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, byte* chunkName, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				WriteChunkNative(pngPtr, chunkName, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, byte* chunkName, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteChunkNative(pngPtr, chunkName, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, ReadOnlySpan<byte> chunkName, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pchunkName = chunkName)
			{
				fixed (byte* pdata = data)
				{
					WriteChunkNative(pngPtr, (byte*)pchunkName, (byte*)pdata, length);
				}
			}
		}

		/// <summary>
		/// Write a PNG chunk - size, type, (optional) data, CRC. <br/>
		/// </summary>
		public static void WriteChunk(PngStruct* pngPtr, string chunkName, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (chunkName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(chunkName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(chunkName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (data != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(data);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(data, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteChunkNative(pngPtr, pStr0, pStr1, length);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Write the start of a PNG chunk - length and chunk name. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteChunkStartNative(PngStruct* pngPtr, byte* chunkName, uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint, void>)funcTable[14])(pngPtr, chunkName, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[14])((nint)pngPtr, (nint)chunkName, length);
			#endif
		}

		/// <summary>
		/// Write the start of a PNG chunk - length and chunk name. <br/>
		/// </summary>
		public static void WriteChunkStart(PngStruct* pngPtr, byte* chunkName, uint length)
		{
			WriteChunkStartNative(pngPtr, chunkName, length);
		}

		/// <summary>
		/// Write the start of a PNG chunk - length and chunk name. <br/>
		/// </summary>
		public static void WriteChunkStart(PngStruct* pngPtr, ReadOnlySpan<byte> chunkName, uint length)
		{
			fixed (byte* pchunkName = chunkName)
			{
				WriteChunkStartNative(pngPtr, (byte*)pchunkName, length);
			}
		}

		/// <summary>
		/// Write the start of a PNG chunk - length and chunk name. <br/>
		/// </summary>
		public static void WriteChunkStart(PngStruct* pngPtr, string chunkName, uint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (chunkName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(chunkName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(chunkName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteChunkStartNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Write the data of a PNG chunk started with png_write_chunk_start(). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteChunkDataNative(PngStruct* pngPtr, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[15])(pngPtr, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[15])((nint)pngPtr, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write the data of a PNG chunk started with png_write_chunk_start(). <br/>
		/// </summary>
		public static void WriteChunkData(PngStruct* pngPtr, byte* data, nuint length)
		{
			WriteChunkDataNative(pngPtr, data, length);
		}

		/// <summary>
		/// Write the data of a PNG chunk started with png_write_chunk_start(). <br/>
		/// </summary>
		public static void WriteChunkData(PngStruct* pngPtr, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				WriteChunkDataNative(pngPtr, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// Write the data of a PNG chunk started with png_write_chunk_start(). <br/>
		/// </summary>
		public static void WriteChunkData(PngStruct* pngPtr, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteChunkDataNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Finish a chunk started with png_write_chunk_start() (includes CRC). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteChunkEndNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[16])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[16])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Finish a chunk started with png_write_chunk_start() (includes CRC). <br/>
		/// </summary>
		public static void WriteChunkEnd(PngStruct* pngPtr)
		{
			WriteChunkEndNative(pngPtr);
		}

		/// <summary>
		/// Allocate and initialize the info structure <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngInfo* CreateInfoStructNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*>)funcTable[17])(pngPtr);
			#else
			return (PngInfo*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[17])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Allocate and initialize the info structure <br/>
		/// </summary>
		public static PngInfo* CreateInfoStruct(PngStruct* pngPtr)
		{
			PngInfo* ret = CreateInfoStructNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// DEPRECATED: this function allowed init structures to be created using the<br/>
		/// default allocation method (typically malloc).  Use is deprecated in 1.6.0 and<br/>
		/// the API will be removed in the future.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InfoInit3Native(PngInfo** infoPtr, nuint pngInfoStructSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngInfo**, nuint, void>)funcTable[18])(infoPtr, pngInfoStructSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)funcTable[18])((nint)infoPtr, pngInfoStructSize);
			#endif
		}

		/// <summary>
		/// DEPRECATED: this function allowed init structures to be created using the<br/>
		/// default allocation method (typically malloc).  Use is deprecated in 1.6.0 and<br/>
		/// the API will be removed in the future.<br/>
		/// </summary>
		public static void InfoInit3(PngInfo** infoPtr, nuint pngInfoStructSize)
		{
			InfoInit3Native(infoPtr, pngInfoStructSize);
		}

		/// <summary>
		/// Writes all the PNG information before the image. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteInfoBeforePLTENative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[19])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[19])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Writes all the PNG information before the image. <br/>
		/// </summary>
		public static void WriteInfoBeforePLTE(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			WriteInfoBeforePLTENative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteInfoNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[20])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[20])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteInfo(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			WriteInfoNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// Read the information before the actual image data. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadInfoNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[21])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[21])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Read the information before the actual image data. <br/>
		/// </summary>
		public static void ReadInfo(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ReadInfoNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ConvertToRfc1123Native(PngStruct* pngPtr, PngTime* ptime)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngTime*, byte*>)funcTable[22])(pngPtr, ptime);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[22])((nint)pngPtr, (nint)ptime);
			#endif
		}

		/// <summary>
		/// To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) <br/>
		/// </summary>
		public static byte* ConvertToRfc1123(PngStruct* pngPtr, PngTime* ptime)
		{
			byte* ret = ConvertToRfc1123Native(pngPtr, ptime);
			return ret;
		}

		/// <summary>
		/// To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) <br/>
		/// </summary>
		public static string ConvertToRfc1123S(PngStruct* pngPtr, PngTime* ptime)
		{
			string ret = Utils.DecodeStringUTF8(ConvertToRfc1123Native(pngPtr, ptime));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ConvertToRfc1123BufferNative(byte* output, PngTime* ptime)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, PngTime*, int>)funcTable[23])(output, ptime);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[23])((nint)output, (nint)ptime);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ConvertToRfc1123Buffer(byte* output, PngTime* ptime)
		{
			int ret = ConvertToRfc1123BufferNative(output, ptime);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ConvertToRfc1123Buffer(ref byte output, PngTime* ptime)
		{
			fixed (byte* poutput = &output)
			{
				int ret = ConvertToRfc1123BufferNative((byte*)poutput, ptime);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ConvertToRfc1123Buffer(ReadOnlySpan<byte> output, PngTime* ptime)
		{
			fixed (byte* poutput = output)
			{
				int ret = ConvertToRfc1123BufferNative((byte*)poutput, ptime);
				return ret;
			}
		}

		/// <summary>
		/// Convert from a struct tm to png_time <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvertFromStructTmNative(PngTime* ptime, Tm* ttime)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngTime*, Tm*, void>)funcTable[24])(ptime, ttime);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[24])((nint)ptime, (nint)ttime);
			#endif
		}

		/// <summary>
		/// Convert from a struct tm to png_time <br/>
		/// </summary>
		public static void ConvertFromStructTm(PngTime* ptime, Tm* ttime)
		{
			ConvertFromStructTmNative(ptime, ttime);
		}

		/// <summary>
		/// Convert from a struct tm to png_time <br/>
		/// </summary>
		public static void ConvertFromStructTm(PngTime* ptime, ref Tm ttime)
		{
			fixed (Tm* pttime = &ttime)
			{
				ConvertFromStructTmNative(ptime, (Tm*)pttime);
			}
		}

		/// <summary>
		/// Convert from time_t to png_time.  Uses gmtime() <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvertFromTimeNative(PngTime* ptime, long ttime)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngTime*, long, void>)funcTable[25])(ptime, ttime);
			#else
			((delegate* unmanaged[Cdecl]<nint, long, void>)funcTable[25])((nint)ptime, ttime);
			#endif
		}

		/// <summary>
		/// Convert from time_t to png_time.  Uses gmtime() <br/>
		/// </summary>
		public static void ConvertFromTime(PngTime* ptime, long ttime)
		{
			ConvertFromTimeNative(ptime, ttime);
		}

		/// <summary>
		/// Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetExpandNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[26])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[26])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. <br/>
		/// </summary>
		public static void SetExpand(PngStruct* pngPtr)
		{
			SetExpandNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetExpandGray124To8Native(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[27])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[27])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetExpandGray124To8(PngStruct* pngPtr)
		{
			SetExpandGray124To8Native(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPaletteToRgbNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[28])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPaletteToRgb(PngStruct* pngPtr)
		{
			SetPaletteToRgbNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTRNSToAlphaNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[29])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[29])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTRNSToAlpha(PngStruct* pngPtr)
		{
			SetTRNSToAlphaNative(pngPtr);
		}

		/// <summary>
		/// Expand to 16-bit channels, forces conversion of palette to RGB and expansion<br/>
		/// of a tRNS chunk if present.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetExpand16Native(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[30])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[30])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Expand to 16-bit channels, forces conversion of palette to RGB and expansion<br/>
		/// of a tRNS chunk if present.<br/>
		/// </summary>
		public static void SetExpand16(PngStruct* pngPtr)
		{
			SetExpand16Native(pngPtr);
		}

		/// <summary>
		/// Use blue, green, red order for pixels. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBgrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[31])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[31])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Use blue, green, red order for pixels. <br/>
		/// </summary>
		public static void SetBgr(PngStruct* pngPtr)
		{
			SetBgrNative(pngPtr);
		}

		/// <summary>
		/// Expand the grayscale to 24-bit RGB if necessary. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGrayToRgbNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[32])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[32])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Expand the grayscale to 24-bit RGB if necessary. <br/>
		/// </summary>
		public static void SetGrayToRgb(PngStruct* pngPtr)
		{
			SetGrayToRgbNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRgbToGrayNative(PngStruct* pngPtr, int errorAction, double red, double green)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, double, double, void>)funcTable[33])(pngPtr, errorAction, red, green);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, double, double, void>)funcTable[33])((nint)pngPtr, errorAction, red, green);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRgbToGray(PngStruct* pngPtr, int errorAction, double red, double green)
		{
			SetRgbToGrayNative(pngPtr, errorAction, red, green);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRgbToGrayFixedNative(PngStruct* pngPtr, int errorAction, int red, int green)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, int, void>)funcTable[34])(pngPtr, errorAction, red, green);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, void>)funcTable[34])((nint)pngPtr, errorAction, red, green);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetRgbToGrayFixed(PngStruct* pngPtr, int errorAction, int red, int green)
		{
			SetRgbToGrayFixedNative(pngPtr, errorAction, red, green);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetRgbToGrayStatusNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte>)funcTable[35])(pngPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[35])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte GetRgbToGrayStatus(PngStruct* pngPtr)
		{
			byte ret = GetRgbToGrayStatusNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BuildGrayscalePaletteNative(int bitDepth, PngColor* palette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, PngColor*, void>)funcTable[36])(bitDepth, palette);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[36])(bitDepth, (nint)palette);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BuildGrayscalePalette(int bitDepth, PngColor* palette)
		{
			BuildGrayscalePaletteNative(bitDepth, palette);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAlphaModeNative(PngStruct* pngPtr, int mode, double outputGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, double, void>)funcTable[37])(pngPtr, mode, outputGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, double, void>)funcTable[37])((nint)pngPtr, mode, outputGamma);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAlphaMode(PngStruct* pngPtr, int mode, double outputGamma)
		{
			SetAlphaModeNative(pngPtr, mode, outputGamma);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAlphaModeFixedNative(PngStruct* pngPtr, int mode, int outputGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, void>)funcTable[38])(pngPtr, mode, outputGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[38])((nint)pngPtr, mode, outputGamma);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAlphaModeFixed(PngStruct* pngPtr, int mode, int outputGamma)
		{
			SetAlphaModeFixedNative(pngPtr, mode, outputGamma);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetStripAlphaNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[39])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[39])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetStripAlpha(PngStruct* pngPtr)
		{
			SetStripAlphaNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSwapAlphaNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[40])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[40])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSwapAlpha(PngStruct* pngPtr)
		{
			SetSwapAlphaNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInvertAlphaNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[41])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[41])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetInvertAlpha(PngStruct* pngPtr)
		{
			SetInvertAlphaNative(pngPtr);
		}

		/// <summary>
		/// Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFillerNative(PngStruct* pngPtr, uint filler, int flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, int, void>)funcTable[42])(pngPtr, filler, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, int, void>)funcTable[42])((nint)pngPtr, filler, flags);
			#endif
		}

		/// <summary>
		/// Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. <br/>
		/// </summary>
		public static void SetFiller(PngStruct* pngPtr, uint filler, int flags)
		{
			SetFillerNative(pngPtr, filler, flags);
		}

		/// <summary>
		/// Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAddAlphaNative(PngStruct* pngPtr, uint filler, int flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, int, void>)funcTable[43])(pngPtr, filler, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, int, void>)funcTable[43])((nint)pngPtr, filler, flags);
			#endif
		}

		/// <summary>
		/// Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. <br/>
		/// </summary>
		public static void SetAddAlpha(PngStruct* pngPtr, uint filler, int flags)
		{
			SetAddAlphaNative(pngPtr, filler, flags);
		}

		/// <summary>
		/// Swap bytes in 16-bit depth files. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSwapNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[44])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[44])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Swap bytes in 16-bit depth files. <br/>
		/// </summary>
		public static void SetSwap(PngStruct* pngPtr)
		{
			SetSwapNative(pngPtr);
		}

		/// <summary>
		/// Use 1 byte per pixel in 1, 2, or 4-bit depth files. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPackingNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[45])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[45])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Use 1 byte per pixel in 1, 2, or 4-bit depth files. <br/>
		/// </summary>
		public static void SetPacking(PngStruct* pngPtr)
		{
			SetPackingNative(pngPtr);
		}

		/// <summary>
		/// Swap packing order of pixels in bytes. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPackswapNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[46])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[46])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Swap packing order of pixels in bytes. <br/>
		/// </summary>
		public static void SetPackswap(PngStruct* pngPtr)
		{
			SetPackswapNative(pngPtr);
		}

		/// <summary>
		/// Converts files to legal bit depths. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetShiftNative(PngStruct* pngPtr, PngColor8* trueBits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor8*, void>)funcTable[47])(pngPtr, trueBits);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[47])((nint)pngPtr, (nint)trueBits);
			#endif
		}

		/// <summary>
		/// Converts files to legal bit depths. <br/>
		/// </summary>
		public static void SetShift(PngStruct* pngPtr, PngColor8* trueBits)
		{
			SetShiftNative(pngPtr, trueBits);
		}

		/// <summary>
		/// Have the code handle the interlacing.  Returns the number of passes.<br/>
		/// MUST be called before png_read_update_info or png_start_read_image,<br/>
		/// otherwise it will not have the desired effect.  Note that it is still<br/>
		/// necessary to call png_read_row or png_read_rows png_get_image_height<br/>
		/// times for each pass.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetInterlaceHandlingNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int>)funcTable[48])(pngPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[48])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Have the code handle the interlacing.  Returns the number of passes.<br/>
		/// MUST be called before png_read_update_info or png_start_read_image,<br/>
		/// otherwise it will not have the desired effect.  Note that it is still<br/>
		/// necessary to call png_read_row or png_read_rows png_get_image_height<br/>
		/// times for each pass.<br/>
		/// </summary>
		public static int SetInterlaceHandling(PngStruct* pngPtr)
		{
			int ret = SetInterlaceHandlingNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Invert monochrome files <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInvertMonoNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[49])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[49])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Invert monochrome files <br/>
		/// </summary>
		public static void SetInvertMono(PngStruct* pngPtr)
		{
			SetInvertMonoNative(pngPtr);
		}

		/// <summary>
		/// Handle alpha and tRNS by replacing with a background color.  Prior to<br/>
		/// libpng-1.5.4 this API must not be called before the PNG file header has been<br/>
		/// read.  Doing so will result in unexpected behavior and possible warnings or<br/>
		/// errors if the PNG file contains a bKGD chunk.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBackgroundNative(PngStruct* pngPtr, PngColor16* backgroundColor, int backgroundGammaCode, int needExpand, double backgroundGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor16*, int, int, double, void>)funcTable[50])(pngPtr, backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, double, void>)funcTable[50])((nint)pngPtr, (nint)backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
			#endif
		}

		/// <summary>
		/// Handle alpha and tRNS by replacing with a background color.  Prior to<br/>
		/// libpng-1.5.4 this API must not be called before the PNG file header has been<br/>
		/// read.  Doing so will result in unexpected behavior and possible warnings or<br/>
		/// errors if the PNG file contains a bKGD chunk.<br/>
		/// </summary>
		public static void SetBackground(PngStruct* pngPtr, PngColor16* backgroundColor, int backgroundGammaCode, int needExpand, double backgroundGamma)
		{
			SetBackgroundNative(pngPtr, backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
		}

		/// <summary>
		/// Handle alpha and tRNS by replacing with a background color.  Prior to<br/>
		/// libpng-1.5.4 this API must not be called before the PNG file header has been<br/>
		/// read.  Doing so will result in unexpected behavior and possible warnings or<br/>
		/// errors if the PNG file contains a bKGD chunk.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBackgroundFixedNative(PngStruct* pngPtr, PngColor16* backgroundColor, int backgroundGammaCode, int needExpand, int backgroundGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor16*, int, int, int, void>)funcTable[51])(pngPtr, backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, void>)funcTable[51])((nint)pngPtr, (nint)backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
			#endif
		}

		/// <summary>
		/// Handle alpha and tRNS by replacing with a background color.  Prior to<br/>
		/// libpng-1.5.4 this API must not be called before the PNG file header has been<br/>
		/// read.  Doing so will result in unexpected behavior and possible warnings or<br/>
		/// errors if the PNG file contains a bKGD chunk.<br/>
		/// </summary>
		public static void SetBackgroundFixed(PngStruct* pngPtr, PngColor16* backgroundColor, int backgroundGammaCode, int needExpand, int backgroundGamma)
		{
			SetBackgroundFixedNative(pngPtr, backgroundColor, backgroundGammaCode, needExpand, backgroundGamma);
		}

		/// <summary>
		/// Scale a 16-bit depth file down to 8-bit, accurately. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetScale16Native(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[52])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[52])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Scale a 16-bit depth file down to 8-bit, accurately. <br/>
		/// </summary>
		public static void SetScale16(PngStruct* pngPtr)
		{
			SetScale16Native(pngPtr);
		}

		/// <summary>
		/// Strip the second byte of information from a 16-bit depth file. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetStrip16Native(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[53])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[53])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Strip the second byte of information from a 16-bit depth file. <br/>
		/// </summary>
		public static void SetStrip16(PngStruct* pngPtr)
		{
			SetStrip16Native(pngPtr);
		}

		/// <summary>
		/// Turn on quantizing, and reduce the palette to the number of colors<br/>
		/// available.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetQuantizeNative(PngStruct* pngPtr, PngColor* palette, int numPalette, int maximumColors, ushort* histogram, int fullQuantize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor*, int, int, ushort*, int, void>)funcTable[54])(pngPtr, palette, numPalette, maximumColors, histogram, fullQuantize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, nint, int, void>)funcTable[54])((nint)pngPtr, (nint)palette, numPalette, maximumColors, (nint)histogram, fullQuantize);
			#endif
		}

		/// <summary>
		/// Turn on quantizing, and reduce the palette to the number of colors<br/>
		/// available.<br/>
		/// </summary>
		public static void SetQuantize(PngStruct* pngPtr, PngColor* palette, int numPalette, int maximumColors, ushort* histogram, int fullQuantize)
		{
			SetQuantizeNative(pngPtr, palette, numPalette, maximumColors, histogram, fullQuantize);
		}

		/// <summary>
		/// Handle gamma correction. Screen_gamma=(display_exponent).<br/>
		/// NOTE: this API simply sets the screen and file gamma values. It will<br/>
		/// therefore override the value for gamma in a PNG file if it is called after<br/>
		/// the file header has been read - use with care  - call before reading the PNG<br/>
		/// file for best results!<br/>
		/// These routines accept the same gamma values as png_set_alpha_mode (described<br/>
		/// above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either<br/>
		/// API (floating point or fixed.)  Notice, however, that the 'file_gamma' value<br/>
		/// is the inverse of a 'screen gamma' value.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGammaNative(PngStruct* pngPtr, double screenGamma, double overrideFileGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, double, double, void>)funcTable[55])(pngPtr, screenGamma, overrideFileGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, double, double, void>)funcTable[55])((nint)pngPtr, screenGamma, overrideFileGamma);
			#endif
		}

		/// <summary>
		/// Handle gamma correction. Screen_gamma=(display_exponent).<br/>
		/// NOTE: this API simply sets the screen and file gamma values. It will<br/>
		/// therefore override the value for gamma in a PNG file if it is called after<br/>
		/// the file header has been read - use with care  - call before reading the PNG<br/>
		/// file for best results!<br/>
		/// These routines accept the same gamma values as png_set_alpha_mode (described<br/>
		/// above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either<br/>
		/// API (floating point or fixed.)  Notice, however, that the 'file_gamma' value<br/>
		/// is the inverse of a 'screen gamma' value.<br/>
		/// </summary>
		public static void SetGamma(PngStruct* pngPtr, double screenGamma, double overrideFileGamma)
		{
			SetGammaNative(pngPtr, screenGamma, overrideFileGamma);
		}

		/// <summary>
		/// Handle gamma correction. Screen_gamma=(display_exponent).<br/>
		/// NOTE: this API simply sets the screen and file gamma values. It will<br/>
		/// therefore override the value for gamma in a PNG file if it is called after<br/>
		/// the file header has been read - use with care  - call before reading the PNG<br/>
		/// file for best results!<br/>
		/// These routines accept the same gamma values as png_set_alpha_mode (described<br/>
		/// above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either<br/>
		/// API (floating point or fixed.)  Notice, however, that the 'file_gamma' value<br/>
		/// is the inverse of a 'screen gamma' value.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetGammaFixedNative(PngStruct* pngPtr, int screenGamma, int overrideFileGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, void>)funcTable[56])(pngPtr, screenGamma, overrideFileGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[56])((nint)pngPtr, screenGamma, overrideFileGamma);
			#endif
		}

		/// <summary>
		/// Handle gamma correction. Screen_gamma=(display_exponent).<br/>
		/// NOTE: this API simply sets the screen and file gamma values. It will<br/>
		/// therefore override the value for gamma in a PNG file if it is called after<br/>
		/// the file header has been read - use with care  - call before reading the PNG<br/>
		/// file for best results!<br/>
		/// These routines accept the same gamma values as png_set_alpha_mode (described<br/>
		/// above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either<br/>
		/// API (floating point or fixed.)  Notice, however, that the 'file_gamma' value<br/>
		/// is the inverse of a 'screen gamma' value.<br/>
		/// </summary>
		public static void SetGammaFixed(PngStruct* pngPtr, int screenGamma, int overrideFileGamma)
		{
			SetGammaFixedNative(pngPtr, screenGamma, overrideFileGamma);
		}

		/// <summary>
		/// Set how many lines between output flushes - 0 for no flushing <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFlushNative(PngStruct* pngPtr, int nrows)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[57])(pngPtr, nrows);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[57])((nint)pngPtr, nrows);
			#endif
		}

		/// <summary>
		/// Set how many lines between output flushes - 0 for no flushing <br/>
		/// </summary>
		public static void SetFlush(PngStruct* pngPtr, int nrows)
		{
			SetFlushNative(pngPtr, nrows);
		}

		/// <summary>
		/// Flush the current PNG output buffer <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteFlushNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[58])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[58])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Flush the current PNG output buffer <br/>
		/// </summary>
		public static void WriteFlush(PngStruct* pngPtr)
		{
			WriteFlushNative(pngPtr);
		}

		/// <summary>
		/// Optional update palette with requested transformations <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StartReadImageNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[59])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[59])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Optional update palette with requested transformations <br/>
		/// </summary>
		public static void StartReadImage(PngStruct* pngPtr)
		{
			StartReadImageNative(pngPtr);
		}

		/// <summary>
		/// Optional call to update the users info structure <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadUpdateInfoNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[60])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[60])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Optional call to update the users info structure <br/>
		/// </summary>
		public static void ReadUpdateInfo(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ReadUpdateInfoNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// Read one or more rows of image data. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadRowsNative(PngStruct* pngPtr, byte** row, byte** displayRow, uint numRows)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte**, byte**, uint, void>)funcTable[61])(pngPtr, row, displayRow, numRows);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, void>)funcTable[61])((nint)pngPtr, (nint)row, (nint)displayRow, numRows);
			#endif
		}

		/// <summary>
		/// Read one or more rows of image data. <br/>
		/// </summary>
		public static void ReadRows(PngStruct* pngPtr, byte** row, byte** displayRow, uint numRows)
		{
			ReadRowsNative(pngPtr, row, displayRow, numRows);
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadRowNative(PngStruct* pngPtr, byte* row, byte* displayRow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, void>)funcTable[62])(pngPtr, row, displayRow);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[62])((nint)pngPtr, (nint)row, (nint)displayRow);
			#endif
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, byte* row, byte* displayRow)
		{
			ReadRowNative(pngPtr, row, displayRow);
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, ReadOnlySpan<byte> row, byte* displayRow)
		{
			fixed (byte* prow = row)
			{
				ReadRowNative(pngPtr, (byte*)prow, displayRow);
			}
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, string row, byte* displayRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadRowNative(pngPtr, pStr0, displayRow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, byte* row, ReadOnlySpan<byte> displayRow)
		{
			fixed (byte* pdisplayRow = displayRow)
			{
				ReadRowNative(pngPtr, row, (byte*)pdisplayRow);
			}
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, byte* row, string displayRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (displayRow != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(displayRow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(displayRow, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadRowNative(pngPtr, row, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, ReadOnlySpan<byte> row, ReadOnlySpan<byte> displayRow)
		{
			fixed (byte* prow = row)
			{
				fixed (byte* pdisplayRow = displayRow)
				{
					ReadRowNative(pngPtr, (byte*)prow, (byte*)pdisplayRow);
				}
			}
		}

		/// <summary>
		/// Read a row of data. <br/>
		/// </summary>
		public static void ReadRow(PngStruct* pngPtr, string row, string displayRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (displayRow != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(displayRow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(displayRow, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ReadRowNative(pngPtr, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read the whole image into memory at once. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadImageNative(PngStruct* pngPtr, byte** image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte**, void>)funcTable[63])(pngPtr, image);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[63])((nint)pngPtr, (nint)image);
			#endif
		}

		/// <summary>
		/// Read the whole image into memory at once. <br/>
		/// </summary>
		public static void ReadImage(PngStruct* pngPtr, byte** image)
		{
			ReadImageNative(pngPtr, image);
		}

		/// <summary>
		/// Write a row of image data <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteRowNative(PngStruct* pngPtr, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[64])(pngPtr, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[64])((nint)pngPtr, (nint)row);
			#endif
		}

		/// <summary>
		/// Write a row of image data <br/>
		/// </summary>
		public static void WriteRow(PngStruct* pngPtr, byte* row)
		{
			WriteRowNative(pngPtr, row);
		}

		/// <summary>
		/// Write a row of image data <br/>
		/// </summary>
		public static void WriteRow(PngStruct* pngPtr, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				WriteRowNative(pngPtr, (byte*)prow);
			}
		}

		/// <summary>
		/// Write a row of image data <br/>
		/// </summary>
		public static void WriteRow(PngStruct* pngPtr, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteRowNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Write a few rows of image data: (*row) is not written; however, the type<br/>
		/// is declared as writeable to maintain compatibility with previous versions<br/>
		/// of libpng and to allow the 'display_row' array from read_rows to be passed<br/>
		/// unchanged to write_rows.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteRowsNative(PngStruct* pngPtr, byte** row, uint numRows)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte**, uint, void>)funcTable[65])(pngPtr, row, numRows);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[65])((nint)pngPtr, (nint)row, numRows);
			#endif
		}

		/// <summary>
		/// Write a few rows of image data: (*row) is not written; however, the type<br/>
		/// is declared as writeable to maintain compatibility with previous versions<br/>
		/// of libpng and to allow the 'display_row' array from read_rows to be passed<br/>
		/// unchanged to write_rows.<br/>
		/// </summary>
		public static void WriteRows(PngStruct* pngPtr, byte** row, uint numRows)
		{
			WriteRowsNative(pngPtr, row, numRows);
		}

		/// <summary>
		/// Write the image data <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteImageNative(PngStruct* pngPtr, byte** image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte**, void>)funcTable[66])(pngPtr, image);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[66])((nint)pngPtr, (nint)image);
			#endif
		}

		/// <summary>
		/// Write the image data <br/>
		/// </summary>
		public static void WriteImage(PngStruct* pngPtr, byte** image)
		{
			WriteImageNative(pngPtr, image);
		}

		/// <summary>
		/// Write the end of the PNG file. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteEndNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[67])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[67])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Write the end of the PNG file. <br/>
		/// </summary>
		public static void WriteEnd(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			WriteEndNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// Read the end of the PNG file. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadEndNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[68])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[68])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Read the end of the PNG file. <br/>
		/// </summary>
		public static void ReadEnd(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ReadEndNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// Free any memory associated with the png_info_struct <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyInfoStructNative(PngStruct* pngPtr, PngInfo** infoPtrPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo**, void>)funcTable[69])(pngPtr, infoPtrPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[69])((nint)pngPtr, (nint)infoPtrPtr);
			#endif
		}

		/// <summary>
		/// Free any memory associated with the png_info_struct <br/>
		/// </summary>
		public static void DestroyInfoStruct(PngStruct* pngPtr, PngInfo** infoPtrPtr)
		{
			DestroyInfoStructNative(pngPtr, infoPtrPtr);
		}

		/// <summary>
		/// Free any memory associated with the png_struct and the png_info_structs <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyReadStructNative(PngStruct** pngPtrPtr, PngInfo** infoPtrPtr, PngInfo** endInfoPtrPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct**, PngInfo**, PngInfo**, void>)funcTable[70])(pngPtrPtr, infoPtrPtr, endInfoPtrPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[70])((nint)pngPtrPtr, (nint)infoPtrPtr, (nint)endInfoPtrPtr);
			#endif
		}

		/// <summary>
		/// Free any memory associated with the png_struct and the png_info_structs <br/>
		/// </summary>
		public static void DestroyReadStruct(PngStruct** pngPtrPtr, PngInfo** infoPtrPtr, PngInfo** endInfoPtrPtr)
		{
			DestroyReadStructNative(pngPtrPtr, infoPtrPtr, endInfoPtrPtr);
		}

		/// <summary>
		/// Free any memory associated with the png_struct and the png_info_structs <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyWriteStructNative(PngStruct** pngPtrPtr, PngInfo** infoPtrPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct**, PngInfo**, void>)funcTable[71])(pngPtrPtr, infoPtrPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[71])((nint)pngPtrPtr, (nint)infoPtrPtr);
			#endif
		}

		/// <summary>
		/// Free any memory associated with the png_struct and the png_info_structs <br/>
		/// </summary>
		public static void DestroyWriteStruct(PngStruct** pngPtrPtr, PngInfo** infoPtrPtr)
		{
			DestroyWriteStructNative(pngPtrPtr, infoPtrPtr);
		}

		/// <summary>
		/// Set the libpng method of handling chunk CRC errors <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCrcActionNative(PngStruct* pngPtr, int critAction, int ancilAction)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, void>)funcTable[72])(pngPtr, critAction, ancilAction);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[72])((nint)pngPtr, critAction, ancilAction);
			#endif
		}

		/// <summary>
		/// Set the libpng method of handling chunk CRC errors <br/>
		/// </summary>
		public static void SetCrcAction(PngStruct* pngPtr, int critAction, int ancilAction)
		{
			SetCrcActionNative(pngPtr, critAction, ancilAction);
		}

		/// <summary>
		/// Set the filtering method(s) used by libpng.  Currently, the only valid<br/>
		/// value for "method" is 0.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFilterNative(PngStruct* pngPtr, int method, int filters)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, void>)funcTable[73])(pngPtr, method, filters);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[73])((nint)pngPtr, method, filters);
			#endif
		}

		/// <summary>
		/// Set the filtering method(s) used by libpng.  Currently, the only valid<br/>
		/// value for "method" is 0.<br/>
		/// </summary>
		public static void SetFilter(PngStruct* pngPtr, int method, int filters)
		{
			SetFilterNative(pngPtr, method, filters);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFilterHeuristicsNative(PngStruct* pngPtr, int heuristicMethod, int numWeights, double* filterWeights, double* filterCosts)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, double*, double*, void>)funcTable[74])(pngPtr, heuristicMethod, numWeights, filterWeights, filterCosts);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, void>)funcTable[74])((nint)pngPtr, heuristicMethod, numWeights, (nint)filterWeights, (nint)filterCosts);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetFilterHeuristics(PngStruct* pngPtr, int heuristicMethod, int numWeights, double* filterWeights, double* filterCosts)
		{
			SetFilterHeuristicsNative(pngPtr, heuristicMethod, numWeights, filterWeights, filterCosts);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFilterHeuristicsFixedNative(PngStruct* pngPtr, int heuristicMethod, int numWeights, int* filterWeights, int* filterCosts)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, int*, int*, void>)funcTable[75])(pngPtr, heuristicMethod, numWeights, filterWeights, filterCosts);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, nint, nint, void>)funcTable[75])((nint)pngPtr, heuristicMethod, numWeights, (nint)filterWeights, (nint)filterCosts);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetFilterHeuristicsFixed(PngStruct* pngPtr, int heuristicMethod, int numWeights, int* filterWeights, int* filterCosts)
		{
			SetFilterHeuristicsFixedNative(pngPtr, heuristicMethod, numWeights, filterWeights, filterCosts);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionLevelNative(PngStruct* pngPtr, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[76])(pngPtr, level);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[76])((nint)pngPtr, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCompressionLevel(PngStruct* pngPtr, int level)
		{
			SetCompressionLevelNative(pngPtr, level);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionMemLevelNative(PngStruct* pngPtr, int memLevel)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[77])(pngPtr, memLevel);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[77])((nint)pngPtr, memLevel);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCompressionMemLevel(PngStruct* pngPtr, int memLevel)
		{
			SetCompressionMemLevelNative(pngPtr, memLevel);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionStrategyNative(PngStruct* pngPtr, int strategy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[78])(pngPtr, strategy);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[78])((nint)pngPtr, strategy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCompressionStrategy(PngStruct* pngPtr, int strategy)
		{
			SetCompressionStrategyNative(pngPtr, strategy);
		}

		/// <summary>
		/// If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a<br/>
		/// smaller value of window_bits if it can do so safely.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionWindowBitsNative(PngStruct* pngPtr, int windowBits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[79])(pngPtr, windowBits);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[79])((nint)pngPtr, windowBits);
			#endif
		}

		/// <summary>
		/// If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a<br/>
		/// smaller value of window_bits if it can do so safely.<br/>
		/// </summary>
		public static void SetCompressionWindowBits(PngStruct* pngPtr, int windowBits)
		{
			SetCompressionWindowBitsNative(pngPtr, windowBits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCompressionMethodNative(PngStruct* pngPtr, int method)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[80])(pngPtr, method);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[80])((nint)pngPtr, method);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCompressionMethod(PngStruct* pngPtr, int method)
		{
			SetCompressionMethodNative(pngPtr, method);
		}

		/// <summary>
		/// Also set zlib parameters for compressing non-IDAT chunks <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextCompressionLevelNative(PngStruct* pngPtr, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[81])(pngPtr, level);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[81])((nint)pngPtr, level);
			#endif
		}

		/// <summary>
		/// Also set zlib parameters for compressing non-IDAT chunks <br/>
		/// </summary>
		public static void SetTextCompressionLevel(PngStruct* pngPtr, int level)
		{
			SetTextCompressionLevelNative(pngPtr, level);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextCompressionMemLevelNative(PngStruct* pngPtr, int memLevel)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[82])(pngPtr, memLevel);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[82])((nint)pngPtr, memLevel);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTextCompressionMemLevel(PngStruct* pngPtr, int memLevel)
		{
			SetTextCompressionMemLevelNative(pngPtr, memLevel);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextCompressionStrategyNative(PngStruct* pngPtr, int strategy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[83])(pngPtr, strategy);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[83])((nint)pngPtr, strategy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTextCompressionStrategy(PngStruct* pngPtr, int strategy)
		{
			SetTextCompressionStrategyNative(pngPtr, strategy);
		}

		/// <summary>
		/// If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a<br/>
		/// smaller value of window_bits if it can do so safely.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextCompressionWindowBitsNative(PngStruct* pngPtr, int windowBits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[84])(pngPtr, windowBits);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[84])((nint)pngPtr, windowBits);
			#endif
		}

		/// <summary>
		/// If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a<br/>
		/// smaller value of window_bits if it can do so safely.<br/>
		/// </summary>
		public static void SetTextCompressionWindowBits(PngStruct* pngPtr, int windowBits)
		{
			SetTextCompressionWindowBitsNative(pngPtr, windowBits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextCompressionMethodNative(PngStruct* pngPtr, int method)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[85])(pngPtr, method);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[85])((nint)pngPtr, method);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTextCompressionMethod(PngStruct* pngPtr, int method)
		{
			SetTextCompressionMethodNative(pngPtr, method);
		}

		/// <summary>
		/// Initialize the input/output for the PNG file to the default functions. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitIoNative(PngStruct* pngPtr, FILE* fp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, FILE*, void>)funcTable[86])(pngPtr, fp);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[86])((nint)pngPtr, (nint)fp);
			#endif
		}

		/// <summary>
		/// Initialize the input/output for the PNG file to the default functions. <br/>
		/// </summary>
		public static void InitIo(PngStruct* pngPtr, FILE* fp)
		{
			InitIoNative(pngPtr, fp);
		}

		/// <summary>
		/// Replace the (error and abort), and warning functions with user<br/>
		/// supplied functions.  If no messages are to be printed you must still<br/>
		/// write and use replacement functions. The replacement error_fn should<br/>
		/// still do a longjmp to the last setjmp location if you are using this<br/>
		/// method of error handling.  If error_fn or warning_fn is NULL, the<br/>
		/// default function will be used.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetErrorFnNative(PngStruct* pngPtr, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warningFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, void>)funcTable[87])(pngPtr, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warningFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[87])((nint)pngPtr, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warningFn));
			#endif
		}

		/// <summary>
		/// Replace the (error and abort), and warning functions with user<br/>
		/// supplied functions.  If no messages are to be printed you must still<br/>
		/// write and use replacement functions. The replacement error_fn should<br/>
		/// still do a longjmp to the last setjmp location if you are using this<br/>
		/// method of error handling.  If error_fn or warning_fn is NULL, the<br/>
		/// default function will be used.<br/>
		/// </summary>
		public static void SetErrorFn(PngStruct* pngPtr, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warningFn)
		{
			SetErrorFnNative(pngPtr, errorPtr, errorFn, warningFn);
		}

		/// <summary>
		/// Return the user pointer associated with the error functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetErrorPtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[88])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[88])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Return the user pointer associated with the error functions <br/>
		/// </summary>
		public static void* GetErrorPtr(PngStruct* pngPtr)
		{
			void* ret = GetErrorPtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Replace the default data output functions with a user supplied one(s).<br/>
		/// If buffered output is not used, then output_flush_fn can be set to NULL.<br/>
		/// If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time<br/>
		/// output_flush_fn will be ignored (and thus can be NULL).<br/>
		/// It is probably a mistake to use NULL for output_flush_fn if<br/>
		/// write_data_fn is not also NULL unless you have built libpng with<br/>
		/// PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's<br/>
		/// default flush function, which uses the standard *FILE structure, will<br/>
		/// be used.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWriteFnNative(PngStruct* pngPtr, void* ioPtr, PngRwPtr writeDataFn, PngFlushPtr outputFlushFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, byte*, nuint, void>, delegate*<PngStruct*, void>, void>)funcTable[89])(pngPtr, ioPtr, (delegate*<PngStruct*, byte*, nuint, void>)Utils.GetFunctionPointerForDelegate(writeDataFn), (delegate*<PngStruct*, void>)Utils.GetFunctionPointerForDelegate(outputFlushFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[89])((nint)pngPtr, (nint)ioPtr, (nint)Utils.GetFunctionPointerForDelegate(writeDataFn), (nint)Utils.GetFunctionPointerForDelegate(outputFlushFn));
			#endif
		}

		/// <summary>
		/// Replace the default data output functions with a user supplied one(s).<br/>
		/// If buffered output is not used, then output_flush_fn can be set to NULL.<br/>
		/// If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time<br/>
		/// output_flush_fn will be ignored (and thus can be NULL).<br/>
		/// It is probably a mistake to use NULL for output_flush_fn if<br/>
		/// write_data_fn is not also NULL unless you have built libpng with<br/>
		/// PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's<br/>
		/// default flush function, which uses the standard *FILE structure, will<br/>
		/// be used.<br/>
		/// </summary>
		public static void SetWriteFn(PngStruct* pngPtr, void* ioPtr, PngRwPtr writeDataFn, PngFlushPtr outputFlushFn)
		{
			SetWriteFnNative(pngPtr, ioPtr, writeDataFn, outputFlushFn);
		}

		/// <summary>
		/// Replace the default data input function with a user supplied one. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetReadFnNative(PngStruct* pngPtr, void* ioPtr, PngRwPtr readDataFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, byte*, nuint, void>, void>)funcTable[90])(pngPtr, ioPtr, (delegate*<PngStruct*, byte*, nuint, void>)Utils.GetFunctionPointerForDelegate(readDataFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[90])((nint)pngPtr, (nint)ioPtr, (nint)Utils.GetFunctionPointerForDelegate(readDataFn));
			#endif
		}

		/// <summary>
		/// Replace the default data input function with a user supplied one. <br/>
		/// </summary>
		public static void SetReadFn(PngStruct* pngPtr, void* ioPtr, PngRwPtr readDataFn)
		{
			SetReadFnNative(pngPtr, ioPtr, readDataFn);
		}

		/// <summary>
		/// Return the user pointer associated with the I/O functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetIoPtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[91])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[91])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Return the user pointer associated with the I/O functions <br/>
		/// </summary>
		public static void* GetIoPtr(PngStruct* pngPtr)
		{
			void* ret = GetIoPtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetReadStatusFnNative(PngStruct* pngPtr, PngReadStatusPtr readRowFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, delegate*<PngStruct*, uint, int, void>, void>)funcTable[92])(pngPtr, (delegate*<PngStruct*, uint, int, void>)Utils.GetFunctionPointerForDelegate(readRowFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[92])((nint)pngPtr, (nint)Utils.GetFunctionPointerForDelegate(readRowFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetReadStatusFn(PngStruct* pngPtr, PngReadStatusPtr readRowFn)
		{
			SetReadStatusFnNative(pngPtr, readRowFn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWriteStatusFnNative(PngStruct* pngPtr, PngWriteStatusPtr writeRowFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, delegate*<PngStruct*, uint, int, void>, void>)funcTable[93])(pngPtr, (delegate*<PngStruct*, uint, int, void>)Utils.GetFunctionPointerForDelegate(writeRowFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[93])((nint)pngPtr, (nint)Utils.GetFunctionPointerForDelegate(writeRowFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWriteStatusFn(PngStruct* pngPtr, PngWriteStatusPtr writeRowFn)
		{
			SetWriteStatusFnNative(pngPtr, writeRowFn);
		}

		/// <summary>
		/// Replace the default memory allocation functions with user supplied one(s). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMemFnNative(PngStruct* pngPtr, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, nint, void*>, delegate*<PngStruct*, void*, void>, void>)funcTable[94])(pngPtr, memPtr, (delegate*<PngStruct*, nint, void*>)Utils.GetFunctionPointerForDelegate(mallocFn), (delegate*<PngStruct*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, void>)funcTable[94])((nint)pngPtr, (nint)memPtr, (nint)Utils.GetFunctionPointerForDelegate(mallocFn), (nint)Utils.GetFunctionPointerForDelegate(freeFn));
			#endif
		}

		/// <summary>
		/// Replace the default memory allocation functions with user supplied one(s). <br/>
		/// </summary>
		public static void SetMemFn(PngStruct* pngPtr, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			SetMemFnNative(pngPtr, memPtr, mallocFn, freeFn);
		}

		/// <summary>
		/// Return the user pointer associated with the memory functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetMemPtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[95])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[95])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Return the user pointer associated with the memory functions <br/>
		/// </summary>
		public static void* GetMemPtr(PngStruct* pngPtr)
		{
			void* ret = GetMemPtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetReadUserTransformFnNative(PngStruct* pngPtr, PngUserTransformPtr readUserTransformFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, delegate*<PngStruct*, PngRowInfo*, byte*, void>, void>)funcTable[96])(pngPtr, (delegate*<PngStruct*, PngRowInfo*, byte*, void>)Utils.GetFunctionPointerForDelegate(readUserTransformFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[96])((nint)pngPtr, (nint)Utils.GetFunctionPointerForDelegate(readUserTransformFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetReadUserTransformFn(PngStruct* pngPtr, PngUserTransformPtr readUserTransformFn)
		{
			SetReadUserTransformFnNative(pngPtr, readUserTransformFn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWriteUserTransformFnNative(PngStruct* pngPtr, PngUserTransformPtr writeUserTransformFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, delegate*<PngStruct*, PngRowInfo*, byte*, void>, void>)funcTable[97])(pngPtr, (delegate*<PngStruct*, PngRowInfo*, byte*, void>)Utils.GetFunctionPointerForDelegate(writeUserTransformFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[97])((nint)pngPtr, (nint)Utils.GetFunctionPointerForDelegate(writeUserTransformFn));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWriteUserTransformFn(PngStruct* pngPtr, PngUserTransformPtr writeUserTransformFn)
		{
			SetWriteUserTransformFnNative(pngPtr, writeUserTransformFn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetUserTransformInfoNative(PngStruct* pngPtr, void* userTransformPtr, int userTransformDepth, int userTransformChannels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, int, int, void>)funcTable[98])(pngPtr, userTransformPtr, userTransformDepth, userTransformChannels);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[98])((nint)pngPtr, (nint)userTransformPtr, userTransformDepth, userTransformChannels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetUserTransformInfo(PngStruct* pngPtr, void* userTransformPtr, int userTransformDepth, int userTransformChannels)
		{
			SetUserTransformInfoNative(pngPtr, userTransformPtr, userTransformDepth, userTransformChannels);
		}

		/// <summary>
		/// Return the user pointer associated with the user transform functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetUserTransformPtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[99])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[99])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Return the user pointer associated with the user transform functions <br/>
		/// </summary>
		public static void* GetUserTransformPtr(PngStruct* pngPtr)
		{
			void* ret = GetUserTransformPtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Return information about the row currently being processed.  Note that these<br/>
		/// APIs do not fail but will return unexpected results if called outside a user<br/>
		/// transform callback.  Also note that when transforming an interlaced image the<br/>
		/// row number is the row number within the sub-image of the interlace pass, so<br/>
		/// the value will increase to the height of the sub-image (not the full image)<br/>
		/// then reset to 0 for the next pass.<br/>
		/// Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to<br/>
		/// find the output pixel (x,y) given an interlaced sub-image pixel<br/>
		/// (row,col,pass).  (See below for these macros.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCurrentRowNumberNative(PngStruct* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[100])(unknown0);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[100])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// Return information about the row currently being processed.  Note that these<br/>
		/// APIs do not fail but will return unexpected results if called outside a user<br/>
		/// transform callback.  Also note that when transforming an interlaced image the<br/>
		/// row number is the row number within the sub-image of the interlace pass, so<br/>
		/// the value will increase to the height of the sub-image (not the full image)<br/>
		/// then reset to 0 for the next pass.<br/>
		/// Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to<br/>
		/// find the output pixel (x,y) given an interlaced sub-image pixel<br/>
		/// (row,col,pass).  (See below for these macros.)<br/>
		/// </summary>
		public static uint GetCurrentRowNumber(PngStruct* unknown0)
		{
			uint ret = GetCurrentRowNumberNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetCurrentPassNumberNative(PngStruct* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte>)funcTable[101])(unknown0);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[101])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte GetCurrentPassNumber(PngStruct* unknown0)
		{
			byte ret = GetCurrentPassNumberNative(unknown0);
			return ret;
		}

		/// <summary>
		/// This callback is called only for *unknown* chunks.  If<br/>
		/// PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known<br/>
		/// chunks to be treated as unknown, however in this case the callback must do<br/>
		/// any processing required by the chunk (e.g. by calling the appropriate<br/>
		/// png_set_ APIs.)<br/>
		/// There is no write support - on write, by default, all the chunks in the<br/>
		/// 'unknown' list are written in the specified position.<br/>
		/// The integer return from the callback function is interpreted thus:<br/>
		/// negative: An error occurred; png_chunk_error will be called.<br/>
		/// zero: The chunk was not handled, the chunk will be saved. A critical<br/>
		/// chunk will cause an error at this point unless it is to be saved.<br/>
		/// positive: The chunk was handled, libpng will ignore/discard it.<br/>
		/// See "INTERACTION WITH USER CHUNK CALLBACKS" below for important notes about<br/>
		/// how this behavior will change in libpng 1.7<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetReadUserChunkFnNative(PngStruct* pngPtr, void* userChunkPtr, PngUserChunkPtr readUserChunkFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, PngUnknownChunk*, int>, void>)funcTable[102])(pngPtr, userChunkPtr, (delegate*<PngStruct*, PngUnknownChunk*, int>)Utils.GetFunctionPointerForDelegate(readUserChunkFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[102])((nint)pngPtr, (nint)userChunkPtr, (nint)Utils.GetFunctionPointerForDelegate(readUserChunkFn));
			#endif
		}

		/// <summary>
		/// This callback is called only for *unknown* chunks.  If<br/>
		/// PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known<br/>
		/// chunks to be treated as unknown, however in this case the callback must do<br/>
		/// any processing required by the chunk (e.g. by calling the appropriate<br/>
		/// png_set_ APIs.)<br/>
		/// There is no write support - on write, by default, all the chunks in the<br/>
		/// 'unknown' list are written in the specified position.<br/>
		/// The integer return from the callback function is interpreted thus:<br/>
		/// negative: An error occurred; png_chunk_error will be called.<br/>
		/// zero: The chunk was not handled, the chunk will be saved. A critical<br/>
		/// chunk will cause an error at this point unless it is to be saved.<br/>
		/// positive: The chunk was handled, libpng will ignore/discard it.<br/>
		/// See "INTERACTION WITH USER CHUNK CALLBACKS" below for important notes about<br/>
		/// how this behavior will change in libpng 1.7<br/>
		/// </summary>
		public static void SetReadUserChunkFn(PngStruct* pngPtr, void* userChunkPtr, PngUserChunkPtr readUserChunkFn)
		{
			SetReadUserChunkFnNative(pngPtr, userChunkPtr, readUserChunkFn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetUserChunkPtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[103])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[103])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* GetUserChunkPtr(PngStruct* pngPtr)
		{
			void* ret = GetUserChunkPtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Sets the function callbacks for the push reader, and a pointer to a<br/>
		/// user-defined structure available to the callback functions.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetProgressiveReadFnNative(PngStruct* pngPtr, void* progressivePtr, PngProgressiveInfoPtr infoFn, PngProgressiveRowPtr rowFn, PngProgressiveEndPtr endFn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, delegate*<PngStruct*, PngInfo*, void>, delegate*<PngStruct*, byte*, uint, int, void>, delegate*<PngStruct*, PngInfo*, void>, void>)funcTable[104])(pngPtr, progressivePtr, (delegate*<PngStruct*, PngInfo*, void>)Utils.GetFunctionPointerForDelegate(infoFn), (delegate*<PngStruct*, byte*, uint, int, void>)Utils.GetFunctionPointerForDelegate(rowFn), (delegate*<PngStruct*, PngInfo*, void>)Utils.GetFunctionPointerForDelegate(endFn));
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, void>)funcTable[104])((nint)pngPtr, (nint)progressivePtr, (nint)Utils.GetFunctionPointerForDelegate(infoFn), (nint)Utils.GetFunctionPointerForDelegate(rowFn), (nint)Utils.GetFunctionPointerForDelegate(endFn));
			#endif
		}

		/// <summary>
		/// Sets the function callbacks for the push reader, and a pointer to a<br/>
		/// user-defined structure available to the callback functions.<br/>
		/// </summary>
		public static void SetProgressiveReadFn(PngStruct* pngPtr, void* progressivePtr, PngProgressiveInfoPtr infoFn, PngProgressiveRowPtr rowFn, PngProgressiveEndPtr endFn)
		{
			SetProgressiveReadFnNative(pngPtr, progressivePtr, infoFn, rowFn, endFn);
		}

		/// <summary>
		/// Returns the user pointer associated with the push read functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetProgressivePtrNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*>)funcTable[105])(pngPtr);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[105])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Returns the user pointer associated with the push read functions <br/>
		/// </summary>
		public static void* GetProgressivePtr(PngStruct* pngPtr)
		{
			void* ret = GetProgressivePtrNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Function to be called when data becomes available <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProcessDataNative(PngStruct* pngPtr, PngInfo* infoPtr, byte* buffer, nuint bufferSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte*, nuint, void>)funcTable[106])(pngPtr, infoPtr, buffer, bufferSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, void>)funcTable[106])((nint)pngPtr, (nint)infoPtr, (nint)buffer, bufferSize);
			#endif
		}

		/// <summary>
		/// Function to be called when data becomes available <br/>
		/// </summary>
		public static void ProcessData(PngStruct* pngPtr, PngInfo* infoPtr, byte* buffer, nuint bufferSize)
		{
			ProcessDataNative(pngPtr, infoPtr, buffer, bufferSize);
		}

		/// <summary>
		/// Function to be called when data becomes available <br/>
		/// </summary>
		public static void ProcessData(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> buffer, nuint bufferSize)
		{
			fixed (byte* pbuffer = buffer)
			{
				ProcessDataNative(pngPtr, infoPtr, (byte*)pbuffer, bufferSize);
			}
		}

		/// <summary>
		/// Function to be called when data becomes available <br/>
		/// </summary>
		public static void ProcessData(PngStruct* pngPtr, PngInfo* infoPtr, string buffer, nuint bufferSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProcessDataNative(pngPtr, infoPtr, pStr0, bufferSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// A function which may be called *only* within png_process_data to stop the<br/>
		/// processing of any more data.  The function returns the number of bytes<br/>
		/// remaining, excluding any that libpng has cached internally.  A subsequent<br/>
		/// call to png_process_data must supply these bytes again.  If the argument<br/>
		/// 'save' is set to true the routine will first save all the pending data and<br/>
		/// will always return 0.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint ProcessDataPauseNative(PngStruct* unknown0, int save)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int, nuint>)funcTable[107])(unknown0, save);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, int, nuint>)funcTable[107])((nint)unknown0, save);
			#endif
		}

		/// <summary>
		/// A function which may be called *only* within png_process_data to stop the<br/>
		/// processing of any more data.  The function returns the number of bytes<br/>
		/// remaining, excluding any that libpng has cached internally.  A subsequent<br/>
		/// call to png_process_data must supply these bytes again.  If the argument<br/>
		/// 'save' is set to true the routine will first save all the pending data and<br/>
		/// will always return 0.<br/>
		/// </summary>
		public static nuint ProcessDataPause(PngStruct* unknown0, int save)
		{
			nuint ret = ProcessDataPauseNative(unknown0, save);
			return ret;
		}

		/// <summary>
		/// A function which may be called *only* outside (after) a call to<br/>
		/// png_process_data.  It returns the number of bytes of data to skip in the<br/>
		/// input.  Normally it will return 0, but if it returns a non-zero value the<br/>
		/// application must skip than number of bytes of input data and pass the<br/>
		/// following data to the next call to png_process_data.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ProcessDataSkipNative(PngStruct* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[108])(unknown0);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[108])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// A function which may be called *only* outside (after) a call to<br/>
		/// png_process_data.  It returns the number of bytes of data to skip in the<br/>
		/// input.  Normally it will return 0, but if it returns a non-zero value the<br/>
		/// application must skip than number of bytes of input data and pass the<br/>
		/// following data to the next call to png_process_data.<br/>
		/// </summary>
		public static uint ProcessDataSkip(PngStruct* unknown0)
		{
			uint ret = ProcessDataSkipNative(unknown0);
			return ret;
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgressiveCombineRowNative(PngStruct* pngPtr, byte* oldRow, byte* newRow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, void>)funcTable[109])(pngPtr, oldRow, newRow);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[109])((nint)pngPtr, (nint)oldRow, (nint)newRow);
			#endif
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, byte* oldRow, byte* newRow)
		{
			ProgressiveCombineRowNative(pngPtr, oldRow, newRow);
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, ReadOnlySpan<byte> oldRow, byte* newRow)
		{
			fixed (byte* poldRow = oldRow)
			{
				ProgressiveCombineRowNative(pngPtr, (byte*)poldRow, newRow);
			}
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, string oldRow, byte* newRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldRow != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldRow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldRow, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressiveCombineRowNative(pngPtr, pStr0, newRow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, byte* oldRow, ReadOnlySpan<byte> newRow)
		{
			fixed (byte* pnewRow = newRow)
			{
				ProgressiveCombineRowNative(pngPtr, oldRow, (byte*)pnewRow);
			}
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, byte* oldRow, string newRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newRow != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newRow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newRow, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressiveCombineRowNative(pngPtr, oldRow, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, ReadOnlySpan<byte> oldRow, ReadOnlySpan<byte> newRow)
		{
			fixed (byte* poldRow = oldRow)
			{
				fixed (byte* pnewRow = newRow)
				{
					ProgressiveCombineRowNative(pngPtr, (byte*)poldRow, (byte*)pnewRow);
				}
			}
		}

		/// <summary>
		/// Function that combines rows.  'new_row' is a flag that should come from<br/>
		/// the callback and be non-NULL if anything needs to be done; the library<br/>
		/// stores its own version of the new data internally and ignores the passed<br/>
		/// in value.<br/>
		/// </summary>
		public static void ProgressiveCombineRow(PngStruct* pngPtr, string oldRow, string newRow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldRow != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldRow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldRow, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newRow != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newRow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newRow, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ProgressiveCombineRowNative(pngPtr, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocNative(PngStruct* pngPtr, nint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint, void*>)funcTable[110])(pngPtr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[110])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* Malloc(PngStruct* pngPtr, nint size)
		{
			void* ret = MallocNative(pngPtr, size);
			return ret;
		}

		/// <summary>
		/// Added at libpng version 1.4.0 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* CallocNative(PngStruct* pngPtr, nint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint, void*>)funcTable[111])(pngPtr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[111])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// Added at libpng version 1.4.0 <br/>
		/// </summary>
		public static void* Calloc(PngStruct* pngPtr, nint size)
		{
			void* ret = CallocNative(pngPtr, size);
			return ret;
		}

		/// <summary>
		/// Added at libpng version 1.2.4 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocWarnNative(PngStruct* pngPtr, nint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint, void*>)funcTable[112])(pngPtr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[112])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// Added at libpng version 1.2.4 <br/>
		/// </summary>
		public static void* MallocWarn(PngStruct* pngPtr, nint size)
		{
			void* ret = MallocWarnNative(pngPtr, size);
			return ret;
		}

		/// <summary>
		/// Frees a pointer allocated by png_malloc() <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeNative(PngStruct* pngPtr, void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, void>)funcTable[113])(pngPtr, ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[113])((nint)pngPtr, (nint)ptr);
			#endif
		}

		/// <summary>
		/// Frees a pointer allocated by png_malloc() <br/>
		/// </summary>
		public static void Free(PngStruct* pngPtr, void* ptr)
		{
			FreeNative(pngPtr, ptr);
		}

		/// <summary>
		/// Free data that was allocated internally <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeDataNative(PngStruct* pngPtr, PngInfo* infoPtr, uint freeMe, int num)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint, int, void>)funcTable[114])(pngPtr, infoPtr, freeMe, num);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, int, void>)funcTable[114])((nint)pngPtr, (nint)infoPtr, freeMe, num);
			#endif
		}

		/// <summary>
		/// Free data that was allocated internally <br/>
		/// </summary>
		public static void FreeData(PngStruct* pngPtr, PngInfo* infoPtr, uint freeMe, int num)
		{
			FreeDataNative(pngPtr, infoPtr, freeMe, num);
		}

		/// <summary>
		/// Reassign the responsibility for freeing existing data, whether allocated<br/>
		/// by libpng or by the application; this works on the png_info structure passed<br/>
		/// in, without changing the state for other png_info structures.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DataFreerNative(PngStruct* pngPtr, PngInfo* infoPtr, int freer, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, uint, void>)funcTable[115])(pngPtr, infoPtr, freer, mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, uint, void>)funcTable[115])((nint)pngPtr, (nint)infoPtr, freer, mask);
			#endif
		}

		/// <summary>
		/// Reassign the responsibility for freeing existing data, whether allocated<br/>
		/// by libpng or by the application; this works on the png_info structure passed<br/>
		/// in, without changing the state for other png_info structures.<br/>
		/// </summary>
		public static void DataFreer(PngStruct* pngPtr, PngInfo* infoPtr, int freer, uint mask)
		{
			DataFreerNative(pngPtr, infoPtr, freer, mask);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocDefaultNative(PngStruct* pngPtr, nint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint, void*>)funcTable[116])(pngPtr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[116])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* MallocDefault(PngStruct* pngPtr, nint size)
		{
			void* ret = MallocDefaultNative(pngPtr, size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeDefaultNative(PngStruct* pngPtr, void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void*, void>)funcTable[117])(pngPtr, ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[117])((nint)pngPtr, (nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FreeDefault(PngStruct* pngPtr, void* ptr)
		{
			FreeDefaultNative(pngPtr, ptr);
		}

		/// <summary>
		/// Fatal error in PNG image of libpng - can't continue <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ErrorNative(PngStruct* pngPtr, byte* errorMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[118])(pngPtr, errorMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[118])((nint)pngPtr, (nint)errorMessage);
			#endif
		}

		/// <summary>
		/// Fatal error in PNG image of libpng - can't continue <br/>
		/// </summary>
		public static void Error(PngStruct* pngPtr, byte* errorMessage)
		{
			ErrorNative(pngPtr, errorMessage);
		}

		/// <summary>
		/// Fatal error in PNG image of libpng - can't continue <br/>
		/// </summary>
		public static void Error(PngStruct* pngPtr, ReadOnlySpan<byte> errorMessage)
		{
			fixed (byte* perrorMessage = errorMessage)
			{
				ErrorNative(pngPtr, (byte*)perrorMessage);
			}
		}

		/// <summary>
		/// Fatal error in PNG image of libpng - can't continue <br/>
		/// </summary>
		public static void Error(PngStruct* pngPtr, string errorMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errorMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errorMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errorMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// The same, but the chunk name is prepended to the error string. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChunkErrorNative(PngStruct* pngPtr, byte* errorMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[119])(pngPtr, errorMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[119])((nint)pngPtr, (nint)errorMessage);
			#endif
		}

		/// <summary>
		/// The same, but the chunk name is prepended to the error string. <br/>
		/// </summary>
		public static void ChunkError(PngStruct* pngPtr, byte* errorMessage)
		{
			ChunkErrorNative(pngPtr, errorMessage);
		}

		/// <summary>
		/// The same, but the chunk name is prepended to the error string. <br/>
		/// </summary>
		public static void ChunkError(PngStruct* pngPtr, ReadOnlySpan<byte> errorMessage)
		{
			fixed (byte* perrorMessage = errorMessage)
			{
				ChunkErrorNative(pngPtr, (byte*)perrorMessage);
			}
		}

		/// <summary>
		/// The same, but the chunk name is prepended to the error string. <br/>
		/// </summary>
		public static void ChunkError(PngStruct* pngPtr, string errorMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errorMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errorMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errorMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ChunkErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Non-fatal error in libpng.  Can continue, but may have a problem. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarningNative(PngStruct* pngPtr, byte* warningMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[120])(pngPtr, warningMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[120])((nint)pngPtr, (nint)warningMessage);
			#endif
		}

		/// <summary>
		/// Non-fatal error in libpng.  Can continue, but may have a problem. <br/>
		/// </summary>
		public static void Warning(PngStruct* pngPtr, byte* warningMessage)
		{
			WarningNative(pngPtr, warningMessage);
		}

		/// <summary>
		/// Non-fatal error in libpng.  Can continue, but may have a problem. <br/>
		/// </summary>
		public static void Warning(PngStruct* pngPtr, ReadOnlySpan<byte> warningMessage)
		{
			fixed (byte* pwarningMessage = warningMessage)
			{
				WarningNative(pngPtr, (byte*)pwarningMessage);
			}
		}

		/// <summary>
		/// Non-fatal error in libpng.  Can continue, but may have a problem. <br/>
		/// </summary>
		public static void Warning(PngStruct* pngPtr, string warningMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (warningMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(warningMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(warningMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WarningNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Non-fatal error in libpng, chunk name is prepended to message. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChunkWarningNative(PngStruct* pngPtr, byte* warningMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[121])(pngPtr, warningMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[121])((nint)pngPtr, (nint)warningMessage);
			#endif
		}

		/// <summary>
		/// Non-fatal error in libpng, chunk name is prepended to message. <br/>
		/// </summary>
		public static void ChunkWarning(PngStruct* pngPtr, byte* warningMessage)
		{
			ChunkWarningNative(pngPtr, warningMessage);
		}

		/// <summary>
		/// Non-fatal error in libpng, chunk name is prepended to message. <br/>
		/// </summary>
		public static void ChunkWarning(PngStruct* pngPtr, ReadOnlySpan<byte> warningMessage)
		{
			fixed (byte* pwarningMessage = warningMessage)
			{
				ChunkWarningNative(pngPtr, (byte*)pwarningMessage);
			}
		}

		/// <summary>
		/// Non-fatal error in libpng, chunk name is prepended to message. <br/>
		/// </summary>
		public static void ChunkWarning(PngStruct* pngPtr, string warningMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (warningMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(warningMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(warningMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ChunkWarningNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Benign error in libpng.  Can continue, but may have a problem.<br/>
		/// User can choose whether to handle as a fatal error or as a warning. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BenignErrorNative(PngStruct* pngPtr, byte* warningMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[122])(pngPtr, warningMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[122])((nint)pngPtr, (nint)warningMessage);
			#endif
		}

		/// <summary>
		/// Benign error in libpng.  Can continue, but may have a problem.<br/>
		/// User can choose whether to handle as a fatal error or as a warning. <br/>
		/// </summary>
		public static void BenignError(PngStruct* pngPtr, byte* warningMessage)
		{
			BenignErrorNative(pngPtr, warningMessage);
		}

		/// <summary>
		/// Benign error in libpng.  Can continue, but may have a problem.<br/>
		/// User can choose whether to handle as a fatal error or as a warning. <br/>
		/// </summary>
		public static void BenignError(PngStruct* pngPtr, ReadOnlySpan<byte> warningMessage)
		{
			fixed (byte* pwarningMessage = warningMessage)
			{
				BenignErrorNative(pngPtr, (byte*)pwarningMessage);
			}
		}

		/// <summary>
		/// Benign error in libpng.  Can continue, but may have a problem.<br/>
		/// User can choose whether to handle as a fatal error or as a warning. <br/>
		/// </summary>
		public static void BenignError(PngStruct* pngPtr, string warningMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (warningMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(warningMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(warningMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BenignErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Same, chunk name is prepended to message (only during read) <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChunkBenignErrorNative(PngStruct* pngPtr, byte* warningMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[123])(pngPtr, warningMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[123])((nint)pngPtr, (nint)warningMessage);
			#endif
		}

		/// <summary>
		/// Same, chunk name is prepended to message (only during read) <br/>
		/// </summary>
		public static void ChunkBenignError(PngStruct* pngPtr, byte* warningMessage)
		{
			ChunkBenignErrorNative(pngPtr, warningMessage);
		}

		/// <summary>
		/// Same, chunk name is prepended to message (only during read) <br/>
		/// </summary>
		public static void ChunkBenignError(PngStruct* pngPtr, ReadOnlySpan<byte> warningMessage)
		{
			fixed (byte* pwarningMessage = warningMessage)
			{
				ChunkBenignErrorNative(pngPtr, (byte*)pwarningMessage);
			}
		}

		/// <summary>
		/// Same, chunk name is prepended to message (only during read) <br/>
		/// </summary>
		public static void ChunkBenignError(PngStruct* pngPtr, string warningMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (warningMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(warningMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(warningMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ChunkBenignErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBenignErrorsNative(PngStruct* pngPtr, int allowed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[124])(pngPtr, allowed);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[124])((nint)pngPtr, allowed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBenignErrors(PngStruct* pngPtr, int allowed)
		{
			SetBenignErrorsNative(pngPtr, allowed);
		}

		/// <summary>
		/// The png_set_<br/>
		/// <chunk<br/>
		/// > functions are for storing values in the png_info_struct.<br/>
		/// Similarly, the png_get_<br/>
		/// <chunk<br/>
		/// > calls are used to read values from the<br/>
		/// png_info_struct, either storing the parameters in the passed variables, or<br/>
		/// setting pointers into the png_info_struct where the data is stored.  The<br/>
		/// png_get_<br/>
		/// <chunk<br/>
		/// > functions return a non-zero value if the data was available<br/>
		/// in info_ptr, or return zero and do not change any of the parameters if the<br/>
		/// data was not available.<br/>
		/// These functions should be used instead of directly accessing png_info<br/>
		/// to avoid problems with future changes in the size and internal layout of<br/>
		/// png_info_struct.<br/>
		/// Returns "flag" if chunk data is valid in info_ptr. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetValidNative(PngStruct* pngPtr, PngInfo* infoPtr, uint flag)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint, uint>)funcTable[125])(pngPtr, infoPtr, flag);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint, uint>)funcTable[125])((nint)pngPtr, (nint)infoPtr, flag);
			#endif
		}

		/// <summary>
		/// The png_set_<br/>
		/// <chunk<br/>
		/// > functions are for storing values in the png_info_struct.<br/>
		/// Similarly, the png_get_<br/>
		/// <chunk<br/>
		/// > calls are used to read values from the<br/>
		/// png_info_struct, either storing the parameters in the passed variables, or<br/>
		/// setting pointers into the png_info_struct where the data is stored.  The<br/>
		/// png_get_<br/>
		/// <chunk<br/>
		/// > functions return a non-zero value if the data was available<br/>
		/// in info_ptr, or return zero and do not change any of the parameters if the<br/>
		/// data was not available.<br/>
		/// These functions should be used instead of directly accessing png_info<br/>
		/// to avoid problems with future changes in the size and internal layout of<br/>
		/// png_info_struct.<br/>
		/// Returns "flag" if chunk data is valid in info_ptr. <br/>
		/// </summary>
		public static uint GetValid(PngStruct* pngPtr, PngInfo* infoPtr, uint flag)
		{
			uint ret = GetValidNative(pngPtr, infoPtr, flag);
			return ret;
		}

		/// <summary>
		/// Returns number of bytes needed to hold a transformed row. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint GetRowbytesNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, nuint>)funcTable[126])(pngPtr, infoPtr);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nint, nuint>)funcTable[126])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns number of bytes needed to hold a transformed row. <br/>
		/// </summary>
		public static nuint GetRowbytes(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			nuint ret = GetRowbytesNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns row_pointers, which is an array of pointers to scanlines that was<br/>
		/// returned from png_read_png().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetRowsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte**>)funcTable[127])(pngPtr, infoPtr);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[127])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns row_pointers, which is an array of pointers to scanlines that was<br/>
		/// returned from png_read_png().<br/>
		/// </summary>
		public static byte** GetRows(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte** ret = GetRowsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Set row_pointers, which is an array of pointers to scanlines for use<br/>
		/// by png_write_png().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRowsNative(PngStruct* pngPtr, PngInfo* infoPtr, byte** rowPointers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte**, void>)funcTable[128])(pngPtr, infoPtr, rowPointers);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[128])((nint)pngPtr, (nint)infoPtr, (nint)rowPointers);
			#endif
		}

		/// <summary>
		/// Set row_pointers, which is an array of pointers to scanlines for use<br/>
		/// by png_write_png().<br/>
		/// </summary>
		public static void SetRows(PngStruct* pngPtr, PngInfo* infoPtr, byte** rowPointers)
		{
			SetRowsNative(pngPtr, infoPtr, rowPointers);
		}

		/// <summary>
		/// Returns number of color channels in image. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetChannelsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[129])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[129])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns number of color channels in image. <br/>
		/// </summary>
		public static byte GetChannels(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetChannelsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image width in pixels. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetImageWidthNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[130])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[130])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image width in pixels. <br/>
		/// </summary>
		public static uint GetImageWidth(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetImageWidthNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image height in pixels. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetImageHeightNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[131])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[131])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image height in pixels. <br/>
		/// </summary>
		public static uint GetImageHeight(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetImageHeightNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image bit_depth. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetBitDepthNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[132])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[132])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image bit_depth. <br/>
		/// </summary>
		public static byte GetBitDepth(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetBitDepthNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image color_type. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetColorTypeNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[133])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[133])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image color_type. <br/>
		/// </summary>
		public static byte GetColorType(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetColorTypeNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image filter_type. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetFilterTypeNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[134])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[134])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image filter_type. <br/>
		/// </summary>
		public static byte GetFilterType(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetFilterTypeNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image interlace_type. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetInterlaceTypeNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[135])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[135])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image interlace_type. <br/>
		/// </summary>
		public static byte GetInterlaceType(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetInterlaceTypeNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image compression_type. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetCompressionTypeNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte>)funcTable[136])(pngPtr, infoPtr);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[136])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image compression_type. <br/>
		/// </summary>
		public static byte GetCompressionType(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte ret = GetCompressionTypeNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image resolution in pixels per meter, from pHYs chunk data. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetPixelsPerMeterNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[137])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[137])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image resolution in pixels per meter, from pHYs chunk data. <br/>
		/// </summary>
		public static uint GetPixelsPerMeter(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetPixelsPerMeterNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetXPixelsPerMeterNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[138])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[138])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetXPixelsPerMeter(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetXPixelsPerMeterNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetYPixelsPerMeterNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[139])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[139])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetYPixelsPerMeter(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetYPixelsPerMeterNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns pixel aspect ratio, computed from pHYs chunk data.  <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetPixelAspectRatioNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, float>)funcTable[140])(pngPtr, infoPtr);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, nint, float>)funcTable[140])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns pixel aspect ratio, computed from pHYs chunk data.  <br/>
		/// </summary>
		public static float GetPixelAspectRatio(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			float ret = GetPixelAspectRatioNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns pixel aspect ratio, computed from pHYs chunk data.  <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetPixelAspectRatioFixedNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[141])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[141])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns pixel aspect ratio, computed from pHYs chunk data.  <br/>
		/// </summary>
		public static int GetPixelAspectRatioFixed(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetPixelAspectRatioFixedNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns image x, y offset in pixels or microns, from oFFs chunk data. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetXOffsetPixelsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[142])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[142])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns image x, y offset in pixels or microns, from oFFs chunk data. <br/>
		/// </summary>
		public static int GetXOffsetPixels(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetXOffsetPixelsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetYOffsetPixelsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[143])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[143])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetYOffsetPixels(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetYOffsetPixelsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetXOffsetMicronsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[144])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[144])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetXOffsetMicrons(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetXOffsetMicronsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetYOffsetMicronsNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[145])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[145])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetYOffsetMicrons(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetYOffsetMicronsNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns pointer to signature string read from PNG header <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetSignatureNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte*>)funcTable[146])(pngPtr, infoPtr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[146])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Returns pointer to signature string read from PNG header <br/>
		/// </summary>
		public static byte* GetSignature(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			byte* ret = GetSignatureNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// Returns pointer to signature string read from PNG header <br/>
		/// </summary>
		public static string GetSignatureS(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			string ret = Utils.DecodeStringUTF8(GetSignatureNative(pngPtr, infoPtr));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetBKGDNative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor16** background)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor16**, uint>)funcTable[147])(pngPtr, infoPtr, background);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[147])((nint)pngPtr, (nint)infoPtr, (nint)background);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetBKGD(PngStruct* pngPtr, PngInfo* infoPtr, PngColor16** background)
		{
			uint ret = GetBKGDNative(pngPtr, infoPtr, background);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetBKGD(PngStruct* pngPtr, PngInfo* infoPtr, ref PngColor16* background)
		{
			fixed (PngColor16** pbackground = &background)
			{
				uint ret = GetBKGDNative(pngPtr, infoPtr, (PngColor16**)pbackground);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBKGDNative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor16* background)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor16*, void>)funcTable[148])(pngPtr, infoPtr, background);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[148])((nint)pngPtr, (nint)infoPtr, (nint)background);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBKGD(PngStruct* pngPtr, PngInfo* infoPtr, PngColor16* background)
		{
			SetBKGDNative(pngPtr, infoPtr, background);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCHRMNative(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, double* redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, double*, double*, double*, double*, double*, double*, double*, double*, uint>)funcTable[149])(pngPtr, infoPtr, whiteX, whiteY, redX, redY, greenX, greenY, blueX, blueY);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, nint, nint, nint, nint, uint>)funcTable[149])((nint)pngPtr, (nint)infoPtr, (nint)whiteX, (nint)whiteY, (nint)redX, (nint)redY, (nint)greenX, (nint)greenY, (nint)blueX, (nint)blueY);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, double* redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, redX, redY, greenX, greenY, blueX, blueY);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, double* redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, redX, redY, greenX, greenY, blueX, blueY);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, double* redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, redX, redY, greenX, greenY, blueX, blueY);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, double* redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, redX, redY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, ref double redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* predX = &redX)
			{
				uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, (double*)predX, redY, greenX, greenY, blueX, blueY);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, ref double redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* predX = &redX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, (double*)predX, redY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, ref double redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* predX = &redX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, (double*)predX, redY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, ref double redX, double* redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* predX = &redX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, (double*)predX, redY, greenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, double* redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* predY = &redY)
			{
				uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, redX, (double*)predY, greenX, greenY, blueX, blueY);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, double* redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* predY = &redY)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, redX, (double*)predY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, double* redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* predY = &redY)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, redX, (double*)predY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, double* redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* predY = &redY)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, redX, (double*)predY, greenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, ref double redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* predX = &redX)
			{
				fixed (double* predY = &redY)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, (double*)predX, (double*)predY, greenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, ref double redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* predX = &redX)
				{
					fixed (double* predY = &redY)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, (double*)predX, (double*)predY, greenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, ref double redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* predX = &redX)
				{
					fixed (double* predY = &redY)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, (double*)predX, (double*)predY, greenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, ref double redX, ref double redY, double* greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* predX = &redX)
					{
						fixed (double* predY = &redY)
						{
							uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, (double*)predX, (double*)predY, greenX, greenY, blueX, blueY);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, double* redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pgreenX = &greenX)
			{
				uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, redX, redY, (double*)pgreenX, greenY, blueX, blueY);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, double* redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pgreenX = &greenX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, redX, redY, (double*)pgreenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, double* redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* pgreenX = &greenX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, redX, redY, (double*)pgreenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, double* redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* pgreenX = &greenX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, redX, redY, (double*)pgreenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, ref double redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* predX = &redX)
			{
				fixed (double* pgreenX = &greenX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, (double*)predX, redY, (double*)pgreenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, ref double redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* predX = &redX)
				{
					fixed (double* pgreenX = &greenX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, (double*)predX, redY, (double*)pgreenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, ref double redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* predX = &redX)
				{
					fixed (double* pgreenX = &greenX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, (double*)predX, redY, (double*)pgreenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, ref double redX, double* redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* predX = &redX)
					{
						fixed (double* pgreenX = &greenX)
						{
							uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, (double*)predX, redY, (double*)pgreenX, greenY, blueX, blueY);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, double* whiteY, double* redX, ref double redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* predY = &redY)
			{
				fixed (double* pgreenX = &greenX)
				{
					uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, whiteY, redX, (double*)predY, (double*)pgreenX, greenY, blueX, blueY);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, double* whiteY, double* redX, ref double redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* predY = &redY)
				{
					fixed (double* pgreenX = &greenX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, whiteY, redX, (double*)predY, (double*)pgreenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, double* whiteX, ref double whiteY, double* redX, ref double redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteY = &whiteY)
			{
				fixed (double* predY = &redY)
				{
					fixed (double* pgreenX = &greenX)
					{
						uint ret = GetCHRMNative(pngPtr, infoPtr, whiteX, (double*)pwhiteY, redX, (double*)predY, (double*)pgreenX, greenY, blueX, blueY);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetCHRM(PngStruct* pngPtr, PngInfo* infoPtr, ref double whiteX, ref double whiteY, double* redX, ref double redY, ref double greenX, double* greenY, double* blueX, double* blueY)
		{
			fixed (double* pwhiteX = &whiteX)
			{
				fixed (double* pwhiteY = &whiteY)
				{
					fixed (double* predY = &redY)
					{
						fixed (double* pgreenX = &greenX)
						{
							uint ret = GetCHRMNative(pngPtr, infoPtr, (double*)pwhiteX, (double*)pwhiteY, redX, (double*)predY, (double*)pgreenX, greenY, blueX, blueY);
							return ret;
						}
					}
				}
			}
		}
	}
}
