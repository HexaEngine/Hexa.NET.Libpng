// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	public unsafe partial class Libpng
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* purpose, ref int x0, int* x1, ref int type, ref int nparams, ref byte* units, ref byte** @params)
		{
			fixed (byte** ppurpose = &purpose)
			{
				fixed (int* px0 = &x0)
				{
					fixed (int* ptype = &type)
					{
						fixed (int* pnparams = &nparams)
						{
							fixed (byte** punits = &units)
							{
								fixed (byte*** pparams = &@params)
								{
									uint ret = GetPCALNative(pngPtr, infoPtr, (byte**)ppurpose, (int*)px0, x1, (int*)ptype, (int*)pnparams, (byte**)punits, (byte***)pparams);
									return ret;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, byte** purpose, int* x0, ref int x1, ref int type, ref int nparams, ref byte* units, ref byte** @params)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* ptype = &type)
				{
					fixed (int* pnparams = &nparams)
					{
						fixed (byte** punits = &units)
						{
							fixed (byte*** pparams = &@params)
							{
								uint ret = GetPCALNative(pngPtr, infoPtr, purpose, x0, (int*)px1, (int*)ptype, (int*)pnparams, (byte**)punits, (byte***)pparams);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* purpose, int* x0, ref int x1, ref int type, ref int nparams, ref byte* units, ref byte** @params)
		{
			fixed (byte** ppurpose = &purpose)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* ptype = &type)
					{
						fixed (int* pnparams = &nparams)
						{
							fixed (byte** punits = &units)
							{
								fixed (byte*** pparams = &@params)
								{
									uint ret = GetPCALNative(pngPtr, infoPtr, (byte**)ppurpose, x0, (int*)px1, (int*)ptype, (int*)pnparams, (byte**)punits, (byte***)pparams);
									return ret;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, byte** purpose, ref int x0, ref int x1, ref int type, ref int nparams, ref byte* units, ref byte** @params)
		{
			fixed (int* px0 = &x0)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* ptype = &type)
					{
						fixed (int* pnparams = &nparams)
						{
							fixed (byte** punits = &units)
							{
								fixed (byte*** pparams = &@params)
								{
									uint ret = GetPCALNative(pngPtr, infoPtr, purpose, (int*)px0, (int*)px1, (int*)ptype, (int*)pnparams, (byte**)punits, (byte***)pparams);
									return ret;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* purpose, ref int x0, ref int x1, ref int type, ref int nparams, ref byte* units, ref byte** @params)
		{
			fixed (byte** ppurpose = &purpose)
			{
				fixed (int* px0 = &x0)
				{
					fixed (int* px1 = &x1)
					{
						fixed (int* ptype = &type)
						{
							fixed (int* pnparams = &nparams)
							{
								fixed (byte** punits = &units)
								{
									fixed (byte*** pparams = &@params)
									{
										uint ret = GetPCALNative(pngPtr, infoPtr, (byte**)ppurpose, (int*)px0, (int*)px1, (int*)ptype, (int*)pnparams, (byte**)punits, (byte***)pparams);
										return ret;
									}
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPCALNative(PngStruct* pngPtr, PngInfo* infoPtr, byte* purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte*, int, int, int, int, byte*, byte**, void>)funcTable[182])(pngPtr, infoPtr, purpose, x0, x1, type, nparams, units, @params);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int, int, int, nint, nint, void>)funcTable[182])((nint)pngPtr, (nint)infoPtr, (nint)purpose, x0, x1, type, nparams, (nint)units, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, byte* purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			SetPCALNative(pngPtr, infoPtr, purpose, x0, x1, type, nparams, units, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			fixed (byte* ppurpose = purpose)
			{
				SetPCALNative(pngPtr, infoPtr, (byte*)ppurpose, x0, x1, type, nparams, units, @params);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, string purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (purpose != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(purpose);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(purpose, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetPCALNative(pngPtr, infoPtr, pStr0, x0, x1, type, nparams, units, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, byte* purpose, int x0, int x1, int type, int nparams, ReadOnlySpan<byte> units, byte** @params)
		{
			fixed (byte* punits = units)
			{
				SetPCALNative(pngPtr, infoPtr, purpose, x0, x1, type, nparams, (byte*)punits, @params);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, byte* purpose, int x0, int x1, int type, int nparams, string units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (units != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(units);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(units, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetPCALNative(pngPtr, infoPtr, purpose, x0, x1, type, nparams, pStr0, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> purpose, int x0, int x1, int type, int nparams, ReadOnlySpan<byte> units, byte** @params)
		{
			fixed (byte* ppurpose = purpose)
			{
				fixed (byte* punits = units)
				{
					SetPCALNative(pngPtr, infoPtr, (byte*)ppurpose, x0, x1, type, nparams, (byte*)punits, @params);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPCAL(PngStruct* pngPtr, PngInfo* infoPtr, string purpose, int x0, int x1, int type, int nparams, string units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (purpose != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(purpose);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(purpose, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (units != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(units);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(units, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SetPCALNative(pngPtr, infoPtr, pStr0, x0, x1, type, nparams, pStr1, @params);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetPHYsNative(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, int* unitType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint*, uint*, int*, uint>)funcTable[183])(pngPtr, infoPtr, resX, resY, unitType);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[183])((nint)pngPtr, (nint)infoPtr, (nint)resX, (nint)resY, (nint)unitType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, int* unitType)
		{
			uint ret = GetPHYsNative(pngPtr, infoPtr, resX, resY, unitType);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, uint* resY, int* unitType)
		{
			fixed (uint* presX = &resX)
			{
				uint ret = GetPHYsNative(pngPtr, infoPtr, (uint*)presX, resY, unitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, ref uint resY, int* unitType)
		{
			fixed (uint* presY = &resY)
			{
				uint ret = GetPHYsNative(pngPtr, infoPtr, resX, (uint*)presY, unitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, ref uint resY, int* unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (uint* presY = &resY)
				{
					uint ret = GetPHYsNative(pngPtr, infoPtr, (uint*)presX, (uint*)presY, unitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, ref int unitType)
		{
			fixed (int* punitType = &unitType)
			{
				uint ret = GetPHYsNative(pngPtr, infoPtr, resX, resY, (int*)punitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, uint* resY, ref int unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (int* punitType = &unitType)
				{
					uint ret = GetPHYsNative(pngPtr, infoPtr, (uint*)presX, resY, (int*)punitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, ref uint resY, ref int unitType)
		{
			fixed (uint* presY = &resY)
			{
				fixed (int* punitType = &unitType)
				{
					uint ret = GetPHYsNative(pngPtr, infoPtr, resX, (uint*)presY, (int*)punitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, ref uint resY, ref int unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (uint* presY = &resY)
				{
					fixed (int* punitType = &unitType)
					{
						uint ret = GetPHYsNative(pngPtr, infoPtr, (uint*)presX, (uint*)presY, (int*)punitType);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPHYsNative(PngStruct* pngPtr, PngInfo* infoPtr, uint resX, uint resY, int unitType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint, uint, int, void>)funcTable[184])(pngPtr, infoPtr, resX, resY, unitType);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, uint, int, void>)funcTable[184])((nint)pngPtr, (nint)infoPtr, resX, resY, unitType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPHYs(PngStruct* pngPtr, PngInfo* infoPtr, uint resX, uint resY, int unitType)
		{
			SetPHYsNative(pngPtr, infoPtr, resX, resY, unitType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetPLTENative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor** palette, int* numPalette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor**, int*, uint>)funcTable[185])(pngPtr, infoPtr, palette, numPalette);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, uint>)funcTable[185])((nint)pngPtr, (nint)infoPtr, (nint)palette, (nint)numPalette);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPLTE(PngStruct* pngPtr, PngInfo* infoPtr, PngColor** palette, int* numPalette)
		{
			uint ret = GetPLTENative(pngPtr, infoPtr, palette, numPalette);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPLTE(PngStruct* pngPtr, PngInfo* infoPtr, ref PngColor* palette, int* numPalette)
		{
			fixed (PngColor** ppalette = &palette)
			{
				uint ret = GetPLTENative(pngPtr, infoPtr, (PngColor**)ppalette, numPalette);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPLTE(PngStruct* pngPtr, PngInfo* infoPtr, PngColor** palette, ref int numPalette)
		{
			fixed (int* pnumPalette = &numPalette)
			{
				uint ret = GetPLTENative(pngPtr, infoPtr, palette, (int*)pnumPalette);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPLTE(PngStruct* pngPtr, PngInfo* infoPtr, ref PngColor* palette, ref int numPalette)
		{
			fixed (PngColor** ppalette = &palette)
			{
				fixed (int* pnumPalette = &numPalette)
				{
					uint ret = GetPLTENative(pngPtr, infoPtr, (PngColor**)ppalette, (int*)pnumPalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetPLTENative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor* palette, int numPalette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor*, int, void>)funcTable[186])(pngPtr, infoPtr, palette, numPalette);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[186])((nint)pngPtr, (nint)infoPtr, (nint)palette, numPalette);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetPLTE(PngStruct* pngPtr, PngInfo* infoPtr, PngColor* palette, int numPalette)
		{
			SetPLTENative(pngPtr, infoPtr, palette, numPalette);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSBITNative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor8** sigBit)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor8**, uint>)funcTable[187])(pngPtr, infoPtr, sigBit);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[187])((nint)pngPtr, (nint)infoPtr, (nint)sigBit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSBIT(PngStruct* pngPtr, PngInfo* infoPtr, PngColor8** sigBit)
		{
			uint ret = GetSBITNative(pngPtr, infoPtr, sigBit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSBIT(PngStruct* pngPtr, PngInfo* infoPtr, ref PngColor8* sigBit)
		{
			fixed (PngColor8** psigBit = &sigBit)
			{
				uint ret = GetSBITNative(pngPtr, infoPtr, (PngColor8**)psigBit);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSBITNative(PngStruct* pngPtr, PngInfo* infoPtr, PngColor8* sigBit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngColor8*, void>)funcTable[188])(pngPtr, infoPtr, sigBit);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[188])((nint)pngPtr, (nint)infoPtr, (nint)sigBit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSBIT(PngStruct* pngPtr, PngInfo* infoPtr, PngColor8* sigBit)
		{
			SetSBITNative(pngPtr, infoPtr, sigBit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSRGBNative(PngStruct* pngPtr, PngInfo* infoPtr, int* fileSrgbIntent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int*, uint>)funcTable[189])(pngPtr, infoPtr, fileSrgbIntent);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[189])((nint)pngPtr, (nint)infoPtr, (nint)fileSrgbIntent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSRGB(PngStruct* pngPtr, PngInfo* infoPtr, int* fileSrgbIntent)
		{
			uint ret = GetSRGBNative(pngPtr, infoPtr, fileSrgbIntent);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSRGB(PngStruct* pngPtr, PngInfo* infoPtr, ref int fileSrgbIntent)
		{
			fixed (int* pfileSrgbIntent = &fileSrgbIntent)
			{
				uint ret = GetSRGBNative(pngPtr, infoPtr, (int*)pfileSrgbIntent);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSRGBNative(PngStruct* pngPtr, PngInfo* infoPtr, int srgbIntent)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, void>)funcTable[190])(pngPtr, infoPtr, srgbIntent);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[190])((nint)pngPtr, (nint)infoPtr, srgbIntent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSRGB(PngStruct* pngPtr, PngInfo* infoPtr, int srgbIntent)
		{
			SetSRGBNative(pngPtr, infoPtr, srgbIntent);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSRGBGAMAAndCHRMNative(PngStruct* pngPtr, PngInfo* infoPtr, int srgbIntent)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, void>)funcTable[191])(pngPtr, infoPtr, srgbIntent);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[191])((nint)pngPtr, (nint)infoPtr, srgbIntent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSRGBGAMAAndCHRM(PngStruct* pngPtr, PngInfo* infoPtr, int srgbIntent)
		{
			SetSRGBGAMAAndCHRMNative(pngPtr, infoPtr, srgbIntent);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetICCPNative(PngStruct* pngPtr, PngInfo* infoPtr, byte** name, int* compressionType, byte** profile, uint* proflen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte**, int*, byte**, uint*, uint>)funcTable[192])(pngPtr, infoPtr, name, compressionType, profile, proflen);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, uint>)funcTable[192])((nint)pngPtr, (nint)infoPtr, (nint)name, (nint)compressionType, (nint)profile, (nint)proflen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte** name, int* compressionType, byte** profile, uint* proflen)
		{
			uint ret = GetICCPNative(pngPtr, infoPtr, name, compressionType, profile, proflen);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte** name, ref int compressionType, byte** profile, uint* proflen)
		{
			fixed (int* pcompressionType = &compressionType)
			{
				uint ret = GetICCPNative(pngPtr, infoPtr, name, (int*)pcompressionType, profile, proflen);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte** name, int* compressionType, byte** profile, ref uint proflen)
		{
			fixed (uint* pproflen = &proflen)
			{
				uint ret = GetICCPNative(pngPtr, infoPtr, name, compressionType, profile, (uint*)pproflen);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte** name, ref int compressionType, byte** profile, ref uint proflen)
		{
			fixed (int* pcompressionType = &compressionType)
			{
				fixed (uint* pproflen = &proflen)
				{
					uint ret = GetICCPNative(pngPtr, infoPtr, name, (int*)pcompressionType, profile, (uint*)pproflen);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetICCPNative(PngStruct* pngPtr, PngInfo* infoPtr, byte* name, int compressionType, byte* profile, uint proflen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte*, int, byte*, uint, void>)funcTable[193])(pngPtr, infoPtr, name, compressionType, profile, proflen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, uint, void>)funcTable[193])((nint)pngPtr, (nint)infoPtr, (nint)name, compressionType, (nint)profile, proflen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte* name, int compressionType, byte* profile, uint proflen)
		{
			SetICCPNative(pngPtr, infoPtr, name, compressionType, profile, proflen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> name, int compressionType, byte* profile, uint proflen)
		{
			fixed (byte* pname = name)
			{
				SetICCPNative(pngPtr, infoPtr, (byte*)pname, compressionType, profile, proflen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, string name, int compressionType, byte* profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetICCPNative(pngPtr, infoPtr, pStr0, compressionType, profile, proflen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte* name, int compressionType, ReadOnlySpan<byte> profile, uint proflen)
		{
			fixed (byte* pprofile = profile)
			{
				SetICCPNative(pngPtr, infoPtr, name, compressionType, (byte*)pprofile, proflen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, byte* name, int compressionType, string profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (profile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(profile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(profile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetICCPNative(pngPtr, infoPtr, name, compressionType, pStr0, proflen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> name, int compressionType, ReadOnlySpan<byte> profile, uint proflen)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pprofile = profile)
				{
					SetICCPNative(pngPtr, infoPtr, (byte*)pname, compressionType, (byte*)pprofile, proflen);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetICCP(PngStruct* pngPtr, PngInfo* infoPtr, string name, int compressionType, string profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (profile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(profile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(profile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SetICCPNative(pngPtr, infoPtr, pStr0, compressionType, pStr1, proflen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSPLTNative(PngStruct* pngPtr, PngInfo* infoPtr, PngSPLT* entries)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngSPLT*, int>)funcTable[194])(pngPtr, infoPtr, entries);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[194])((nint)pngPtr, (nint)infoPtr, (nint)entries);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSPLT(PngStruct* pngPtr, PngInfo* infoPtr, PngSPLT* entries)
		{
			int ret = GetSPLTNative(pngPtr, infoPtr, entries);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSPLTNative(PngStruct* pngPtr, PngInfo* infoPtr, PngSPLT* entries, int nentries)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngSPLT*, int, void>)funcTable[195])(pngPtr, infoPtr, entries, nentries);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[195])((nint)pngPtr, (nint)infoPtr, (nint)entries, nentries);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSPLT(PngStruct* pngPtr, PngInfo* infoPtr, PngSPLT* entries, int nentries)
		{
			SetSPLTNative(pngPtr, infoPtr, entries, nentries);
		}

		/// <summary>
		/// png_get_text also returns the number of text chunks in *num_text <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTextNative(PngStruct* pngPtr, PngInfo* infoPtr, PngText** textPtr, int* numText)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngText**, int*, int>)funcTable[196])(pngPtr, infoPtr, textPtr, numText);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[196])((nint)pngPtr, (nint)infoPtr, (nint)textPtr, (nint)numText);
			#endif
		}

		/// <summary>
		/// png_get_text also returns the number of text chunks in *num_text <br/>
		/// </summary>
		public static int GetText(PngStruct* pngPtr, PngInfo* infoPtr, PngText** textPtr, int* numText)
		{
			int ret = GetTextNative(pngPtr, infoPtr, textPtr, numText);
			return ret;
		}

		/// <summary>
		/// png_get_text also returns the number of text chunks in *num_text <br/>
		/// </summary>
		public static int GetText(PngStruct* pngPtr, PngInfo* infoPtr, ref PngText* textPtr, int* numText)
		{
			fixed (PngText** ptextPtr = &textPtr)
			{
				int ret = GetTextNative(pngPtr, infoPtr, (PngText**)ptextPtr, numText);
				return ret;
			}
		}

		/// <summary>
		/// png_get_text also returns the number of text chunks in *num_text <br/>
		/// </summary>
		public static int GetText(PngStruct* pngPtr, PngInfo* infoPtr, PngText** textPtr, ref int numText)
		{
			fixed (int* pnumText = &numText)
			{
				int ret = GetTextNative(pngPtr, infoPtr, textPtr, (int*)pnumText);
				return ret;
			}
		}

		/// <summary>
		/// png_get_text also returns the number of text chunks in *num_text <br/>
		/// </summary>
		public static int GetText(PngStruct* pngPtr, PngInfo* infoPtr, ref PngText* textPtr, ref int numText)
		{
			fixed (PngText** ptextPtr = &textPtr)
			{
				fixed (int* pnumText = &numText)
				{
					int ret = GetTextNative(pngPtr, infoPtr, (PngText**)ptextPtr, (int*)pnumText);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTextNative(PngStruct* pngPtr, PngInfo* infoPtr, PngText* textPtr, int numText)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngText*, int, void>)funcTable[197])(pngPtr, infoPtr, textPtr, numText);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[197])((nint)pngPtr, (nint)infoPtr, (nint)textPtr, numText);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetText(PngStruct* pngPtr, PngInfo* infoPtr, PngText* textPtr, int numText)
		{
			SetTextNative(pngPtr, infoPtr, textPtr, numText);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetTIMENative(PngStruct* pngPtr, PngInfo* infoPtr, PngTime** modTime)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngTime**, uint>)funcTable[198])(pngPtr, infoPtr, modTime);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[198])((nint)pngPtr, (nint)infoPtr, (nint)modTime);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTIME(PngStruct* pngPtr, PngInfo* infoPtr, PngTime** modTime)
		{
			uint ret = GetTIMENative(pngPtr, infoPtr, modTime);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTIME(PngStruct* pngPtr, PngInfo* infoPtr, ref PngTime* modTime)
		{
			fixed (PngTime** pmodTime = &modTime)
			{
				uint ret = GetTIMENative(pngPtr, infoPtr, (PngTime**)pmodTime);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTIMENative(PngStruct* pngPtr, PngInfo* infoPtr, PngTime* modTime)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngTime*, void>)funcTable[199])(pngPtr, infoPtr, modTime);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[199])((nint)pngPtr, (nint)infoPtr, (nint)modTime);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTIME(PngStruct* pngPtr, PngInfo* infoPtr, PngTime* modTime)
		{
			SetTIMENative(pngPtr, infoPtr, modTime);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetTRNSNative(PngStruct* pngPtr, PngInfo* infoPtr, byte** transAlpha, int* numTrans, PngColor16** transColor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte**, int*, PngColor16**, uint>)funcTable[200])(pngPtr, infoPtr, transAlpha, numTrans, transColor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[200])((nint)pngPtr, (nint)infoPtr, (nint)transAlpha, (nint)numTrans, (nint)transColor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, byte** transAlpha, int* numTrans, PngColor16** transColor)
		{
			uint ret = GetTRNSNative(pngPtr, infoPtr, transAlpha, numTrans, transColor);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* transAlpha, int* numTrans, PngColor16** transColor)
		{
			fixed (byte** ptransAlpha = &transAlpha)
			{
				uint ret = GetTRNSNative(pngPtr, infoPtr, (byte**)ptransAlpha, numTrans, transColor);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, byte** transAlpha, ref int numTrans, PngColor16** transColor)
		{
			fixed (int* pnumTrans = &numTrans)
			{
				uint ret = GetTRNSNative(pngPtr, infoPtr, transAlpha, (int*)pnumTrans, transColor);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* transAlpha, ref int numTrans, PngColor16** transColor)
		{
			fixed (byte** ptransAlpha = &transAlpha)
			{
				fixed (int* pnumTrans = &numTrans)
				{
					uint ret = GetTRNSNative(pngPtr, infoPtr, (byte**)ptransAlpha, (int*)pnumTrans, transColor);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, byte** transAlpha, int* numTrans, ref PngColor16* transColor)
		{
			fixed (PngColor16** ptransColor = &transColor)
			{
				uint ret = GetTRNSNative(pngPtr, infoPtr, transAlpha, numTrans, (PngColor16**)ptransColor);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* transAlpha, int* numTrans, ref PngColor16* transColor)
		{
			fixed (byte** ptransAlpha = &transAlpha)
			{
				fixed (PngColor16** ptransColor = &transColor)
				{
					uint ret = GetTRNSNative(pngPtr, infoPtr, (byte**)ptransAlpha, numTrans, (PngColor16**)ptransColor);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, byte** transAlpha, ref int numTrans, ref PngColor16* transColor)
		{
			fixed (int* pnumTrans = &numTrans)
			{
				fixed (PngColor16** ptransColor = &transColor)
				{
					uint ret = GetTRNSNative(pngPtr, infoPtr, transAlpha, (int*)pnumTrans, (PngColor16**)ptransColor);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, ref byte* transAlpha, ref int numTrans, ref PngColor16* transColor)
		{
			fixed (byte** ptransAlpha = &transAlpha)
			{
				fixed (int* pnumTrans = &numTrans)
				{
					fixed (PngColor16** ptransColor = &transColor)
					{
						uint ret = GetTRNSNative(pngPtr, infoPtr, (byte**)ptransAlpha, (int*)pnumTrans, (PngColor16**)ptransColor);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTRNSNative(PngStruct* pngPtr, PngInfo* infoPtr, byte* transAlpha, int numTrans, PngColor16* transColor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, byte*, int, PngColor16*, void>)funcTable[201])(pngPtr, infoPtr, transAlpha, numTrans, transColor);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, void>)funcTable[201])((nint)pngPtr, (nint)infoPtr, (nint)transAlpha, numTrans, (nint)transColor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, byte* transAlpha, int numTrans, PngColor16* transColor)
		{
			SetTRNSNative(pngPtr, infoPtr, transAlpha, numTrans, transColor);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, ReadOnlySpan<byte> transAlpha, int numTrans, PngColor16* transColor)
		{
			fixed (byte* ptransAlpha = transAlpha)
			{
				SetTRNSNative(pngPtr, infoPtr, (byte*)ptransAlpha, numTrans, transColor);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetTRNS(PngStruct* pngPtr, PngInfo* infoPtr, string transAlpha, int numTrans, PngColor16* transColor)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (transAlpha != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(transAlpha);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(transAlpha, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetTRNSNative(pngPtr, infoPtr, pStr0, numTrans, transColor);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSCALNative(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, double* width, double* height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int*, double*, double*, uint>)funcTable[202])(pngPtr, infoPtr, unit, width, height);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[202])((nint)pngPtr, (nint)infoPtr, (nint)unit, (nint)width, (nint)height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, double* width, double* height)
		{
			uint ret = GetSCALNative(pngPtr, infoPtr, unit, width, height);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, double* width, double* height)
		{
			fixed (int* punit = &unit)
			{
				uint ret = GetSCALNative(pngPtr, infoPtr, (int*)punit, width, height);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, ref double width, double* height)
		{
			fixed (double* pwidth = &width)
			{
				uint ret = GetSCALNative(pngPtr, infoPtr, unit, (double*)pwidth, height);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, ref double width, double* height)
		{
			fixed (int* punit = &unit)
			{
				fixed (double* pwidth = &width)
				{
					uint ret = GetSCALNative(pngPtr, infoPtr, (int*)punit, (double*)pwidth, height);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, double* width, ref double height)
		{
			fixed (double* pheight = &height)
			{
				uint ret = GetSCALNative(pngPtr, infoPtr, unit, width, (double*)pheight);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, double* width, ref double height)
		{
			fixed (int* punit = &unit)
			{
				fixed (double* pheight = &height)
				{
					uint ret = GetSCALNative(pngPtr, infoPtr, (int*)punit, width, (double*)pheight);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, ref double width, ref double height)
		{
			fixed (double* pwidth = &width)
			{
				fixed (double* pheight = &height)
				{
					uint ret = GetSCALNative(pngPtr, infoPtr, unit, (double*)pwidth, (double*)pheight);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, ref double width, ref double height)
		{
			fixed (int* punit = &unit)
			{
				fixed (double* pwidth = &width)
				{
					fixed (double* pheight = &height)
					{
						uint ret = GetSCALNative(pngPtr, infoPtr, (int*)punit, (double*)pwidth, (double*)pheight);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSCALFixedNative(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, int* width, int* height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int*, int*, int*, uint>)funcTable[203])(pngPtr, infoPtr, unit, width, height);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[203])((nint)pngPtr, (nint)infoPtr, (nint)unit, (nint)width, (nint)height);
			#endif
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, int* width, int* height)
		{
			uint ret = GetSCALFixedNative(pngPtr, infoPtr, unit, width, height);
			return ret;
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, int* width, int* height)
		{
			fixed (int* punit = &unit)
			{
				uint ret = GetSCALFixedNative(pngPtr, infoPtr, (int*)punit, width, height);
				return ret;
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, ref int width, int* height)
		{
			fixed (int* pwidth = &width)
			{
				uint ret = GetSCALFixedNative(pngPtr, infoPtr, unit, (int*)pwidth, height);
				return ret;
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, ref int width, int* height)
		{
			fixed (int* punit = &unit)
			{
				fixed (int* pwidth = &width)
				{
					uint ret = GetSCALFixedNative(pngPtr, infoPtr, (int*)punit, (int*)pwidth, height);
					return ret;
				}
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, int* width, ref int height)
		{
			fixed (int* pheight = &height)
			{
				uint ret = GetSCALFixedNative(pngPtr, infoPtr, unit, width, (int*)pheight);
				return ret;
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, int* width, ref int height)
		{
			fixed (int* punit = &unit)
			{
				fixed (int* pheight = &height)
				{
					uint ret = GetSCALFixedNative(pngPtr, infoPtr, (int*)punit, width, (int*)pheight);
					return ret;
				}
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, ref int width, ref int height)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pheight = &height)
				{
					uint ret = GetSCALFixedNative(pngPtr, infoPtr, unit, (int*)pwidth, (int*)pheight);
					return ret;
				}
			}
		}

		/// <summary>
		/// NOTE: this API is currently implemented using floating point arithmetic,<br/>
		/// consequently it can only be used on systems with floating point support.<br/>
		/// In any case the range of values supported by png_fixed_point is small and it<br/>
		/// is highly recommended that png_get_sCAL_s be used instead.<br/>
		/// </summary>
		public static uint GetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, ref int width, ref int height)
		{
			fixed (int* punit = &unit)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pheight = &height)
					{
						uint ret = GetSCALFixedNative(pngPtr, infoPtr, (int*)punit, (int*)pwidth, (int*)pheight);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSCALSNative(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, byte** swidth, byte** sheight)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int*, byte**, byte**, uint>)funcTable[204])(pngPtr, infoPtr, unit, swidth, sheight);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[204])((nint)pngPtr, (nint)infoPtr, (nint)unit, (nint)swidth, (nint)sheight);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int* unit, byte** swidth, byte** sheight)
		{
			uint ret = GetSCALSNative(pngPtr, infoPtr, unit, swidth, sheight);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, ref int unit, byte** swidth, byte** sheight)
		{
			fixed (int* punit = &unit)
			{
				uint ret = GetSCALSNative(pngPtr, infoPtr, (int*)punit, swidth, sheight);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSCALNative(PngStruct* pngPtr, PngInfo* infoPtr, int unit, double width, double height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, double, double, void>)funcTable[205])(pngPtr, infoPtr, unit, width, height);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, double, double, void>)funcTable[205])((nint)pngPtr, (nint)infoPtr, unit, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCAL(PngStruct* pngPtr, PngInfo* infoPtr, int unit, double width, double height)
		{
			SetSCALNative(pngPtr, infoPtr, unit, width, height);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSCALFixedNative(PngStruct* pngPtr, PngInfo* infoPtr, int unit, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, int, int, void>)funcTable[206])(pngPtr, infoPtr, unit, width, height);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, void>)funcTable[206])((nint)pngPtr, (nint)infoPtr, unit, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALFixed(PngStruct* pngPtr, PngInfo* infoPtr, int unit, int width, int height)
		{
			SetSCALFixedNative(pngPtr, infoPtr, unit, width, height);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetSCALSNative(PngStruct* pngPtr, PngInfo* infoPtr, int unit, byte* swidth, byte* sheight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, byte*, byte*, void>)funcTable[207])(pngPtr, infoPtr, unit, swidth, sheight);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint, void>)funcTable[207])((nint)pngPtr, (nint)infoPtr, unit, (nint)swidth, (nint)sheight);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, byte* swidth, byte* sheight)
		{
			SetSCALSNative(pngPtr, infoPtr, unit, swidth, sheight);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, ReadOnlySpan<byte> swidth, byte* sheight)
		{
			fixed (byte* pswidth = swidth)
			{
				SetSCALSNative(pngPtr, infoPtr, unit, (byte*)pswidth, sheight);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, string swidth, byte* sheight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (swidth != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(swidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(swidth, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetSCALSNative(pngPtr, infoPtr, unit, pStr0, sheight);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, byte* swidth, ReadOnlySpan<byte> sheight)
		{
			fixed (byte* psheight = sheight)
			{
				SetSCALSNative(pngPtr, infoPtr, unit, swidth, (byte*)psheight);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, byte* swidth, string sheight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sheight != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sheight);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sheight, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetSCALSNative(pngPtr, infoPtr, unit, swidth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, ReadOnlySpan<byte> swidth, ReadOnlySpan<byte> sheight)
		{
			fixed (byte* pswidth = swidth)
			{
				fixed (byte* psheight = sheight)
				{
					SetSCALSNative(pngPtr, infoPtr, unit, (byte*)pswidth, (byte*)psheight);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetSCALS(PngStruct* pngPtr, PngInfo* infoPtr, int unit, string swidth, string sheight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (swidth != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(swidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(swidth, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (sheight != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(sheight);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(sheight, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SetSCALSNative(pngPtr, infoPtr, unit, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetKeepUnknownChunksNative(PngStruct* pngPtr, int keep, byte* chunkList, int numChunks)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, byte*, int, void>)funcTable[208])(pngPtr, keep, chunkList, numChunks);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, int, void>)funcTable[208])((nint)pngPtr, keep, (nint)chunkList, numChunks);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetKeepUnknownChunks(PngStruct* pngPtr, int keep, byte* chunkList, int numChunks)
		{
			SetKeepUnknownChunksNative(pngPtr, keep, chunkList, numChunks);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetKeepUnknownChunks(PngStruct* pngPtr, int keep, ReadOnlySpan<byte> chunkList, int numChunks)
		{
			fixed (byte* pchunkList = chunkList)
			{
				SetKeepUnknownChunksNative(pngPtr, keep, (byte*)pchunkList, numChunks);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetKeepUnknownChunks(PngStruct* pngPtr, int keep, string chunkList, int numChunks)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (chunkList != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(chunkList);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(chunkList, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetKeepUnknownChunksNative(pngPtr, keep, pStr0, numChunks);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;<br/>
		/// the result is therefore true (non-zero) if special handling is required,<br/>
		/// false for the default handling.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int HandleAsUnknownNative(PngStruct* pngPtr, byte* chunkName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int>)funcTable[209])(pngPtr, chunkName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[209])((nint)pngPtr, (nint)chunkName);
			#endif
		}

		/// <summary>
		/// The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;<br/>
		/// the result is therefore true (non-zero) if special handling is required,<br/>
		/// false for the default handling.<br/>
		/// </summary>
		public static int HandleAsUnknown(PngStruct* pngPtr, byte* chunkName)
		{
			int ret = HandleAsUnknownNative(pngPtr, chunkName);
			return ret;
		}

		/// <summary>
		/// The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;<br/>
		/// the result is therefore true (non-zero) if special handling is required,<br/>
		/// false for the default handling.<br/>
		/// </summary>
		public static int HandleAsUnknown(PngStruct* pngPtr, ReadOnlySpan<byte> chunkName)
		{
			fixed (byte* pchunkName = chunkName)
			{
				int ret = HandleAsUnknownNative(pngPtr, (byte*)pchunkName);
				return ret;
			}
		}

		/// <summary>
		/// The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;<br/>
		/// the result is therefore true (non-zero) if special handling is required,<br/>
		/// false for the default handling.<br/>
		/// </summary>
		public static int HandleAsUnknown(PngStruct* pngPtr, string chunkName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (chunkName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(chunkName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(chunkName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = HandleAsUnknownNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetUnknownChunksNative(PngStruct* pngPtr, PngInfo* infoPtr, PngUnknownChunk* unknowns, int numUnknowns)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngUnknownChunk*, int, void>)funcTable[210])(pngPtr, infoPtr, unknowns, numUnknowns);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[210])((nint)pngPtr, (nint)infoPtr, (nint)unknowns, numUnknowns);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetUnknownChunks(PngStruct* pngPtr, PngInfo* infoPtr, PngUnknownChunk* unknowns, int numUnknowns)
		{
			SetUnknownChunksNative(pngPtr, infoPtr, unknowns, numUnknowns);
		}

		/// <summary>
		/// NOTE: prior to 1.6.0 this routine set the 'location' field of the added<br/>
		/// unknowns to the location currently stored in the png_struct.  This is<br/>
		/// invariably the wrong value on write.  To fix this call the following API<br/>
		/// for each chunk in the list with the correct location.  If you know your<br/>
		/// code won't be compiled on earlier versions you can rely on<br/>
		/// png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing<br/>
		/// the correct thing.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetUnknownChunkLocationNative(PngStruct* pngPtr, PngInfo* infoPtr, int chunk, int location)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, int, void>)funcTable[211])(pngPtr, infoPtr, chunk, location);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[211])((nint)pngPtr, (nint)infoPtr, chunk, location);
			#endif
		}

		/// <summary>
		/// NOTE: prior to 1.6.0 this routine set the 'location' field of the added<br/>
		/// unknowns to the location currently stored in the png_struct.  This is<br/>
		/// invariably the wrong value on write.  To fix this call the following API<br/>
		/// for each chunk in the list with the correct location.  If you know your<br/>
		/// code won't be compiled on earlier versions you can rely on<br/>
		/// png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing<br/>
		/// the correct thing.<br/>
		/// </summary>
		public static void SetUnknownChunkLocation(PngStruct* pngPtr, PngInfo* infoPtr, int chunk, int location)
		{
			SetUnknownChunkLocationNative(pngPtr, infoPtr, chunk, location);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUnknownChunksNative(PngStruct* pngPtr, PngInfo* infoPtr, PngUnknownChunk** entries)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngUnknownChunk**, int>)funcTable[212])(pngPtr, infoPtr, entries);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[212])((nint)pngPtr, (nint)infoPtr, (nint)entries);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetUnknownChunks(PngStruct* pngPtr, PngInfo* infoPtr, PngUnknownChunk** entries)
		{
			int ret = GetUnknownChunksNative(pngPtr, infoPtr, entries);
			return ret;
		}

		/// <summary>
		/// Png_free_data() will turn off the "valid" flag for anything it frees.<br/>
		/// If you need to turn it off for a chunk that your application has freed,<br/>
		/// you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInvalidNative(PngStruct* pngPtr, PngInfo* infoPtr, int mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, void>)funcTable[213])(pngPtr, infoPtr, mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[213])((nint)pngPtr, (nint)infoPtr, mask);
			#endif
		}

		/// <summary>
		/// Png_free_data() will turn off the "valid" flag for anything it frees.<br/>
		/// If you need to turn it off for a chunk that your application has freed,<br/>
		/// you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);<br/>
		/// </summary>
		public static void SetInvalid(PngStruct* pngPtr, PngInfo* infoPtr, int mask)
		{
			SetInvalidNative(pngPtr, infoPtr, mask);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadPngNative(PngStruct* pngPtr, PngInfo* infoPtr, int transforms, void* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, void*, void>)funcTable[214])(pngPtr, infoPtr, transforms, @params);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, nint, void>)funcTable[214])((nint)pngPtr, (nint)infoPtr, transforms, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReadPng(PngStruct* pngPtr, PngInfo* infoPtr, int transforms, void* @params)
		{
			ReadPngNative(pngPtr, infoPtr, transforms, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WritePngNative(PngStruct* pngPtr, PngInfo* infoPtr, int transforms, void* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int, void*, void>)funcTable[215])(pngPtr, infoPtr, transforms, @params);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, nint, void>)funcTable[215])((nint)pngPtr, (nint)infoPtr, transforms, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePng(PngStruct* pngPtr, PngInfo* infoPtr, int transforms, void* @params)
		{
			WritePngNative(pngPtr, infoPtr, transforms, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCopyrightNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*>)funcTable[216])(pngPtr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[216])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetCopyright(PngStruct* pngPtr)
		{
			byte* ret = GetCopyrightNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetCopyrightS(PngStruct* pngPtr)
		{
			string ret = Utils.DecodeStringUTF8(GetCopyrightNative(pngPtr));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHeaderVerNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*>)funcTable[217])(pngPtr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[217])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetHeaderVer(PngStruct* pngPtr)
		{
			byte* ret = GetHeaderVerNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetHeaderVerS(PngStruct* pngPtr)
		{
			string ret = Utils.DecodeStringUTF8(GetHeaderVerNative(pngPtr));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetHeaderVersionNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*>)funcTable[218])(pngPtr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[218])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetHeaderVersion(PngStruct* pngPtr)
		{
			byte* ret = GetHeaderVersionNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetHeaderVersionS(PngStruct* pngPtr)
		{
			string ret = Utils.DecodeStringUTF8(GetHeaderVersionNative(pngPtr));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetLibpngVerNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*>)funcTable[219])(pngPtr);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[219])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetLibpngVer(PngStruct* pngPtr)
		{
			byte* ret = GetLibpngVerNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetLibpngVerS(PngStruct* pngPtr)
		{
			string ret = Utils.DecodeStringUTF8(GetLibpngVerNative(pngPtr));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint PermitMngFeaturesNative(PngStruct* pngPtr, uint mngFeaturesPermitted)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint>)funcTable[220])(pngPtr, mngFeaturesPermitted);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint, uint>)funcTable[220])((nint)pngPtr, mngFeaturesPermitted);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint PermitMngFeatures(PngStruct* pngPtr, uint mngFeaturesPermitted)
		{
			uint ret = PermitMngFeaturesNative(pngPtr, mngFeaturesPermitted);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetUserLimitsNative(PngStruct* pngPtr, uint userWidthMax, uint userHeightMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint, void>)funcTable[221])(pngPtr, userWidthMax, userHeightMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, void>)funcTable[221])((nint)pngPtr, userWidthMax, userHeightMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetUserLimits(PngStruct* pngPtr, uint userWidthMax, uint userHeightMax)
		{
			SetUserLimitsNative(pngPtr, userWidthMax, userHeightMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUserWidthMaxNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[222])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[222])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUserWidthMax(PngStruct* pngPtr)
		{
			uint ret = GetUserWidthMaxNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUserHeightMaxNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[223])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[223])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUserHeightMax(PngStruct* pngPtr)
		{
			uint ret = GetUserHeightMaxNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Added in libpng-1.4.0 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetChunkCacheMaxNative(PngStruct* pngPtr, uint userChunkCacheMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, void>)funcTable[224])(pngPtr, userChunkCacheMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[224])((nint)pngPtr, userChunkCacheMax);
			#endif
		}

		/// <summary>
		/// Added in libpng-1.4.0 <br/>
		/// </summary>
		public static void SetChunkCacheMax(PngStruct* pngPtr, uint userChunkCacheMax)
		{
			SetChunkCacheMaxNative(pngPtr, userChunkCacheMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetChunkCacheMaxNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[225])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[225])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetChunkCacheMax(PngStruct* pngPtr)
		{
			uint ret = GetChunkCacheMaxNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Added in libpng-1.4.1 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetChunkMallocMaxNative(PngStruct* pngPtr, nint userChunkCacheMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, nint, void>)funcTable[226])(pngPtr, userChunkCacheMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[226])((nint)pngPtr, userChunkCacheMax);
			#endif
		}

		/// <summary>
		/// Added in libpng-1.4.1 <br/>
		/// </summary>
		public static void SetChunkMallocMax(PngStruct* pngPtr, nint userChunkCacheMax)
		{
			SetChunkMallocMaxNative(pngPtr, userChunkCacheMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nint GetChunkMallocMaxNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint>)funcTable[227])(pngPtr);
			#else
			return (nint)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[227])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nint GetChunkMallocMax(PngStruct* pngPtr)
		{
			nint ret = GetChunkMallocMaxNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetPixelsPerInchNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[228])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[228])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPixelsPerInch(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetPixelsPerInchNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetXPixelsPerInchNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[229])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[229])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetXPixelsPerInch(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetXPixelsPerInchNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetYPixelsPerInchNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint>)funcTable[230])(pngPtr, infoPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[230])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetYPixelsPerInch(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			uint ret = GetYPixelsPerInchNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetXOffsetInchesNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, float>)funcTable[231])(pngPtr, infoPtr);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, nint, float>)funcTable[231])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetXOffsetInches(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			float ret = GetXOffsetInchesNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetXOffsetInchesFixedNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[232])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[232])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetXOffsetInchesFixed(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetXOffsetInchesFixedNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetYOffsetInchesNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, float>)funcTable[233])(pngPtr, infoPtr);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, nint, float>)funcTable[233])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetYOffsetInches(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			float ret = GetYOffsetInchesNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetYOffsetInchesFixedNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[234])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[234])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetYOffsetInchesFixed(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetYOffsetInchesFixedNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetPHYsDpiNative(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, int* unitType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint*, uint*, int*, uint>)funcTable[235])(pngPtr, infoPtr, resX, resY, unitType);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, uint>)funcTable[235])((nint)pngPtr, (nint)infoPtr, (nint)resX, (nint)resY, (nint)unitType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, int* unitType)
		{
			uint ret = GetPHYsDpiNative(pngPtr, infoPtr, resX, resY, unitType);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, uint* resY, int* unitType)
		{
			fixed (uint* presX = &resX)
			{
				uint ret = GetPHYsDpiNative(pngPtr, infoPtr, (uint*)presX, resY, unitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, ref uint resY, int* unitType)
		{
			fixed (uint* presY = &resY)
			{
				uint ret = GetPHYsDpiNative(pngPtr, infoPtr, resX, (uint*)presY, unitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, ref uint resY, int* unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (uint* presY = &resY)
				{
					uint ret = GetPHYsDpiNative(pngPtr, infoPtr, (uint*)presX, (uint*)presY, unitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, uint* resY, ref int unitType)
		{
			fixed (int* punitType = &unitType)
			{
				uint ret = GetPHYsDpiNative(pngPtr, infoPtr, resX, resY, (int*)punitType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, uint* resY, ref int unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (int* punitType = &unitType)
				{
					uint ret = GetPHYsDpiNative(pngPtr, infoPtr, (uint*)presX, resY, (int*)punitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, uint* resX, ref uint resY, ref int unitType)
		{
			fixed (uint* presY = &resY)
			{
				fixed (int* punitType = &unitType)
				{
					uint ret = GetPHYsDpiNative(pngPtr, infoPtr, resX, (uint*)presY, (int*)punitType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetPHYsDpi(PngStruct* pngPtr, PngInfo* infoPtr, ref uint resX, ref uint resY, ref int unitType)
		{
			fixed (uint* presX = &resX)
			{
				fixed (uint* presY = &resY)
				{
					fixed (int* punitType = &unitType)
					{
						uint ret = GetPHYsDpiNative(pngPtr, infoPtr, (uint*)presX, (uint*)presY, (int*)punitType);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIoStateNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[236])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[236])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIoState(PngStruct* pngPtr)
		{
			uint ret = GetIoStateNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Removed from libpng 1.6; use png_get_io_chunk_type. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIoChunkTypeNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[237])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[237])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Removed from libpng 1.6; use png_get_io_chunk_type. <br/>
		/// </summary>
		public static uint GetIoChunkType(PngStruct* pngPtr)
		{
			uint ret = GetIoChunkTypeNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUint32Native(byte* buf)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint>)funcTable[238])(buf);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[238])((nint)buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint32(byte* buf)
		{
			uint ret = GetUint32Native(buf);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint32(ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf = buf)
			{
				uint ret = GetUint32Native((byte*)pbuf);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint32(string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUint32Native(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetUint16Native(byte* buf)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ushort>)funcTable[239])(buf);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, ushort>)funcTable[239])((nint)buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort GetUint16(byte* buf)
		{
			ushort ret = GetUint16Native(buf);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort GetUint16(ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf = buf)
			{
				ushort ret = GetUint16Native((byte*)pbuf);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort GetUint16(string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ushort ret = GetUint16Native(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetInt32Native(byte* buf)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[240])(buf);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[240])((nint)buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInt32(byte* buf)
		{
			int ret = GetInt32Native(buf);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInt32(ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf = buf)
			{
				int ret = GetInt32Native((byte*)pbuf);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetInt32(string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetInt32Native(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUint31Native(PngStruct* pngPtr, byte* buf)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint>)funcTable[241])(pngPtr, buf);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[241])((nint)pngPtr, (nint)buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint31(PngStruct* pngPtr, byte* buf)
		{
			uint ret = GetUint31Native(pngPtr, buf);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint31(PngStruct* pngPtr, ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf = buf)
			{
				uint ret = GetUint31Native(pngPtr, (byte*)pbuf);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetUint31(PngStruct* pngPtr, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUint31Native(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SaveUint32Native(byte* buf, uint i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, uint, void>)funcTable[242])(buf, i);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[242])((nint)buf, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint32(byte* buf, uint i)
		{
			SaveUint32Native(buf, i);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint32(ReadOnlySpan<byte> buf, uint i)
		{
			fixed (byte* pbuf = buf)
			{
				SaveUint32Native((byte*)pbuf, i);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint32(string buf, uint i)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveUint32Native(pStr0, i);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SaveInt32Native(byte* buf, int i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, void>)funcTable[243])(buf, i);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[243])((nint)buf, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveInt32(byte* buf, int i)
		{
			SaveInt32Native(buf, i);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveInt32(ReadOnlySpan<byte> buf, int i)
		{
			fixed (byte* pbuf = buf)
			{
				SaveInt32Native((byte*)pbuf, i);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveInt32(string buf, int i)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveInt32Native(pStr0, i);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SaveUint16Native(byte* buf, uint i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, uint, void>)funcTable[244])(buf, i);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[244])((nint)buf, i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint16(byte* buf, uint i)
		{
			SaveUint16Native(buf, i);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint16(ReadOnlySpan<byte> buf, uint i)
		{
			fixed (byte* pbuf = buf)
			{
				SaveUint16Native((byte*)pbuf, i);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SaveUint16(string buf, uint i)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveUint16Native(pStr0, i);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCheckForInvalidIndexNative(PngStruct* pngPtr, int allowed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[245])(pngPtr, allowed);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[245])((nint)pngPtr, allowed);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCheckForInvalidIndex(PngStruct* pngPtr, int allowed)
		{
			SetCheckForInvalidIndexNative(pngPtr, allowed);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetPaletteMaxNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, int>)funcTable[246])(pngPtr, infoPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[246])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetPaletteMax(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			int ret = GetPaletteMaxNative(pngPtr, infoPtr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageBeginReadFromFileNative(PngImage* image, byte* fileName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, byte*, int>)funcTable[247])(image, fileName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[247])((nint)image, (nint)fileName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageBeginReadFromFile(PngImage* image, byte* fileName)
		{
			int ret = ImageBeginReadFromFileNative(image, fileName);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageBeginReadFromFile(PngImage* image, ref byte fileName)
		{
			fixed (byte* pfileName = &fileName)
			{
				int ret = ImageBeginReadFromFileNative(image, (byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageBeginReadFromFile(PngImage* image, ReadOnlySpan<byte> fileName)
		{
			fixed (byte* pfileName = fileName)
			{
				int ret = ImageBeginReadFromFileNative(image, (byte*)pfileName);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageBeginReadFromFile(PngImage* image, string fileName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fileName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fileName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fileName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImageBeginReadFromFileNative(image, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// The named file is opened for read and the image header is filled in<br/>
		/// from the PNG header in the file.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageBeginReadFromStdioNative(PngImage* image, FILE* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, FILE*, int>)funcTable[248])(image, file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[248])((nint)image, (nint)file);
			#endif
		}

		/// <summary>
		/// The named file is opened for read and the image header is filled in<br/>
		/// from the PNG header in the file.<br/>
		/// </summary>
		public static int ImageBeginReadFromStdio(PngImage* image, FILE* file)
		{
			int ret = ImageBeginReadFromStdioNative(image, file);
			return ret;
		}

		/// <summary>
		/// The named file is opened for read and the image header is filled in<br/>
		/// from the PNG header in the file.<br/>
		/// </summary>
		public static int ImageBeginReadFromStdio(PngImage* image, ref FILE file)
		{
			fixed (FILE* pfile = &file)
			{
				int ret = ImageBeginReadFromStdioNative(image, (FILE*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageBeginReadFromMemoryNative(PngImage* image, void* memory, nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, void*, nuint, int>)funcTable[249])(image, memory, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nuint, int>)funcTable[249])((nint)image, (nint)memory, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageBeginReadFromMemory(PngImage* image, void* memory, nuint size)
		{
			int ret = ImageBeginReadFromMemoryNative(image, memory, size);
			return ret;
		}

		/// <summary>
		/// The PNG header is read from the given memory buffer. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageFinishReadNative(PngImage* image, PngColor* background, void* buffer, int rowStride, void* colormap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, PngColor*, void*, int, void*, int>)funcTable[250])(image, background, buffer, rowStride, colormap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int>)funcTable[250])((nint)image, (nint)background, (nint)buffer, rowStride, (nint)colormap);
			#endif
		}

		/// <summary>
		/// The PNG header is read from the given memory buffer. <br/>
		/// </summary>
		public static int ImageFinishRead(PngImage* image, PngColor* background, void* buffer, int rowStride, void* colormap)
		{
			int ret = ImageFinishReadNative(image, background, buffer, rowStride, colormap);
			return ret;
		}

		/// <summary>
		/// Finish reading the image into the supplied buffer and clean up the<br/>
		/// png_image structure.<br/>
		/// row_stride is the step, in byte or 2-byte units as appropriate,<br/>
		/// between adjacent rows.  A positive stride indicates that the top-most row<br/>
		/// is first in the buffer - the normal top-down arrangement.  A negative<br/>
		/// stride indicates that the bottom-most row is first in the buffer.<br/>
		/// background need only be supplied if an alpha channel must be removed from<br/>
		/// a png_byte format and the removal is to be done by compositing on a solid<br/>
		/// color; otherwise it may be NULL and any composition will be done directly<br/>
		/// onto the buffer.  The value is an sRGB color to use for the background,<br/>
		/// for grayscale output the green channel is used.<br/>
		/// background must be supplied when an alpha channel must be removed from a<br/>
		/// single byte color-mapped output format, in other words if:<br/>
		/// 1) The original format from png_image_begin_read_from_* had<br/>
		/// PNG_FORMAT_FLAG_ALPHA set.<br/>
		/// 2) The format set by the application does not.<br/>
		/// 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and<br/>
		/// PNG_FORMAT_FLAG_LINEAR *not* set.<br/>
		/// For linear output removing the alpha channel is always done by compositing<br/>
		/// on black and background is ignored.<br/>
		/// colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must<br/>
		/// be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.<br/>
		/// image->colormap_entries will be updated to the actual number of entries<br/>
		/// written to the colormap; this may be less than the original value.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImageFreeNative(PngImage* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngImage*, void>)funcTable[251])(image);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[251])((nint)image);
			#endif
		}

		/// <summary>
		/// Finish reading the image into the supplied buffer and clean up the<br/>
		/// png_image structure.<br/>
		/// row_stride is the step, in byte or 2-byte units as appropriate,<br/>
		/// between adjacent rows.  A positive stride indicates that the top-most row<br/>
		/// is first in the buffer - the normal top-down arrangement.  A negative<br/>
		/// stride indicates that the bottom-most row is first in the buffer.<br/>
		/// background need only be supplied if an alpha channel must be removed from<br/>
		/// a png_byte format and the removal is to be done by compositing on a solid<br/>
		/// color; otherwise it may be NULL and any composition will be done directly<br/>
		/// onto the buffer.  The value is an sRGB color to use for the background,<br/>
		/// for grayscale output the green channel is used.<br/>
		/// background must be supplied when an alpha channel must be removed from a<br/>
		/// single byte color-mapped output format, in other words if:<br/>
		/// 1) The original format from png_image_begin_read_from_* had<br/>
		/// PNG_FORMAT_FLAG_ALPHA set.<br/>
		/// 2) The format set by the application does not.<br/>
		/// 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and<br/>
		/// PNG_FORMAT_FLAG_LINEAR *not* set.<br/>
		/// For linear output removing the alpha channel is always done by compositing<br/>
		/// on black and background is ignored.<br/>
		/// colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must<br/>
		/// be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.<br/>
		/// image->colormap_entries will be updated to the actual number of entries<br/>
		/// written to the colormap; this may be less than the original value.<br/>
		/// </summary>
		public static void ImageFree(PngImage* image)
		{
			ImageFreeNative(image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageWriteToFileNative(PngImage* image, byte* file, int convertTo8bit, void* buffer, int rowStride, void* colormap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, byte*, int, void*, int, void*, int>)funcTable[252])(image, file, convertTo8bit, buffer, rowStride, colormap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, int, nint, int>)funcTable[252])((nint)image, (nint)file, convertTo8bit, (nint)buffer, rowStride, (nint)colormap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageWriteToFile(PngImage* image, byte* file, int convertTo8bit, void* buffer, int rowStride, void* colormap)
		{
			int ret = ImageWriteToFileNative(image, file, convertTo8bit, buffer, rowStride, colormap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageWriteToFile(PngImage* image, ref byte file, int convertTo8bit, void* buffer, int rowStride, void* colormap)
		{
			fixed (byte* pfile = &file)
			{
				int ret = ImageWriteToFileNative(image, (byte*)pfile, convertTo8bit, buffer, rowStride, colormap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageWriteToFile(PngImage* image, ReadOnlySpan<byte> file, int convertTo8bit, void* buffer, int rowStride, void* colormap)
		{
			fixed (byte* pfile = file)
			{
				int ret = ImageWriteToFileNative(image, (byte*)pfile, convertTo8bit, buffer, rowStride, colormap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImageWriteToFile(PngImage* image, string file, int convertTo8bit, void* buffer, int rowStride, void* colormap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImageWriteToFileNative(image, pStr0, convertTo8bit, buffer, rowStride, colormap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Write the image to the named file. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageWriteToStdioNative(PngImage* image, FILE* file, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, FILE*, int, void*, int, void*, int>)funcTable[253])(image, file, convertTo8Bit, buffer, rowStride, colormap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, int, nint, int>)funcTable[253])((nint)image, (nint)file, convertTo8Bit, (nint)buffer, rowStride, (nint)colormap);
			#endif
		}

		/// <summary>
		/// Write the image to the named file. <br/>
		/// </summary>
		public static int ImageWriteToStdio(PngImage* image, FILE* file, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			int ret = ImageWriteToStdioNative(image, file, convertTo8Bit, buffer, rowStride, colormap);
			return ret;
		}

		/// <summary>
		/// Write the image to the named file. <br/>
		/// </summary>
		public static int ImageWriteToStdio(PngImage* image, ref FILE file, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			fixed (FILE* pfile = &file)
			{
				int ret = ImageWriteToStdioNative(image, (FILE*)pfile, convertTo8Bit, buffer, rowStride, colormap);
				return ret;
			}
		}

		/// <summary>
		/// With all write APIs if image is in one of the linear formats with 16-bit<br/>
		/// data then setting convert_to_8_bit will cause the output to be an 8-bit PNG<br/>
		/// gamma encoded according to the sRGB specification, otherwise a 16-bit linear<br/>
		/// encoded PNG file is written.<br/>
		/// With color-mapped data formats the colormap parameter point to a color-map<br/>
		/// with at least image->colormap_entries encoded in the specified format.  If<br/>
		/// the format is linear the written PNG color-map will be converted to sRGB<br/>
		/// regardless of the convert_to_8_bit flag.<br/>
		/// With all APIs row_stride is handled as in the read APIs - it is the spacing<br/>
		/// from one row to the next in component sized units (1 or 2 bytes) and if<br/>
		/// negative indicates a bottom-up row layout in the buffer.  If row_stride is<br/>
		/// zero, libpng will calculate it for you from the image width and number of<br/>
		/// channels.<br/>
		/// Note that the write API does not support interlacing, sub-8-bit pixels or<br/>
		/// most ancillary chunks.  If you need to write text chunks (e.g. for copyright<br/>
		/// notices) you need to use one of the other APIs.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageWriteToMemoryNative(PngImage* image, void* memory, nint* memoryBytes, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, void*, nint*, int, void*, int, void*, int>)funcTable[254])(image, memory, memoryBytes, convertTo8Bit, buffer, rowStride, colormap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint, int, nint, int>)funcTable[254])((nint)image, (nint)memory, (nint)memoryBytes, convertTo8Bit, (nint)buffer, rowStride, (nint)colormap);
			#endif
		}

		/// <summary>
		/// With all write APIs if image is in one of the linear formats with 16-bit<br/>
		/// data then setting convert_to_8_bit will cause the output to be an 8-bit PNG<br/>
		/// gamma encoded according to the sRGB specification, otherwise a 16-bit linear<br/>
		/// encoded PNG file is written.<br/>
		/// With color-mapped data formats the colormap parameter point to a color-map<br/>
		/// with at least image->colormap_entries encoded in the specified format.  If<br/>
		/// the format is linear the written PNG color-map will be converted to sRGB<br/>
		/// regardless of the convert_to_8_bit flag.<br/>
		/// With all APIs row_stride is handled as in the read APIs - it is the spacing<br/>
		/// from one row to the next in component sized units (1 or 2 bytes) and if<br/>
		/// negative indicates a bottom-up row layout in the buffer.  If row_stride is<br/>
		/// zero, libpng will calculate it for you from the image width and number of<br/>
		/// channels.<br/>
		/// Note that the write API does not support interlacing, sub-8-bit pixels or<br/>
		/// most ancillary chunks.  If you need to write text chunks (e.g. for copyright<br/>
		/// notices) you need to use one of the other APIs.<br/>
		/// </summary>
		public static int ImageWriteToMemory(PngImage* image, void* memory, nint* memoryBytes, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			int ret = ImageWriteToMemoryNative(image, memory, memoryBytes, convertTo8Bit, buffer, rowStride, colormap);
			return ret;
		}

		/// <summary>
		/// With all write APIs if image is in one of the linear formats with 16-bit<br/>
		/// data then setting convert_to_8_bit will cause the output to be an 8-bit PNG<br/>
		/// gamma encoded according to the sRGB specification, otherwise a 16-bit linear<br/>
		/// encoded PNG file is written.<br/>
		/// With color-mapped data formats the colormap parameter point to a color-map<br/>
		/// with at least image->colormap_entries encoded in the specified format.  If<br/>
		/// the format is linear the written PNG color-map will be converted to sRGB<br/>
		/// regardless of the convert_to_8_bit flag.<br/>
		/// With all APIs row_stride is handled as in the read APIs - it is the spacing<br/>
		/// from one row to the next in component sized units (1 or 2 bytes) and if<br/>
		/// negative indicates a bottom-up row layout in the buffer.  If row_stride is<br/>
		/// zero, libpng will calculate it for you from the image width and number of<br/>
		/// channels.<br/>
		/// Note that the write API does not support interlacing, sub-8-bit pixels or<br/>
		/// most ancillary chunks.  If you need to write text chunks (e.g. for copyright<br/>
		/// notices) you need to use one of the other APIs.<br/>
		/// </summary>
		public static int ImageWriteToMemory(PngImage* image, void* memory, ref nint memoryBytes, int convertTo8Bit, void* buffer, int rowStride, void* colormap)
		{
			fixed (nint* pmemoryBytes = &memoryBytes)
			{
				int ret = ImageWriteToMemoryNative(image, memory, (nint*)pmemoryBytes, convertTo8Bit, buffer, rowStride, colormap);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetOptionNative(PngStruct* pngPtr, int option, int onoff)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int, int, int>)funcTable[255])(pngPtr, option, onoff);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)funcTable[255])((nint)pngPtr, option, onoff);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SetOption(PngStruct* pngPtr, int option, int onoff)
		{
			int ret = SetOptionNative(pngPtr, option, onoff);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ZstreamErrorNative(PngStruct* pngPtr, int ret)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[256])(pngPtr, ret);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[256])((nint)pngPtr, ret);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ZstreamError(PngStruct* pngPtr, int ret)
		{
			ZstreamErrorNative(pngPtr, ret);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeBufferListNative(PngStruct* pngPtr, PngCompressionBuffer** list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngCompressionBuffer**, void>)funcTable[257])(pngPtr, list);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[257])((nint)pngPtr, (nint)list);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FreeBufferList(PngStruct* pngPtr, PngCompressionBuffer** list)
		{
			FreeBufferListNative(pngPtr, list);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FreeBufferList(PngStruct* pngPtr, ref PngCompressionBuffer* list)
		{
			fixed (PngCompressionBuffer** plist = &list)
			{
				FreeBufferListNative(pngPtr, (PngCompressionBuffer**)plist);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FixedNative(PngStruct* pngPtr, double fp, byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, double, byte*, int>)funcTable[258])(pngPtr, fp, text);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, double, nint, int>)funcTable[258])((nint)pngPtr, fp, (nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Fixed(PngStruct* pngPtr, double fp, byte* text)
		{
			int ret = FixedNative(pngPtr, fp, text);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Fixed(PngStruct* pngPtr, double fp, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				int ret = FixedNative(pngPtr, fp, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Fixed(PngStruct* pngPtr, double fp, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FixedNative(pngPtr, fp, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint FixedITUNative(PngStruct* pngPtr, double fp, byte* text)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, double, byte*, uint>)funcTable[259])(pngPtr, fp, text);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, double, nint, uint>)funcTable[259])((nint)pngPtr, fp, (nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint FixedITU(PngStruct* pngPtr, double fp, byte* text)
		{
			uint ret = FixedITUNative(pngPtr, fp, text);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint FixedITU(PngStruct* pngPtr, double fp, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				uint ret = FixedITUNative(pngPtr, fp, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint FixedITU(PngStruct* pngPtr, double fp, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = FixedITUNative(pngPtr, fp, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Check the user version string for compatibility, returns false if the version<br/>
		/// numbers aren't compatible.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UserVersionCheckNative(PngStruct* pngPtr, byte* userPngVer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int>)funcTable[260])(pngPtr, userPngVer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[260])((nint)pngPtr, (nint)userPngVer);
			#endif
		}

		/// <summary>
		/// Check the user version string for compatibility, returns false if the version<br/>
		/// numbers aren't compatible.<br/>
		/// </summary>
		public static int UserVersionCheck(PngStruct* pngPtr, byte* userPngVer)
		{
			int ret = UserVersionCheckNative(pngPtr, userPngVer);
			return ret;
		}

		/// <summary>
		/// Check the user version string for compatibility, returns false if the version<br/>
		/// numbers aren't compatible.<br/>
		/// </summary>
		public static int UserVersionCheck(PngStruct* pngPtr, ReadOnlySpan<byte> userPngVer)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				int ret = UserVersionCheckNative(pngPtr, (byte*)puserPngVer);
				return ret;
			}
		}

		/// <summary>
		/// Check the user version string for compatibility, returns false if the version<br/>
		/// numbers aren't compatible.<br/>
		/// </summary>
		public static int UserVersionCheck(PngStruct* pngPtr, string userPngVer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = UserVersionCheckNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Internal base allocator - no messages, NULL on failure to allocate.  This<br/>
		/// does, however, call the application provided allocator and that could call<br/>
		/// png_error (although that would be a bug in the application implementation.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocBaseNative(PngStruct* pngPtr, nint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, nint, void*>)funcTable[261])(pngPtr, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[261])((nint)pngPtr, size);
			#endif
		}

		/// <summary>
		/// Internal base allocator - no messages, NULL on failure to allocate.  This<br/>
		/// does, however, call the application provided allocator and that could call<br/>
		/// png_error (although that would be a bug in the application implementation.)<br/>
		/// </summary>
		public static void* MallocBase(PngStruct* pngPtr, nint size)
		{
			void* ret = MallocBaseNative(pngPtr, size);
			return ret;
		}

		/// <summary>
		/// Internal array allocator, outputs no error or warning messages on failure,<br/>
		/// just returns NULL.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MallocArrayNative(PngStruct* pngPtr, int nelements, nuint elementSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int, nuint, void*>)funcTable[262])(pngPtr, nelements, elementSize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, int, nuint, nint>)funcTable[262])((nint)pngPtr, nelements, elementSize);
			#endif
		}

		/// <summary>
		/// Internal array allocator, outputs no error or warning messages on failure,<br/>
		/// just returns NULL.<br/>
		/// </summary>
		public static void* MallocArray(PngStruct* pngPtr, int nelements, nuint elementSize)
		{
			void* ret = MallocArrayNative(pngPtr, nelements, elementSize);
			return ret;
		}

		/// <summary>
		/// The same but an existing array is extended by add_elements.  This function<br/>
		/// also memsets the new elements to 0 and copies the old elements.  The old<br/>
		/// array is not freed or altered.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ReallocArrayNative(PngStruct* pngPtr, void* array, int oldElements, int addElements, nuint elementSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, void*, int, int, nuint, void*>)funcTable[263])(pngPtr, array, oldElements, addElements, elementSize);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, int, int, nuint, nint>)funcTable[263])((nint)pngPtr, (nint)array, oldElements, addElements, elementSize);
			#endif
		}

		/// <summary>
		/// The same but an existing array is extended by add_elements.  This function<br/>
		/// also memsets the new elements to 0 and copies the old elements.  The old<br/>
		/// array is not freed or altered.<br/>
		/// </summary>
		public static void* ReallocArray(PngStruct* pngPtr, void* array, int oldElements, int addElements, nuint elementSize)
		{
			void* ret = ReallocArrayNative(pngPtr, array, oldElements, addElements, elementSize);
			return ret;
		}

		/// <summary>
		/// Magic to create a struct when there is no struct to call the user supplied<br/>
		/// memory allocators.  Because error handling has not been set up the memory<br/>
		/// handlers can't safely call png_error, but this is an obscure and undocumented<br/>
		/// restriction so libpng has to assume that the 'free' handler, at least, might<br/>
		/// call png_error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngStruct* CreatePngStructNative(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, void*, delegate*<PngStruct*, byte*, void>, delegate*<PngStruct*, byte*, void>, void*, delegate*<PngStruct*, nint, void*>, delegate*<PngStruct*, void*, void>, PngStruct*>)funcTable[264])(userPngVer, errorPtr, (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(errorFn), (delegate*<PngStruct*, byte*, void>)Utils.GetFunctionPointerForDelegate(warnFn), memPtr, (delegate*<PngStruct*, nint, void*>)Utils.GetFunctionPointerForDelegate(mallocFn), (delegate*<PngStruct*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFn));
			#else
			return (PngStruct*)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, nint, nint, nint>)funcTable[264])((nint)userPngVer, (nint)errorPtr, (nint)Utils.GetFunctionPointerForDelegate(errorFn), (nint)Utils.GetFunctionPointerForDelegate(warnFn), (nint)memPtr, (nint)Utils.GetFunctionPointerForDelegate(mallocFn), (nint)Utils.GetFunctionPointerForDelegate(freeFn));
			#endif
		}

		/// <summary>
		/// Magic to create a struct when there is no struct to call the user supplied<br/>
		/// memory allocators.  Because error handling has not been set up the memory<br/>
		/// handlers can't safely call png_error, but this is an obscure and undocumented<br/>
		/// restriction so libpng has to assume that the 'free' handler, at least, might<br/>
		/// call png_error.<br/>
		/// </summary>
		public static PngStruct* CreatePngStruct(byte* userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			PngStruct* ret = CreatePngStructNative(userPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			return ret;
		}

		/// <summary>
		/// Magic to create a struct when there is no struct to call the user supplied<br/>
		/// memory allocators.  Because error handling has not been set up the memory<br/>
		/// handlers can't safely call png_error, but this is an obscure and undocumented<br/>
		/// restriction so libpng has to assume that the 'free' handler, at least, might<br/>
		/// call png_error.<br/>
		/// </summary>
		public static PngStruct* CreatePngStruct(ReadOnlySpan<byte> userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			fixed (byte* puserPngVer = userPngVer)
			{
				PngStruct* ret = CreatePngStructNative((byte*)puserPngVer, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
				return ret;
			}
		}

		/// <summary>
		/// Magic to create a struct when there is no struct to call the user supplied<br/>
		/// memory allocators.  Because error handling has not been set up the memory<br/>
		/// handlers can't safely call png_error, but this is an obscure and undocumented<br/>
		/// restriction so libpng has to assume that the 'free' handler, at least, might<br/>
		/// call png_error.<br/>
		/// </summary>
		public static PngStruct* CreatePngStruct(string userPngVer, void* errorPtr, PngErrorPtr errorFn, PngErrorPtr warnFn, void* memPtr, PngMallocPtr mallocFn, PngFreePtr freeFn)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (userPngVer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(userPngVer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(userPngVer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PngStruct* ret = CreatePngStructNative(pStr0, errorPtr, errorFn, warnFn, memPtr, mallocFn, freeFn);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Free memory from internal libpng struct <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPngStructNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[265])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[265])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Free memory from internal libpng struct <br/>
		/// </summary>
		public static void DestroyPngStruct(PngStruct* pngPtr)
		{
			DestroyPngStructNative(pngPtr);
		}

		/// <summary>
		/// Free an allocated jmp_buf (always succeeds) <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeJmpbufNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[266])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[266])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Free an allocated jmp_buf (always succeeds) <br/>
		/// </summary>
		public static void FreeJmpbuf(PngStruct* pngPtr)
		{
			FreeJmpbufNative(pngPtr);
		}

		/// <summary>
		/// Function to allocate memory for zlib.  PNGAPI is disallowed. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ZallocNative(void* pngPtr, uint items, uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, uint, uint, void*>)funcTable[267])(pngPtr, items, size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, uint, uint, nint>)funcTable[267])((nint)pngPtr, items, size);
			#endif
		}

		/// <summary>
		/// Function to allocate memory for zlib.  PNGAPI is disallowed. <br/>
		/// </summary>
		public static void* Zalloc(void* pngPtr, uint items, uint size)
		{
			void* ret = ZallocNative(pngPtr, items, size);
			return ret;
		}

		/// <summary>
		/// Function to free memory for zlib.  PNGAPI is disallowed. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ZfreeNative(void* pngPtr, void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[268])(pngPtr, ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[268])((nint)pngPtr, (nint)ptr);
			#endif
		}

		/// <summary>
		/// Function to free memory for zlib.  PNGAPI is disallowed. <br/>
		/// </summary>
		public static void Zfree(void* pngPtr, void* ptr)
		{
			ZfreeNative(pngPtr, ptr);
		}

		/// <summary>
		/// Next four functions are used internally as callbacks.  PNGCBAPI is required<br/>
		/// but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to<br/>
		/// PNGCBAPI at 1.5.0<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DefaultReadDataNative(PngStruct* pngPtr, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[269])(pngPtr, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[269])((nint)pngPtr, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Next four functions are used internally as callbacks.  PNGCBAPI is required<br/>
		/// but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to<br/>
		/// PNGCBAPI at 1.5.0<br/>
		/// </summary>
		public static void DefaultReadData(PngStruct* pngPtr, byte* data, nuint length)
		{
			DefaultReadDataNative(pngPtr, data, length);
		}

		/// <summary>
		/// Next four functions are used internally as callbacks.  PNGCBAPI is required<br/>
		/// but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to<br/>
		/// PNGCBAPI at 1.5.0<br/>
		/// </summary>
		public static void DefaultReadData(PngStruct* pngPtr, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				DefaultReadDataNative(pngPtr, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// Next four functions are used internally as callbacks.  PNGCBAPI is required<br/>
		/// but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to<br/>
		/// PNGCBAPI at 1.5.0<br/>
		/// </summary>
		public static void DefaultReadData(PngStruct* pngPtr, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DefaultReadDataNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushFillBufferNative(PngStruct* pngPtr, byte* buffer, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[270])(pngPtr, buffer, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[270])((nint)pngPtr, (nint)buffer, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFillBuffer(PngStruct* pngPtr, byte* buffer, nuint length)
		{
			PushFillBufferNative(pngPtr, buffer, length);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFillBuffer(PngStruct* pngPtr, ReadOnlySpan<byte> buffer, nuint length)
		{
			fixed (byte* pbuffer = buffer)
			{
				PushFillBufferNative(pngPtr, (byte*)pbuffer, length);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushFillBuffer(PngStruct* pngPtr, string buffer, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushFillBufferNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DefaultWriteDataNative(PngStruct* pngPtr, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[271])(pngPtr, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[271])((nint)pngPtr, (nint)data, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DefaultWriteData(PngStruct* pngPtr, byte* data, nuint length)
		{
			DefaultWriteDataNative(pngPtr, data, length);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DefaultWriteData(PngStruct* pngPtr, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				DefaultWriteDataNative(pngPtr, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DefaultWriteData(PngStruct* pngPtr, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DefaultWriteDataNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DefaultFlushNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[272])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[272])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DefaultFlush(PngStruct* pngPtr)
		{
			DefaultFlushNative(pngPtr);
		}

		/// <summary>
		/// Reset the CRC variable <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetCrcNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[273])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[273])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Reset the CRC variable <br/>
		/// </summary>
		public static void ResetCrc(PngStruct* pngPtr)
		{
			ResetCrcNative(pngPtr);
		}

		/// <summary>
		/// Write the "data" buffer to whatever output you are using <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteDataNative(PngStruct* pngPtr, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[274])(pngPtr, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[274])((nint)pngPtr, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Write the "data" buffer to whatever output you are using <br/>
		/// </summary>
		public static void WriteData(PngStruct* pngPtr, byte* data, nuint length)
		{
			WriteDataNative(pngPtr, data, length);
		}

		/// <summary>
		/// Write the "data" buffer to whatever output you are using <br/>
		/// </summary>
		public static void WriteData(PngStruct* pngPtr, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				WriteDataNative(pngPtr, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// Write the "data" buffer to whatever output you are using <br/>
		/// </summary>
		public static void WriteData(PngStruct* pngPtr, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteDataNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read and check the PNG file signature <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadSigNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[275])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[275])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Read and check the PNG file signature <br/>
		/// </summary>
		public static void ReadSig(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ReadSigNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// Read the chunk header (length + type name) <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ReadChunkHeaderNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint>)funcTable[276])(pngPtr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[276])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Read the chunk header (length + type name) <br/>
		/// </summary>
		public static uint ReadChunkHeader(PngStruct* pngPtr)
		{
			uint ret = ReadChunkHeaderNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Read data from whatever input you are using into the "data" buffer <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadDataNative(PngStruct* pngPtr, byte* data, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[277])(pngPtr, data, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[277])((nint)pngPtr, (nint)data, length);
			#endif
		}

		/// <summary>
		/// Read data from whatever input you are using into the "data" buffer <br/>
		/// </summary>
		public static void ReadData(PngStruct* pngPtr, byte* data, nuint length)
		{
			ReadDataNative(pngPtr, data, length);
		}

		/// <summary>
		/// Read data from whatever input you are using into the "data" buffer <br/>
		/// </summary>
		public static void ReadData(PngStruct* pngPtr, ReadOnlySpan<byte> data, nuint length)
		{
			fixed (byte* pdata = data)
			{
				ReadDataNative(pngPtr, (byte*)pdata, length);
			}
		}

		/// <summary>
		/// Read data from whatever input you are using into the "data" buffer <br/>
		/// </summary>
		public static void ReadData(PngStruct* pngPtr, string data, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadDataNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read bytes into buf, and update png_ptr->crc <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CrcReadNative(PngStruct* pngPtr, byte* buf, uint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint, void>)funcTable[278])(pngPtr, buf, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[278])((nint)pngPtr, (nint)buf, length);
			#endif
		}

		/// <summary>
		/// Read bytes into buf, and update png_ptr->crc <br/>
		/// </summary>
		public static void CrcRead(PngStruct* pngPtr, byte* buf, uint length)
		{
			CrcReadNative(pngPtr, buf, length);
		}

		/// <summary>
		/// Read bytes into buf, and update png_ptr->crc <br/>
		/// </summary>
		public static void CrcRead(PngStruct* pngPtr, ReadOnlySpan<byte> buf, uint length)
		{
			fixed (byte* pbuf = buf)
			{
				CrcReadNative(pngPtr, (byte*)pbuf, length);
			}
		}

		/// <summary>
		/// Read bytes into buf, and update png_ptr->crc <br/>
		/// </summary>
		public static void CrcRead(PngStruct* pngPtr, string buf, uint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CrcReadNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CrcFinishNative(PngStruct* pngPtr, uint skip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint, int>)funcTable[279])(pngPtr, skip);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[279])((nint)pngPtr, skip);
			#endif
		}

		/// <summary>
		/// Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc <br/>
		/// </summary>
		public static int CrcFinish(PngStruct* pngPtr, uint skip)
		{
			int ret = CrcFinishNative(pngPtr, skip);
			return ret;
		}

		/// <summary>
		/// Calculate the CRC over a section of data.  Note that we are only<br/>
		/// passing a maximum of 64K on systems that have this as a memory limit,<br/>
		/// since this is the maximum buffer size we can specify.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateCrcNative(PngStruct* pngPtr, byte* ptr, nuint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[280])(pngPtr, ptr, length);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[280])((nint)pngPtr, (nint)ptr, length);
			#endif
		}

		/// <summary>
		/// Calculate the CRC over a section of data.  Note that we are only<br/>
		/// passing a maximum of 64K on systems that have this as a memory limit,<br/>
		/// since this is the maximum buffer size we can specify.<br/>
		/// </summary>
		public static void CalculateCrc(PngStruct* pngPtr, byte* ptr, nuint length)
		{
			CalculateCrcNative(pngPtr, ptr, length);
		}

		/// <summary>
		/// Calculate the CRC over a section of data.  Note that we are only<br/>
		/// passing a maximum of 64K on systems that have this as a memory limit,<br/>
		/// since this is the maximum buffer size we can specify.<br/>
		/// </summary>
		public static void CalculateCrc(PngStruct* pngPtr, ReadOnlySpan<byte> ptr, nuint length)
		{
			fixed (byte* pptr = ptr)
			{
				CalculateCrcNative(pngPtr, (byte*)pptr, length);
			}
		}

		/// <summary>
		/// Calculate the CRC over a section of data.  Note that we are only<br/>
		/// passing a maximum of 64K on systems that have this as a memory limit,<br/>
		/// since this is the maximum buffer size we can specify.<br/>
		/// </summary>
		public static void CalculateCrc(PngStruct* pngPtr, string ptr, nuint length)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ptr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ptr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ptr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalculateCrcNative(pngPtr, pStr0, length);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[281])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[281])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Flush(PngStruct* pngPtr)
		{
			FlushNative(pngPtr);
		}

		/// <summary>
		/// Write the IHDR chunk, and update the png_struct with the necessary<br/>
		/// information.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteIHDRNative(PngStruct* pngPtr, uint width, uint height, int bitDepth, int colorType, int compressionMethod, int filterMethod, int interlaceMethod)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint, int, int, int, int, int, void>)funcTable[282])(pngPtr, width, height, bitDepth, colorType, compressionMethod, filterMethod, interlaceMethod);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, int, int, int, int, int, void>)funcTable[282])((nint)pngPtr, width, height, bitDepth, colorType, compressionMethod, filterMethod, interlaceMethod);
			#endif
		}

		/// <summary>
		/// Write the IHDR chunk, and update the png_struct with the necessary<br/>
		/// information.<br/>
		/// </summary>
		public static void WriteIHDR(PngStruct* pngPtr, uint width, uint height, int bitDepth, int colorType, int compressionMethod, int filterMethod, int interlaceMethod)
		{
			WriteIHDRNative(pngPtr, width, height, bitDepth, colorType, compressionMethod, filterMethod, interlaceMethod);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WritePLTENative(PngStruct* pngPtr, PngColor* palette, uint numPal)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor*, uint, void>)funcTable[283])(pngPtr, palette, numPal);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, void>)funcTable[283])((nint)pngPtr, (nint)palette, numPal);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePLTE(PngStruct* pngPtr, PngColor* palette, uint numPal)
		{
			WritePLTENative(pngPtr, palette, numPal);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressIDATNative(PngStruct* pngPtr, byte* rowData, nint rowDataLength, int flush)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nint, int, void>)funcTable[284])(pngPtr, rowData, rowDataLength, flush);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[284])((nint)pngPtr, (nint)rowData, rowDataLength, flush);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompressIDAT(PngStruct* pngPtr, byte* rowData, nint rowDataLength, int flush)
		{
			CompressIDATNative(pngPtr, rowData, rowDataLength, flush);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompressIDAT(PngStruct* pngPtr, ReadOnlySpan<byte> rowData, nint rowDataLength, int flush)
		{
			fixed (byte* prowData = rowData)
			{
				CompressIDATNative(pngPtr, (byte*)prowData, rowDataLength, flush);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompressIDAT(PngStruct* pngPtr, string rowData, nint rowDataLength, int flush)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (rowData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(rowData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(rowData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompressIDATNative(pngPtr, pStr0, rowDataLength, flush);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteIENDNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[285])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[285])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteIEND(PngStruct* pngPtr)
		{
			WriteIENDNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteGAMAFixedNative(PngStruct* pngPtr, int fileGamma)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[286])(pngPtr, fileGamma);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[286])((nint)pngPtr, fileGamma);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteGAMAFixed(PngStruct* pngPtr, int fileGamma)
		{
			WriteGAMAFixedNative(pngPtr, fileGamma);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteSBITNative(PngStruct* pngPtr, PngColor8* sbit, int colorType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor8*, int, void>)funcTable[287])(pngPtr, sbit, colorType);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[287])((nint)pngPtr, (nint)sbit, colorType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSBIT(PngStruct* pngPtr, PngColor8* sbit, int colorType)
		{
			WriteSBITNative(pngPtr, sbit, colorType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteCHRMFixedNative(PngStruct* pngPtr, PngXy* xy)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngXy*, void>)funcTable[288])(pngPtr, xy);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[288])((nint)pngPtr, (nint)xy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteCHRMFixed(PngStruct* pngPtr, PngXy* xy)
		{
			WriteCHRMFixedNative(pngPtr, xy);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteCHRMFixed(PngStruct* pngPtr, ref PngXy xy)
		{
			fixed (PngXy* pxy = &xy)
			{
				WriteCHRMFixedNative(pngPtr, (PngXy*)pxy);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteCICPNative(PngStruct* pngPtr, byte colourPrimaries, byte transferFunction, byte matrixCoefficients, byte videoFullRangeFlag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte, byte, byte, byte, void>)funcTable[289])(pngPtr, colourPrimaries, transferFunction, matrixCoefficients, videoFullRangeFlag);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, byte, byte, byte, void>)funcTable[289])((nint)pngPtr, colourPrimaries, transferFunction, matrixCoefficients, videoFullRangeFlag);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteCICP(PngStruct* pngPtr, byte colourPrimaries, byte transferFunction, byte matrixCoefficients, byte videoFullRangeFlag)
		{
			WriteCICPNative(pngPtr, colourPrimaries, transferFunction, matrixCoefficients, videoFullRangeFlag);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteCLLIFixedNative(PngStruct* pngPtr, uint maxCLL, uint maxFALL)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint, void>)funcTable[290])(pngPtr, maxCLL, maxFALL);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, void>)funcTable[290])((nint)pngPtr, maxCLL, maxFALL);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteCLLIFixed(PngStruct* pngPtr, uint maxCLL, uint maxFALL)
		{
			WriteCLLIFixedNative(pngPtr, maxCLL, maxFALL);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteMDCVFixedNative(PngStruct* pngPtr, ushort redX, ushort redY, ushort greenX, ushort greenY, ushort blueX, ushort blueY, ushort whiteX, ushort whiteY, uint maxDL, uint minDL)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort, uint, uint, void>)funcTable[291])(pngPtr, redX, redY, greenX, greenY, blueX, blueY, whiteX, whiteY, maxDL, minDL);
			#else
			((delegate* unmanaged[Cdecl]<nint, ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort, uint, uint, void>)funcTable[291])((nint)pngPtr, redX, redY, greenX, greenY, blueX, blueY, whiteX, whiteY, maxDL, minDL);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteMDCVFixed(PngStruct* pngPtr, ushort redX, ushort redY, ushort greenX, ushort greenY, ushort blueX, ushort blueY, ushort whiteX, ushort whiteY, uint maxDL, uint minDL)
		{
			WriteMDCVFixedNative(pngPtr, redX, redY, greenX, greenY, blueX, blueY, whiteX, whiteY, maxDL, minDL);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteSRGBNative(PngStruct* pngPtr, int intent)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[292])(pngPtr, intent);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[292])((nint)pngPtr, intent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSRGB(PngStruct* pngPtr, int intent)
		{
			WriteSRGBNative(pngPtr, intent);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteEXIfNative(PngStruct* pngPtr, byte* exif, int numExif)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int, void>)funcTable[293])(pngPtr, exif, numExif);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[293])((nint)pngPtr, (nint)exif, numExif);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteEXIf(PngStruct* pngPtr, byte* exif, int numExif)
		{
			WriteEXIfNative(pngPtr, exif, numExif);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteEXIf(PngStruct* pngPtr, ReadOnlySpan<byte> exif, int numExif)
		{
			fixed (byte* pexif = exif)
			{
				WriteEXIfNative(pngPtr, (byte*)pexif, numExif);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteEXIf(PngStruct* pngPtr, string exif, int numExif)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (exif != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(exif);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(exif, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteEXIfNative(pngPtr, pStr0, numExif);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteICCPNative(PngStruct* pngPtr, byte* name, byte* profile, uint proflen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, uint, void>)funcTable[294])(pngPtr, name, profile, proflen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, void>)funcTable[294])((nint)pngPtr, (nint)name, (nint)profile, proflen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, byte* name, byte* profile, uint proflen)
		{
			WriteICCPNative(pngPtr, name, profile, proflen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, ReadOnlySpan<byte> name, byte* profile, uint proflen)
		{
			fixed (byte* pname = name)
			{
				WriteICCPNative(pngPtr, (byte*)pname, profile, proflen);
			}
		}
	}
}
