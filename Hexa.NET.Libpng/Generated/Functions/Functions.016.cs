// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	public unsafe partial class Libpng
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, string name, byte* profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteICCPNative(pngPtr, pStr0, profile, proflen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, byte* name, ReadOnlySpan<byte> profile, uint proflen)
		{
			fixed (byte* pprofile = profile)
			{
				WriteICCPNative(pngPtr, name, (byte*)pprofile, proflen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, byte* name, string profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (profile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(profile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(profile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteICCPNative(pngPtr, name, pStr0, proflen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, ReadOnlySpan<byte> name, ReadOnlySpan<byte> profile, uint proflen)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pprofile = profile)
				{
					WriteICCPNative(pngPtr, (byte*)pname, (byte*)pprofile, proflen);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteICCP(PngStruct* pngPtr, string name, string profile, uint proflen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (profile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(profile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(profile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteICCPNative(pngPtr, pStr0, pStr1, proflen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteSPLTNative(PngStruct* pngPtr, PngSPLT* palette)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngSPLT*, void>)funcTable[295])(pngPtr, palette);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[295])((nint)pngPtr, (nint)palette);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSPLT(PngStruct* pngPtr, PngSPLT* palette)
		{
			WriteSPLTNative(pngPtr, palette);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteTRNSNative(PngStruct* pngPtr, byte* trans, PngColor16* values, int number, int colorType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, PngColor16*, int, int, void>)funcTable[296])(pngPtr, trans, values, number, colorType);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int, void>)funcTable[296])((nint)pngPtr, (nint)trans, (nint)values, number, colorType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTRNS(PngStruct* pngPtr, byte* trans, PngColor16* values, int number, int colorType)
		{
			WriteTRNSNative(pngPtr, trans, values, number, colorType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTRNS(PngStruct* pngPtr, ReadOnlySpan<byte> trans, PngColor16* values, int number, int colorType)
		{
			fixed (byte* ptrans = trans)
			{
				WriteTRNSNative(pngPtr, (byte*)ptrans, values, number, colorType);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTRNS(PngStruct* pngPtr, string trans, PngColor16* values, int number, int colorType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (trans != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(trans);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(trans, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteTRNSNative(pngPtr, pStr0, values, number, colorType);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteBKGDNative(PngStruct* pngPtr, PngColor16* values, int colorType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngColor16*, int, void>)funcTable[297])(pngPtr, values, colorType);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[297])((nint)pngPtr, (nint)values, colorType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteBKGD(PngStruct* pngPtr, PngColor16* values, int colorType)
		{
			WriteBKGDNative(pngPtr, values, colorType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteHISTNative(PngStruct* pngPtr, ushort* hist, int numHist)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, ushort*, int, void>)funcTable[298])(pngPtr, hist, numHist);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[298])((nint)pngPtr, (nint)hist, numHist);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteHIST(PngStruct* pngPtr, ushort* hist, int numHist)
		{
			WriteHISTNative(pngPtr, hist, numHist);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteTEXtNative(PngStruct* pngPtr, byte* key, byte* text, nuint textLen)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, nuint, void>)funcTable[299])(pngPtr, key, text, textLen);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nuint, void>)funcTable[299])((nint)pngPtr, (nint)key, (nint)text, textLen);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, byte* key, byte* text, nuint textLen)
		{
			WriteTEXtNative(pngPtr, key, text, textLen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, ReadOnlySpan<byte> key, byte* text, nuint textLen)
		{
			fixed (byte* pkey = key)
			{
				WriteTEXtNative(pngPtr, (byte*)pkey, text, textLen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, string key, byte* text, nuint textLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteTEXtNative(pngPtr, pStr0, text, textLen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, byte* key, ReadOnlySpan<byte> text, nuint textLen)
		{
			fixed (byte* ptext = text)
			{
				WriteTEXtNative(pngPtr, key, (byte*)ptext, textLen);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, byte* key, string text, nuint textLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteTEXtNative(pngPtr, key, pStr0, textLen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, ReadOnlySpan<byte> key, ReadOnlySpan<byte> text, nuint textLen)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* ptext = text)
				{
					WriteTEXtNative(pngPtr, (byte*)pkey, (byte*)ptext, textLen);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTEXt(PngStruct* pngPtr, string key, string text, nuint textLen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteTEXtNative(pngPtr, pStr0, pStr1, textLen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteZTXtNative(PngStruct* pngPtr, byte* key, byte* text, int compression)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, int, void>)funcTable[300])(pngPtr, key, text, compression);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[300])((nint)pngPtr, (nint)key, (nint)text, compression);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, byte* key, byte* text, int compression)
		{
			WriteZTXtNative(pngPtr, key, text, compression);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, ReadOnlySpan<byte> key, byte* text, int compression)
		{
			fixed (byte* pkey = key)
			{
				WriteZTXtNative(pngPtr, (byte*)pkey, text, compression);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, string key, byte* text, int compression)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteZTXtNative(pngPtr, pStr0, text, compression);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, byte* key, ReadOnlySpan<byte> text, int compression)
		{
			fixed (byte* ptext = text)
			{
				WriteZTXtNative(pngPtr, key, (byte*)ptext, compression);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, byte* key, string text, int compression)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteZTXtNative(pngPtr, key, pStr0, compression);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, ReadOnlySpan<byte> key, ReadOnlySpan<byte> text, int compression)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* ptext = text)
				{
					WriteZTXtNative(pngPtr, (byte*)pkey, (byte*)ptext, compression);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteZTXt(PngStruct* pngPtr, string key, string text, int compression)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteZTXtNative(pngPtr, pStr0, pStr1, compression);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteITXtNative(PngStruct* pngPtr, int compression, byte* key, byte* lang, byte* langKey, byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, byte*, byte*, byte*, byte*, void>)funcTable[301])(pngPtr, compression, key, lang, langKey, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, nint, nint, void>)funcTable[301])((nint)pngPtr, compression, (nint)key, (nint)lang, (nint)langKey, (nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, byte* langKey, byte* text)
		{
			WriteITXtNative(pngPtr, compression, key, lang, langKey, text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, byte* lang, byte* langKey, byte* text)
		{
			fixed (byte* pkey = key)
			{
				WriteITXtNative(pngPtr, compression, (byte*)pkey, lang, langKey, text);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, byte* lang, byte* langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, lang, langKey, text);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, ReadOnlySpan<byte> lang, byte* langKey, byte* text)
		{
			fixed (byte* plang = lang)
			{
				WriteITXtNative(pngPtr, compression, key, (byte*)plang, langKey, text);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, string lang, byte* langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (lang != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(lang);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(lang, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, pStr0, langKey, text);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, ReadOnlySpan<byte> lang, byte* langKey, byte* text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plang = lang)
				{
					WriteITXtNative(pngPtr, compression, (byte*)pkey, (byte*)plang, langKey, text);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, string lang, byte* langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (lang != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(lang);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(lang, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, pStr1, langKey, text);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, ReadOnlySpan<byte> langKey, byte* text)
		{
			fixed (byte* plangKey = langKey)
			{
				WriteITXtNative(pngPtr, compression, key, lang, (byte*)plangKey, text);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, string langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (langKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(langKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, lang, pStr0, text);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, byte* lang, ReadOnlySpan<byte> langKey, byte* text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plangKey = langKey)
				{
					WriteITXtNative(pngPtr, compression, (byte*)pkey, lang, (byte*)plangKey, text);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, byte* lang, string langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (langKey != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(langKey, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, lang, pStr1, text);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, ReadOnlySpan<byte> lang, ReadOnlySpan<byte> langKey, byte* text)
		{
			fixed (byte* plang = lang)
			{
				fixed (byte* plangKey = langKey)
				{
					WriteITXtNative(pngPtr, compression, key, (byte*)plang, (byte*)plangKey, text);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, string lang, string langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (lang != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(lang);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(lang, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (langKey != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(langKey, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, pStr0, pStr1, text);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, ReadOnlySpan<byte> lang, ReadOnlySpan<byte> langKey, byte* text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plang = lang)
				{
					fixed (byte* plangKey = langKey)
					{
						WriteITXtNative(pngPtr, compression, (byte*)pkey, (byte*)plang, (byte*)plangKey, text);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, string lang, string langKey, byte* text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (lang != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(lang);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(lang, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (langKey != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(langKey, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, pStr1, pStr2, text);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, byte* langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				WriteITXtNative(pngPtr, compression, key, lang, langKey, (byte*)ptext);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, byte* langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, lang, langKey, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, byte* lang, byte* langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* ptext = text)
				{
					WriteITXtNative(pngPtr, compression, (byte*)pkey, lang, langKey, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, byte* lang, byte* langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, lang, langKey, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, ReadOnlySpan<byte> lang, byte* langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* plang = lang)
			{
				fixed (byte* ptext = text)
				{
					WriteITXtNative(pngPtr, compression, key, (byte*)plang, langKey, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, string lang, byte* langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (lang != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(lang);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(lang, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, pStr0, langKey, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, ReadOnlySpan<byte> lang, byte* langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plang = lang)
				{
					fixed (byte* ptext = text)
					{
						WriteITXtNative(pngPtr, compression, (byte*)pkey, (byte*)plang, langKey, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, string lang, byte* langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (lang != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(lang);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(lang, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (text != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(text);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(text, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, pStr1, langKey, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, ReadOnlySpan<byte> langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* plangKey = langKey)
			{
				fixed (byte* ptext = text)
				{
					WriteITXtNative(pngPtr, compression, key, lang, (byte*)plangKey, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, byte* lang, string langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (langKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(langKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (text != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(text);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(text, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, lang, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, byte* lang, ReadOnlySpan<byte> langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plangKey = langKey)
				{
					fixed (byte* ptext = text)
					{
						WriteITXtNative(pngPtr, compression, (byte*)pkey, lang, (byte*)plangKey, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, byte* lang, string langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (langKey != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(langKey, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (text != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(text);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(text, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, lang, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, ReadOnlySpan<byte> lang, ReadOnlySpan<byte> langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* plang = lang)
			{
				fixed (byte* plangKey = langKey)
				{
					fixed (byte* ptext = text)
					{
						WriteITXtNative(pngPtr, compression, key, (byte*)plang, (byte*)plangKey, (byte*)ptext);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, byte* key, string lang, string langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (lang != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(lang);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(lang, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (langKey != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(langKey, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (text != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(text);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(text, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			WriteITXtNative(pngPtr, compression, key, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, ReadOnlySpan<byte> key, ReadOnlySpan<byte> lang, ReadOnlySpan<byte> langKey, ReadOnlySpan<byte> text)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* plang = lang)
				{
					fixed (byte* plangKey = langKey)
					{
						fixed (byte* ptext = text)
						{
							WriteITXtNative(pngPtr, compression, (byte*)pkey, (byte*)plang, (byte*)plangKey, (byte*)ptext);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteITXt(PngStruct* pngPtr, int compression, string key, string lang, string langKey, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (lang != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(lang);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(lang, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (langKey != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(langKey);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(langKey, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (text != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(text);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(text, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			WriteITXtNative(pngPtr, compression, pStr0, pStr1, pStr2, pStr3);
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetText2Native(PngStruct* pngPtr, PngInfo* infoPtr, PngText* textPtr, int numText)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, PngText*, int, int>)funcTable[302])(pngPtr, infoPtr, textPtr, numText);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, int>)funcTable[302])((nint)pngPtr, (nint)infoPtr, (nint)textPtr, numText);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SetText2(PngStruct* pngPtr, PngInfo* infoPtr, PngText* textPtr, int numText)
		{
			int ret = SetText2Native(pngPtr, infoPtr, textPtr, numText);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteOFFsNative(PngStruct* pngPtr, int xOffset, int yOffset, int unitType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, int, int, void>)funcTable[303])(pngPtr, xOffset, yOffset, unitType);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, void>)funcTable[303])((nint)pngPtr, xOffset, yOffset, unitType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteOFFs(PngStruct* pngPtr, int xOffset, int yOffset, int unitType)
		{
			WriteOFFsNative(pngPtr, xOffset, yOffset, unitType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WritePCALNative(PngStruct* pngPtr, byte* purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int, int, int, int, byte*, byte**, void>)funcTable[304])(pngPtr, purpose, x0, x1, type, nparams, units, @params);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int, nint, nint, void>)funcTable[304])((nint)pngPtr, (nint)purpose, x0, x1, type, nparams, (nint)units, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, byte* purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			WritePCALNative(pngPtr, purpose, x0, x1, type, nparams, units, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, ReadOnlySpan<byte> purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			fixed (byte* ppurpose = purpose)
			{
				WritePCALNative(pngPtr, (byte*)ppurpose, x0, x1, type, nparams, units, @params);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, string purpose, int x0, int x1, int type, int nparams, byte* units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (purpose != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(purpose);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(purpose, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WritePCALNative(pngPtr, pStr0, x0, x1, type, nparams, units, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, byte* purpose, int x0, int x1, int type, int nparams, ReadOnlySpan<byte> units, byte** @params)
		{
			fixed (byte* punits = units)
			{
				WritePCALNative(pngPtr, purpose, x0, x1, type, nparams, (byte*)punits, @params);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, byte* purpose, int x0, int x1, int type, int nparams, string units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (units != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(units);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(units, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WritePCALNative(pngPtr, purpose, x0, x1, type, nparams, pStr0, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, ReadOnlySpan<byte> purpose, int x0, int x1, int type, int nparams, ReadOnlySpan<byte> units, byte** @params)
		{
			fixed (byte* ppurpose = purpose)
			{
				fixed (byte* punits = units)
				{
					WritePCALNative(pngPtr, (byte*)ppurpose, x0, x1, type, nparams, (byte*)punits, @params);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePCAL(PngStruct* pngPtr, string purpose, int x0, int x1, int type, int nparams, string units, byte** @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (purpose != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(purpose);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(purpose, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (units != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(units);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(units, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WritePCALNative(pngPtr, pStr0, x0, x1, type, nparams, pStr1, @params);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WritePHYsNative(PngStruct* pngPtr, uint xPixelsPerUnit, uint yPixelsPerUnit, int unitType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint, int, void>)funcTable[305])(pngPtr, xPixelsPerUnit, yPixelsPerUnit, unitType);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, int, void>)funcTable[305])((nint)pngPtr, xPixelsPerUnit, yPixelsPerUnit, unitType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WritePHYs(PngStruct* pngPtr, uint xPixelsPerUnit, uint yPixelsPerUnit, int unitType)
		{
			WritePHYsNative(pngPtr, xPixelsPerUnit, yPixelsPerUnit, unitType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteTIMENative(PngStruct* pngPtr, PngTime* modTime)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngTime*, void>)funcTable[306])(pngPtr, modTime);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[306])((nint)pngPtr, (nint)modTime);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteTIME(PngStruct* pngPtr, PngTime* modTime)
		{
			WriteTIMENative(pngPtr, modTime);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteSCALSNative(PngStruct* pngPtr, int unit, byte* width, byte* height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, byte*, byte*, void>)funcTable[307])(pngPtr, unit, width, height);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[307])((nint)pngPtr, unit, (nint)width, (nint)height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, byte* width, byte* height)
		{
			WriteSCALSNative(pngPtr, unit, width, height);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, ReadOnlySpan<byte> width, byte* height)
		{
			fixed (byte* pwidth = width)
			{
				WriteSCALSNative(pngPtr, unit, (byte*)pwidth, height);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, string width, byte* height)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (width != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(width, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteSCALSNative(pngPtr, unit, pStr0, height);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, byte* width, ReadOnlySpan<byte> height)
		{
			fixed (byte* pheight = height)
			{
				WriteSCALSNative(pngPtr, unit, width, (byte*)pheight);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, byte* width, string height)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (height != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(height);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(height, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WriteSCALSNative(pngPtr, unit, width, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, ReadOnlySpan<byte> width, ReadOnlySpan<byte> height)
		{
			fixed (byte* pwidth = width)
			{
				fixed (byte* pheight = height)
				{
					WriteSCALSNative(pngPtr, unit, (byte*)pwidth, (byte*)pheight);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WriteSCALS(PngStruct* pngPtr, int unit, string width, string height)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (width != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(width, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (height != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(height);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(height, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			WriteSCALSNative(pngPtr, unit, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Called when finished processing a row of data <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteFinishRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[308])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[308])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Called when finished processing a row of data <br/>
		/// </summary>
		public static void WriteFinishRow(PngStruct* pngPtr)
		{
			WriteFinishRowNative(pngPtr);
		}

		/// <summary>
		/// Internal use only.   Called before first row of data <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteStartRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[309])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[309])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Internal use only.   Called before first row of data <br/>
		/// </summary>
		public static void WriteStartRow(PngStruct* pngPtr)
		{
			WriteStartRowNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombineRowNative(PngStruct* pngPtr, byte* row, int display)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int, void>)funcTable[310])(pngPtr, row, display);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[310])((nint)pngPtr, (nint)row, display);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineRow(PngStruct* pngPtr, byte* row, int display)
		{
			CombineRowNative(pngPtr, row, display);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineRow(PngStruct* pngPtr, ReadOnlySpan<byte> row, int display)
		{
			fixed (byte* prow = row)
			{
				CombineRowNative(pngPtr, (byte*)prow, display);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineRow(PngStruct* pngPtr, string row, int display)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CombineRowNative(pngPtr, pStr0, display);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Expand an interlaced row: the 'row_info' describes the pass data that has<br/>
		/// been read in and must correspond to the pixels in 'row', the pixels are<br/>
		/// expanded (moved apart) in 'row' to match the final layout, when doing this<br/>
		/// the pixels are *replicated* to the intervening space.  This is essential for<br/>
		/// the correct operation of png_combine_row, above.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoReadInterlaceNative(PngRowInfo* rowInfo, byte* row, int pass, uint transformations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, int, uint, void>)funcTable[311])(rowInfo, row, pass, transformations);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, uint, void>)funcTable[311])((nint)rowInfo, (nint)row, pass, transformations);
			#endif
		}

		/// <summary>
		/// Expand an interlaced row: the 'row_info' describes the pass data that has<br/>
		/// been read in and must correspond to the pixels in 'row', the pixels are<br/>
		/// expanded (moved apart) in 'row' to match the final layout, when doing this<br/>
		/// the pixels are *replicated* to the intervening space.  This is essential for<br/>
		/// the correct operation of png_combine_row, above.<br/>
		/// </summary>
		public static void DoReadInterlace(PngRowInfo* rowInfo, byte* row, int pass, uint transformations)
		{
			DoReadInterlaceNative(rowInfo, row, pass, transformations);
		}

		/// <summary>
		/// Expand an interlaced row: the 'row_info' describes the pass data that has<br/>
		/// been read in and must correspond to the pixels in 'row', the pixels are<br/>
		/// expanded (moved apart) in 'row' to match the final layout, when doing this<br/>
		/// the pixels are *replicated* to the intervening space.  This is essential for<br/>
		/// the correct operation of png_combine_row, above.<br/>
		/// </summary>
		public static void DoReadInterlace(PngRowInfo* rowInfo, ReadOnlySpan<byte> row, int pass, uint transformations)
		{
			fixed (byte* prow = row)
			{
				DoReadInterlaceNative(rowInfo, (byte*)prow, pass, transformations);
			}
		}

		/// <summary>
		/// Expand an interlaced row: the 'row_info' describes the pass data that has<br/>
		/// been read in and must correspond to the pixels in 'row', the pixels are<br/>
		/// expanded (moved apart) in 'row' to match the final layout, when doing this<br/>
		/// the pixels are *replicated* to the intervening space.  This is essential for<br/>
		/// the correct operation of png_combine_row, above.<br/>
		/// </summary>
		public static void DoReadInterlace(PngRowInfo* rowInfo, string row, int pass, uint transformations)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoReadInterlaceNative(rowInfo, pStr0, pass, transformations);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Grab pixels out of a row for an interlaced pass <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoWriteInterlaceNative(PngRowInfo* rowInfo, byte* row, int pass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, int, void>)funcTable[312])(rowInfo, row, pass);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[312])((nint)rowInfo, (nint)row, pass);
			#endif
		}

		/// <summary>
		/// Grab pixels out of a row for an interlaced pass <br/>
		/// </summary>
		public static void DoWriteInterlace(PngRowInfo* rowInfo, byte* row, int pass)
		{
			DoWriteInterlaceNative(rowInfo, row, pass);
		}

		/// <summary>
		/// Grab pixels out of a row for an interlaced pass <br/>
		/// </summary>
		public static void DoWriteInterlace(PngRowInfo* rowInfo, ReadOnlySpan<byte> row, int pass)
		{
			fixed (byte* prow = row)
			{
				DoWriteInterlaceNative(rowInfo, (byte*)prow, pass);
			}
		}

		/// <summary>
		/// Grab pixels out of a row for an interlaced pass <br/>
		/// </summary>
		public static void DoWriteInterlace(PngRowInfo* rowInfo, string row, int pass)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoWriteInterlaceNative(rowInfo, pStr0, pass);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadFilterRowNative(PngStruct* pp, PngRowInfo* rowInfo, byte* row, byte* prevRow, int filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngRowInfo*, byte*, byte*, int, void>)funcTable[313])(pp, rowInfo, row, prevRow, filter);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int, void>)funcTable[313])((nint)pp, (nint)rowInfo, (nint)row, (nint)prevRow, filter);
			#endif
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, byte* row, byte* prevRow, int filter)
		{
			ReadFilterRowNative(pp, rowInfo, row, prevRow, filter);
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, ReadOnlySpan<byte> row, byte* prevRow, int filter)
		{
			fixed (byte* prow = row)
			{
				ReadFilterRowNative(pp, rowInfo, (byte*)prow, prevRow, filter);
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, string row, byte* prevRow, int filter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadFilterRowNative(pp, rowInfo, pStr0, prevRow, filter);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, byte* row, ReadOnlySpan<byte> prevRow, int filter)
		{
			fixed (byte* pprevRow = prevRow)
			{
				ReadFilterRowNative(pp, rowInfo, row, (byte*)pprevRow, filter);
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, byte* row, string prevRow, int filter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prevRow != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prevRow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prevRow, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadFilterRowNative(pp, rowInfo, row, pStr0, filter);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, ReadOnlySpan<byte> row, ReadOnlySpan<byte> prevRow, int filter)
		{
			fixed (byte* prow = row)
			{
				fixed (byte* pprevRow = prevRow)
				{
					ReadFilterRowNative(pp, rowInfo, (byte*)prow, (byte*)pprevRow, filter);
				}
			}
		}

		/// <summary>
		/// Unfilter a row: check the filter value before calling this, there is no point<br/>
		/// calling it for PNG_FILTER_VALUE_NONE.<br/>
		/// </summary>
		public static void ReadFilterRow(PngStruct* pp, PngRowInfo* rowInfo, string row, string prevRow, int filter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (prevRow != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(prevRow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(prevRow, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ReadFilterRowNative(pp, rowInfo, pStr0, pStr1, filter);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Choose the best filter to use and filter the row data <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteFindFilterNative(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngRowInfo*, void>)funcTable[314])(pngPtr, rowInfo);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[314])((nint)pngPtr, (nint)rowInfo);
			#endif
		}

		/// <summary>
		/// Choose the best filter to use and filter the row data <br/>
		/// </summary>
		public static void WriteFindFilter(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			WriteFindFilterNative(pngPtr, rowInfo);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadIDATDataNative(PngStruct* pngPtr, byte* output, nint availOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nint, void>)funcTable[315])(pngPtr, output, availOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[315])((nint)pngPtr, (nint)output, availOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReadIDATData(PngStruct* pngPtr, byte* output, nint availOut)
		{
			ReadIDATDataNative(pngPtr, output, availOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReadIDATData(PngStruct* pngPtr, ReadOnlySpan<byte> output, nint availOut)
		{
			fixed (byte* poutput = output)
			{
				ReadIDATDataNative(pngPtr, (byte*)poutput, availOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReadIDATData(PngStruct* pngPtr, string output, nint availOut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (output != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(output);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(output, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ReadIDATDataNative(pngPtr, pStr0, availOut);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Read 'avail_out' bytes of data from the IDAT stream.  If the output buffer<br/>
		/// is NULL the function checks, instead, for the end of the stream.  In this<br/>
		/// case a benign error will be issued if the stream end is not found or if<br/>
		/// extra data has to be consumed.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadFinishIDATNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[316])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[316])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Read 'avail_out' bytes of data from the IDAT stream.  If the output buffer<br/>
		/// is NULL the function checks, instead, for the end of the stream.  In this<br/>
		/// case a benign error will be issued if the stream end is not found or if<br/>
		/// extra data has to be consumed.<br/>
		/// </summary>
		public static void ReadFinishIDAT(PngStruct* pngPtr)
		{
			ReadFinishIDATNative(pngPtr);
		}

		/// <summary>
		/// This cleans up when the IDAT LZ stream does not end when the last image<br/>
		/// byte is read; there is still some pending input.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadFinishRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[317])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[317])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// This cleans up when the IDAT LZ stream does not end when the last image<br/>
		/// byte is read; there is still some pending input.<br/>
		/// </summary>
		public static void ReadFinishRow(PngStruct* pngPtr)
		{
			ReadFinishRowNative(pngPtr);
		}

		/// <summary>
		/// Initialize the row buffers, etc. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadStartRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[318])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[318])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Initialize the row buffers, etc. <br/>
		/// </summary>
		public static void ReadStartRow(PngStruct* pngPtr)
		{
			ReadStartRowNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ZlibInflateNative(PngStruct* pngPtr, int flush)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int, int>)funcTable[319])(pngPtr, flush);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[319])((nint)pngPtr, flush);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ZlibInflate(PngStruct* pngPtr, int flush)
		{
			int ret = ZlibInflateNative(pngPtr, flush);
			return ret;
		}

		/// <summary>
		/// Optional call to update the users info structure <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadTransformInfoNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[320])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[320])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// Optional call to update the users info structure <br/>
		/// </summary>
		public static void ReadTransformInfo(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ReadTransformInfoNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoStripChannelNative(PngRowInfo* rowInfo, byte* row, int atStart)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, int, void>)funcTable[321])(rowInfo, row, atStart);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[321])((nint)rowInfo, (nint)row, atStart);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoStripChannel(PngRowInfo* rowInfo, byte* row, int atStart)
		{
			DoStripChannelNative(rowInfo, row, atStart);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoStripChannel(PngRowInfo* rowInfo, ReadOnlySpan<byte> row, int atStart)
		{
			fixed (byte* prow = row)
			{
				DoStripChannelNative(rowInfo, (byte*)prow, atStart);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoStripChannel(PngRowInfo* rowInfo, string row, int atStart)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoStripChannelNative(rowInfo, pStr0, atStart);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoSwapNative(PngRowInfo* rowInfo, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, void>)funcTable[322])(rowInfo, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[322])((nint)rowInfo, (nint)row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoSwap(PngRowInfo* rowInfo, byte* row)
		{
			DoSwapNative(rowInfo, row);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoSwap(PngRowInfo* rowInfo, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				DoSwapNative(rowInfo, (byte*)prow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoSwap(PngRowInfo* rowInfo, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoSwapNative(rowInfo, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoPackswapNative(PngRowInfo* rowInfo, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, void>)funcTable[323])(rowInfo, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[323])((nint)rowInfo, (nint)row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoPackswap(PngRowInfo* rowInfo, byte* row)
		{
			DoPackswapNative(rowInfo, row);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoPackswap(PngRowInfo* rowInfo, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				DoPackswapNative(rowInfo, (byte*)prow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoPackswap(PngRowInfo* rowInfo, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoPackswapNative(rowInfo, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoInvertNative(PngRowInfo* rowInfo, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, void>)funcTable[324])(rowInfo, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[324])((nint)rowInfo, (nint)row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoInvert(PngRowInfo* rowInfo, byte* row)
		{
			DoInvertNative(rowInfo, row);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoInvert(PngRowInfo* rowInfo, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				DoInvertNative(rowInfo, (byte*)prow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoInvert(PngRowInfo* rowInfo, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoInvertNative(rowInfo, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoBgrNative(PngRowInfo* rowInfo, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngRowInfo*, byte*, void>)funcTable[325])(rowInfo, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[325])((nint)rowInfo, (nint)row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoBgr(PngRowInfo* rowInfo, byte* row)
		{
			DoBgrNative(rowInfo, row);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoBgr(PngRowInfo* rowInfo, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				DoBgrNative(rowInfo, (byte*)prow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoBgr(PngRowInfo* rowInfo, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DoBgrNative(rowInfo, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngHandleResultCode HandleUnknownNative(PngStruct* pngPtr, PngInfo* infoPtr, uint length, int keep)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint, int, PngHandleResultCode>)funcTable[326])(pngPtr, infoPtr, length, keep);
			#else
			return (PngHandleResultCode)((delegate* unmanaged[Cdecl]<nint, nint, uint, int, PngHandleResultCode>)funcTable[326])((nint)pngPtr, (nint)infoPtr, length, keep);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static PngHandleResultCode HandleUnknown(PngStruct* pngPtr, PngInfo* infoPtr, uint length, int keep)
		{
			PngHandleResultCode ret = HandleUnknownNative(pngPtr, infoPtr, length, keep);
			return ret;
		}

		/// <summary>
		/// This is the function that gets called for unknown chunks.  The 'keep'<br/>
		/// argument is either non-zero for a known chunk that has been set to be<br/>
		/// handled as unknown or zero for an unknown chunk.  By default the function<br/>
		/// just skips the chunk or errors out if it is critical.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static PngHandleResultCode HandleChunkNative(PngStruct* pngPtr, PngInfo* infoPtr, uint length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, uint, PngHandleResultCode>)funcTable[327])(pngPtr, infoPtr, length);
			#else
			return (PngHandleResultCode)((delegate* unmanaged[Cdecl]<nint, nint, uint, PngHandleResultCode>)funcTable[327])((nint)pngPtr, (nint)infoPtr, length);
			#endif
		}

		/// <summary>
		/// This is the function that gets called for unknown chunks.  The 'keep'<br/>
		/// argument is either non-zero for a known chunk that has been set to be<br/>
		/// handled as unknown or zero for an unknown chunk.  By default the function<br/>
		/// just skips the chunk or errors out if it is critical.<br/>
		/// </summary>
		public static PngHandleResultCode HandleChunk(PngStruct* pngPtr, PngInfo* infoPtr, uint length)
		{
			PngHandleResultCode ret = HandleChunkNative(pngPtr, infoPtr, length);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ChunkUnknownHandlingNative(PngStruct* pngPtr, uint chunkName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint, int>)funcTable[328])(pngPtr, chunkName);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, uint, int>)funcTable[328])((nint)pngPtr, chunkName);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ChunkUnknownHandling(PngStruct* pngPtr, uint chunkName)
		{
			int ret = ChunkUnknownHandlingNative(pngPtr, chunkName);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoReadTransformationsNative(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngRowInfo*, void>)funcTable[329])(pngPtr, rowInfo);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[329])((nint)pngPtr, (nint)rowInfo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoReadTransformations(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			DoReadTransformationsNative(pngPtr, rowInfo);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoWriteTransformationsNative(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngRowInfo*, void>)funcTable[330])(pngPtr, rowInfo);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[330])((nint)pngPtr, (nint)rowInfo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoWriteTransformations(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			DoWriteTransformationsNative(pngPtr, rowInfo);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitReadTransformationsNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[331])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[331])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InitReadTransformations(PngStruct* pngPtr)
		{
			InitReadTransformationsNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushReadChunkNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[332])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[332])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushReadChunk(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			PushReadChunkNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushReadSigNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[333])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[333])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushReadSig(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			PushReadSigNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushCheckCrcNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[334])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[334])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushCheckCrc(PngStruct* pngPtr)
		{
			PushCheckCrcNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushSaveBufferNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[335])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[335])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushSaveBuffer(PngStruct* pngPtr)
		{
			PushSaveBufferNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushRestoreBufferNative(PngStruct* pngPtr, byte* buffer, nuint bufferLength)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[336])(pngPtr, buffer, bufferLength);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[336])((nint)pngPtr, (nint)buffer, bufferLength);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushRestoreBuffer(PngStruct* pngPtr, byte* buffer, nuint bufferLength)
		{
			PushRestoreBufferNative(pngPtr, buffer, bufferLength);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushRestoreBuffer(PngStruct* pngPtr, ReadOnlySpan<byte> buffer, nuint bufferLength)
		{
			fixed (byte* pbuffer = buffer)
			{
				PushRestoreBufferNative(pngPtr, (byte*)pbuffer, bufferLength);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushRestoreBuffer(PngStruct* pngPtr, string buffer, nuint bufferLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushRestoreBufferNative(pngPtr, pStr0, bufferLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushReadIDATNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[337])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[337])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushReadIDAT(PngStruct* pngPtr)
		{
			PushReadIDATNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProcessIDATDataNative(PngStruct* pngPtr, byte* buffer, nuint bufferLength)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, void>)funcTable[338])(pngPtr, buffer, bufferLength);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, void>)funcTable[338])((nint)pngPtr, (nint)buffer, bufferLength);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ProcessIDATData(PngStruct* pngPtr, byte* buffer, nuint bufferLength)
		{
			ProcessIDATDataNative(pngPtr, buffer, bufferLength);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ProcessIDATData(PngStruct* pngPtr, ReadOnlySpan<byte> buffer, nuint bufferLength)
		{
			fixed (byte* pbuffer = buffer)
			{
				ProcessIDATDataNative(pngPtr, (byte*)pbuffer, bufferLength);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ProcessIDATData(PngStruct* pngPtr, string buffer, nuint bufferLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProcessIDATDataNative(pngPtr, pStr0, bufferLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushProcessRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[339])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[339])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushProcessRow(PngStruct* pngPtr)
		{
			PushProcessRowNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushHaveInfoNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[340])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[340])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushHaveInfo(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			PushHaveInfoNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushHaveEndNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[341])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[341])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushHaveEnd(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			PushHaveEndNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushHaveRowNative(PngStruct* pngPtr, byte* row)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[342])(pngPtr, row);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[342])((nint)pngPtr, (nint)row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushHaveRow(PngStruct* pngPtr, byte* row)
		{
			PushHaveRowNative(pngPtr, row);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushHaveRow(PngStruct* pngPtr, ReadOnlySpan<byte> row)
		{
			fixed (byte* prow = row)
			{
				PushHaveRowNative(pngPtr, (byte*)prow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushHaveRow(PngStruct* pngPtr, string row)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (row != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(row);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(row, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushHaveRowNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushReadEndNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[343])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[343])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PushReadEnd(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			PushReadEndNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProcessSomeDataNative(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngInfo*, void>)funcTable[344])(pngPtr, infoPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[344])((nint)pngPtr, (nint)infoPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ProcessSomeData(PngStruct* pngPtr, PngInfo* infoPtr)
		{
			ProcessSomeDataNative(pngPtr, infoPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadPushFinishRowNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[345])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[345])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ReadPushFinishRow(PngStruct* pngPtr)
		{
			ReadPushFinishRowNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IccCheckLengthNative(PngStruct* pngPtr, byte* name, uint profileLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint, int>)funcTable[346])(pngPtr, name, profileLength);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, int>)funcTable[346])((nint)pngPtr, (nint)name, profileLength);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckLength(PngStruct* pngPtr, byte* name, uint profileLength)
		{
			int ret = IccCheckLengthNative(pngPtr, name, profileLength);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckLength(PngStruct* pngPtr, ReadOnlySpan<byte> name, uint profileLength)
		{
			fixed (byte* pname = name)
			{
				int ret = IccCheckLengthNative(pngPtr, (byte*)pname, profileLength);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckLength(PngStruct* pngPtr, string name, uint profileLength)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IccCheckLengthNative(pngPtr, pStr0, profileLength);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IccCheckHeaderNative(PngStruct* pngPtr, byte* name, uint profileLength, byte* profile, int colorType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint, byte*, int, int>)funcTable[347])(pngPtr, name, profileLength, profile, colorType);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, int, int>)funcTable[347])((nint)pngPtr, (nint)name, profileLength, (nint)profile, colorType);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, byte* name, uint profileLength, byte* profile, int colorType)
		{
			int ret = IccCheckHeaderNative(pngPtr, name, profileLength, profile, colorType);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, ReadOnlySpan<byte> name, uint profileLength, byte* profile, int colorType)
		{
			fixed (byte* pname = name)
			{
				int ret = IccCheckHeaderNative(pngPtr, (byte*)pname, profileLength, profile, colorType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, string name, uint profileLength, byte* profile, int colorType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IccCheckHeaderNative(pngPtr, pStr0, profileLength, profile, colorType);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, byte* name, uint profileLength, ReadOnlySpan<byte> profile, int colorType)
		{
			fixed (byte* pprofile = profile)
			{
				int ret = IccCheckHeaderNative(pngPtr, name, profileLength, (byte*)pprofile, colorType);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, byte* name, uint profileLength, string profile, int colorType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (profile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(profile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(profile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IccCheckHeaderNative(pngPtr, name, profileLength, pStr0, colorType);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, ReadOnlySpan<byte> name, uint profileLength, ReadOnlySpan<byte> profile, int colorType)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pprofile = profile)
				{
					int ret = IccCheckHeaderNative(pngPtr, (byte*)pname, profileLength, (byte*)pprofile, colorType);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckHeader(PngStruct* pngPtr, string name, uint profileLength, string profile, int colorType)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (profile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(profile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(profile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = IccCheckHeaderNative(pngPtr, pStr0, profileLength, pStr1, colorType);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IccCheckTagTableNative(PngStruct* pngPtr, byte* name, uint profileLength, byte* profile)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, uint, byte*, int>)funcTable[348])(pngPtr, name, profileLength, profile);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, int>)funcTable[348])((nint)pngPtr, (nint)name, profileLength, (nint)profile);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, byte* name, uint profileLength, byte* profile)
		{
			int ret = IccCheckTagTableNative(pngPtr, name, profileLength, profile);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, ReadOnlySpan<byte> name, uint profileLength, byte* profile)
		{
			fixed (byte* pname = name)
			{
				int ret = IccCheckTagTableNative(pngPtr, (byte*)pname, profileLength, profile);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, string name, uint profileLength, byte* profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IccCheckTagTableNative(pngPtr, pStr0, profileLength, profile);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, byte* name, uint profileLength, ReadOnlySpan<byte> profile)
		{
			fixed (byte* pprofile = profile)
			{
				int ret = IccCheckTagTableNative(pngPtr, name, profileLength, (byte*)pprofile);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, byte* name, uint profileLength, string profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (profile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(profile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(profile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IccCheckTagTableNative(pngPtr, name, profileLength, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, ReadOnlySpan<byte> name, uint profileLength, ReadOnlySpan<byte> profile)
		{
			fixed (byte* pname = name)
			{
				fixed (byte* pprofile = profile)
				{
					int ret = IccCheckTagTableNative(pngPtr, (byte*)pname, profileLength, (byte*)pprofile);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int IccCheckTagTable(PngStruct* pngPtr, string name, uint profileLength, string profile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (profile != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(profile);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(profile, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = IccCheckTagTableNative(pngPtr, pStr0, profileLength, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set the RGB coefficients if not already set by png_set_rgb_to_gray <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetRgbCoefficientsNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[349])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[349])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// Set the RGB coefficients if not already set by png_set_rgb_to_gray <br/>
		/// </summary>
		public static void SetRgbCoefficients(PngStruct* pngPtr)
		{
			SetRgbCoefficientsNative(pngPtr);
		}

		/// <summary>
		/// Added at libpng version 1.4.0 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CheckIHDRNative(PngStruct* pngPtr, uint width, uint height, int bitDepth, int colorType, int interlaceType, int compressionType, int filterType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, uint, uint, int, int, int, int, int, void>)funcTable[350])(pngPtr, width, height, bitDepth, colorType, interlaceType, compressionType, filterType);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, uint, int, int, int, int, int, void>)funcTable[350])((nint)pngPtr, width, height, bitDepth, colorType, interlaceType, compressionType, filterType);
			#endif
		}

		/// <summary>
		/// Added at libpng version 1.4.0 <br/>
		/// </summary>
		public static void CheckIHDR(PngStruct* pngPtr, uint width, uint height, int bitDepth, int colorType, int interlaceType, int compressionType, int filterType)
		{
			CheckIHDRNative(pngPtr, width, height, bitDepth, colorType, interlaceType, compressionType, filterType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoCheckPaletteIndexesNative(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngRowInfo*, void>)funcTable[351])(pngPtr, rowInfo);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[351])((nint)pngPtr, (nint)rowInfo);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DoCheckPaletteIndexes(PngStruct* pngPtr, PngRowInfo* rowInfo)
		{
			DoCheckPaletteIndexesNative(pngPtr, rowInfo);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FixedErrorNative(PngStruct* pngPtr, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[352])(pngPtr, name);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[352])((nint)pngPtr, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FixedError(PngStruct* pngPtr, byte* name)
		{
			FixedErrorNative(pngPtr, name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FixedError(PngStruct* pngPtr, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				FixedErrorNative(pngPtr, (byte*)pname);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FixedError(PngStruct* pngPtr, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FixedErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint SafecatNative(byte* buffer, nuint bufsize, nuint pos, byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint, byte*, nuint>)funcTable[353])(buffer, bufsize, pos, str);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<nint, nuint, nuint, nint, nuint>)funcTable[353])((nint)buffer, bufsize, pos, (nint)str);
			#endif
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(byte* buffer, nuint bufsize, nuint pos, byte* str)
		{
			nuint ret = SafecatNative(buffer, bufsize, pos, str);
			return ret;
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(ReadOnlySpan<byte> buffer, nuint bufsize, nuint pos, byte* str)
		{
			fixed (byte* pbuffer = buffer)
			{
				nuint ret = SafecatNative((byte*)pbuffer, bufsize, pos, str);
				return ret;
			}
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(string buffer, nuint bufsize, nuint pos, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SafecatNative(pStr0, bufsize, pos, str);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(byte* buffer, nuint bufsize, nuint pos, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				nuint ret = SafecatNative(buffer, bufsize, pos, (byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(byte* buffer, nuint bufsize, nuint pos, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SafecatNative(buffer, bufsize, pos, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(ReadOnlySpan<byte> buffer, nuint bufsize, nuint pos, ReadOnlySpan<byte> str)
		{
			fixed (byte* pbuffer = buffer)
			{
				fixed (byte* pstr = str)
				{
					nuint ret = SafecatNative((byte*)pbuffer, bufsize, pos, (byte*)pstr);
					return ret;
				}
			}
		}

		/// <summary>
		/// Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite<br/>
		/// the end.  Always leaves the buffer nul terminated.  Never errors out (and<br/>
		/// there is no error code.)<br/>
		/// </summary>
		public static nuint Safecat(string buffer, nuint bufsize, nuint pos, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = SafecatNative(pStr0, bufsize, pos, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* FormatNumberNative(byte* start, byte* end, int format, nint number)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int, nint, byte*>)funcTable[354])(start, end, format, number);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint>)funcTable[354])((nint)start, (nint)end, format, number);
			#endif
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(byte* start, byte* end, int format, nint number)
		{
			byte* ret = FormatNumberNative(start, end, format, number);
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(byte* start, byte* end, int format, nint number)
		{
			string ret = Utils.DecodeStringUTF8(FormatNumberNative(start, end, format, number));
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(ReadOnlySpan<byte> start, byte* end, int format, nint number)
		{
			fixed (byte* pstart = start)
			{
				byte* ret = FormatNumberNative((byte*)pstart, end, format, number);
				return ret;
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(ReadOnlySpan<byte> start, byte* end, int format, nint number)
		{
			fixed (byte* pstart = start)
			{
				string ret = Utils.DecodeStringUTF8(FormatNumberNative((byte*)pstart, end, format, number));
				return ret;
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(string start, byte* end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (start != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(start);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(start, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FormatNumberNative(pStr0, end, format, number);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(string start, byte* end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (start != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(start);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(start, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FormatNumberNative(pStr0, end, format, number));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(byte* start, ReadOnlySpan<byte> end, int format, nint number)
		{
			fixed (byte* pend = end)
			{
				byte* ret = FormatNumberNative(start, (byte*)pend, format, number);
				return ret;
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(byte* start, ReadOnlySpan<byte> end, int format, nint number)
		{
			fixed (byte* pend = end)
			{
				string ret = Utils.DecodeStringUTF8(FormatNumberNative(start, (byte*)pend, format, number));
				return ret;
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(byte* start, string end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (end != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(end);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(end, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = FormatNumberNative(start, pStr0, format, number);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(byte* start, string end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (end != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(end);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(end, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FormatNumberNative(start, pStr0, format, number));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(ReadOnlySpan<byte> start, ReadOnlySpan<byte> end, int format, nint number)
		{
			fixed (byte* pstart = start)
			{
				fixed (byte* pend = end)
				{
					byte* ret = FormatNumberNative((byte*)pstart, (byte*)pend, format, number);
					return ret;
				}
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(ReadOnlySpan<byte> start, ReadOnlySpan<byte> end, int format, nint number)
		{
			fixed (byte* pstart = start)
			{
				fixed (byte* pend = end)
				{
					string ret = Utils.DecodeStringUTF8(FormatNumberNative((byte*)pstart, (byte*)pend, format, number));
					return ret;
				}
			}
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static byte* FormatNumber(string start, string end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (start != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(start);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(start, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (end != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(end);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(end, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = FormatNumberNative(pStr0, pStr1, format, number);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Utility to dump an unsigned value into a buffer, given a start pointer and<br/>
		/// and end pointer (which should point just *beyond* the end of the buffer!)<br/>
		/// Returns the pointer to the start of the formatted string.  This utility only<br/>
		/// does unsigned values.<br/>
		/// </summary>
		public static string FormatNumberS(string start, string end, int format, nint number)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (start != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(start);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(start, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (end != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(end);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(end, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(FormatNumberNative(pStr0, pStr1, format, number));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarningParameterNative(PngWarningParameters p, int number, byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, byte*, void>)funcTable[355])(p, number, str);
			#else
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, nint, void>)funcTable[355])(p, number, (nint)str);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WarningParameter(PngWarningParameters p, int number, byte* str)
		{
			WarningParameterNative(p, number, str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WarningParameter(PngWarningParameters p, int number, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				WarningParameterNative(p, number, (byte*)pstr);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WarningParameter(PngWarningParameters p, int number, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			WarningParameterNative(p, number, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Parameters are limited in size to PNG_WARNING_PARAMETER_SIZE characters,<br/>
		/// including the trailing '<br/>
		/// \<br/>
		/// 0'.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarningParameterUnsignedNative(PngWarningParameters p, int number, int format, nint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, int, nint, void>)funcTable[356])(p, number, format, value);
			#else
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, int, nint, void>)funcTable[356])(p, number, format, value);
			#endif
		}

		/// <summary>
		/// Parameters are limited in size to PNG_WARNING_PARAMETER_SIZE characters,<br/>
		/// including the trailing '<br/>
		/// \<br/>
		/// 0'.<br/>
		/// </summary>
		public static void WarningParameterUnsigned(PngWarningParameters p, int number, int format, nint value)
		{
			WarningParameterUnsignedNative(p, number, format, value);
		}

		/// <summary>
		/// Use png_alloc_size_t because it is an unsigned type as big as any we<br/>
		/// need to output.  Use the following for a signed value.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WarningParameterSignedNative(PngWarningParameters p, int number, int format, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, int, int, void>)funcTable[357])(p, number, format, value);
			#else
			((delegate* unmanaged[Cdecl]<PngWarningParameters, int, int, int, void>)funcTable[357])(p, number, format, value);
			#endif
		}

		/// <summary>
		/// Use png_alloc_size_t because it is an unsigned type as big as any we<br/>
		/// need to output.  Use the following for a signed value.<br/>
		/// </summary>
		public static void WarningParameterSigned(PngWarningParameters p, int number, int format, int value)
		{
			WarningParameterSignedNative(p, number, format, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FormattedWarningNative(PngStruct* pngPtr, PngWarningParameters p, byte* message)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, PngWarningParameters, byte*, void>)funcTable[358])(pngPtr, p, message);
			#else
			((delegate* unmanaged[Cdecl]<nint, PngWarningParameters, nint, void>)funcTable[358])((nint)pngPtr, p, (nint)message);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FormattedWarning(PngStruct* pngPtr, PngWarningParameters p, byte* message)
		{
			FormattedWarningNative(pngPtr, p, message);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FormattedWarning(PngStruct* pngPtr, PngWarningParameters p, ReadOnlySpan<byte> message)
		{
			fixed (byte* pmessage = message)
			{
				FormattedWarningNative(pngPtr, p, (byte*)pmessage);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FormattedWarning(PngStruct* pngPtr, PngWarningParameters p, string message)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FormattedWarningNative(pngPtr, p, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Application errors (new in 1.6); use these functions (declared below) for<br/>
		/// errors in the parameters or order of API function calls on read.  The<br/>
		/// 'warning' should be used for an error that can be handled completely; the<br/>
		/// 'error' for one which can be handled safely but which may lose application<br/>
		/// information or settings.<br/>
		/// By default these both result in a png_error call prior to release, while in a<br/>
		/// released version the 'warning' is just a warning.  However if the application<br/>
		/// explicitly disables benign errors (explicitly permitting the code to lose<br/>
		/// information) they both turn into warnings.<br/>
		/// If benign errors aren't supported they end up as the corresponding base call<br/>
		/// (png_warning or png_error.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppWarningNative(PngStruct* pngPtr, byte* message)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[359])(pngPtr, message);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[359])((nint)pngPtr, (nint)message);
			#endif
		}

		/// <summary>
		/// Application errors (new in 1.6); use these functions (declared below) for<br/>
		/// errors in the parameters or order of API function calls on read.  The<br/>
		/// 'warning' should be used for an error that can be handled completely; the<br/>
		/// 'error' for one which can be handled safely but which may lose application<br/>
		/// information or settings.<br/>
		/// By default these both result in a png_error call prior to release, while in a<br/>
		/// released version the 'warning' is just a warning.  However if the application<br/>
		/// explicitly disables benign errors (explicitly permitting the code to lose<br/>
		/// information) they both turn into warnings.<br/>
		/// If benign errors aren't supported they end up as the corresponding base call<br/>
		/// (png_warning or png_error.)<br/>
		/// </summary>
		public static void AppWarning(PngStruct* pngPtr, byte* message)
		{
			AppWarningNative(pngPtr, message);
		}

		/// <summary>
		/// Application errors (new in 1.6); use these functions (declared below) for<br/>
		/// errors in the parameters or order of API function calls on read.  The<br/>
		/// 'warning' should be used for an error that can be handled completely; the<br/>
		/// 'error' for one which can be handled safely but which may lose application<br/>
		/// information or settings.<br/>
		/// By default these both result in a png_error call prior to release, while in a<br/>
		/// released version the 'warning' is just a warning.  However if the application<br/>
		/// explicitly disables benign errors (explicitly permitting the code to lose<br/>
		/// information) they both turn into warnings.<br/>
		/// If benign errors aren't supported they end up as the corresponding base call<br/>
		/// (png_warning or png_error.)<br/>
		/// </summary>
		public static void AppWarning(PngStruct* pngPtr, ReadOnlySpan<byte> message)
		{
			fixed (byte* pmessage = message)
			{
				AppWarningNative(pngPtr, (byte*)pmessage);
			}
		}

		/// <summary>
		/// Application errors (new in 1.6); use these functions (declared below) for<br/>
		/// errors in the parameters or order of API function calls on read.  The<br/>
		/// 'warning' should be used for an error that can be handled completely; the<br/>
		/// 'error' for one which can be handled safely but which may lose application<br/>
		/// information or settings.<br/>
		/// By default these both result in a png_error call prior to release, while in a<br/>
		/// released version the 'warning' is just a warning.  However if the application<br/>
		/// explicitly disables benign errors (explicitly permitting the code to lose<br/>
		/// information) they both turn into warnings.<br/>
		/// If benign errors aren't supported they end up as the corresponding base call<br/>
		/// (png_warning or png_error.)<br/>
		/// </summary>
		public static void AppWarning(PngStruct* pngPtr, string message)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppWarningNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// The application provided invalid parameters to an API function or called<br/>
		/// an API function at the wrong time, libpng can completely recover.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AppErrorNative(PngStruct* pngPtr, byte* message)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[360])(pngPtr, message);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[360])((nint)pngPtr, (nint)message);
			#endif
		}

		/// <summary>
		/// The application provided invalid parameters to an API function or called<br/>
		/// an API function at the wrong time, libpng can completely recover.<br/>
		/// </summary>
		public static void AppError(PngStruct* pngPtr, byte* message)
		{
			AppErrorNative(pngPtr, message);
		}

		/// <summary>
		/// The application provided invalid parameters to an API function or called<br/>
		/// an API function at the wrong time, libpng can completely recover.<br/>
		/// </summary>
		public static void AppError(PngStruct* pngPtr, ReadOnlySpan<byte> message)
		{
			fixed (byte* pmessage = message)
			{
				AppErrorNative(pngPtr, (byte*)pmessage);
			}
		}

		/// <summary>
		/// The application provided invalid parameters to an API function or called<br/>
		/// an API function at the wrong time, libpng can completely recover.<br/>
		/// </summary>
		public static void AppError(PngStruct* pngPtr, string message)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AppErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChunkReportNative(PngStruct* pngPtr, byte* message, int error)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, int, void>)funcTable[361])(pngPtr, message, error);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, void>)funcTable[361])((nint)pngPtr, (nint)message, error);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ChunkReport(PngStruct* pngPtr, byte* message, int error)
		{
			ChunkReportNative(pngPtr, message, error);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ChunkReport(PngStruct* pngPtr, ReadOnlySpan<byte> message, int error)
		{
			fixed (byte* pmessage = message)
			{
				ChunkReportNative(pngPtr, (byte*)pmessage, error);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ChunkReport(PngStruct* pngPtr, string message, int error)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ChunkReportNative(pngPtr, pStr0, error);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AsciiFromFpNative(PngStruct* pngPtr, byte* ascii, nuint size, double fp, uint precision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, double, uint, void>)funcTable[362])(pngPtr, ascii, size, fp, precision);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, double, uint, void>)funcTable[362])((nint)pngPtr, (nint)ascii, size, fp, precision);
			#endif
		}
	}
}
