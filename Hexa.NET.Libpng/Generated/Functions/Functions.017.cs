// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	public unsafe partial class Libpng
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFp(PngStruct* pngPtr, byte* ascii, nuint size, double fp, uint precision)
		{
			AsciiFromFpNative(pngPtr, ascii, size, fp, precision);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFp(PngStruct* pngPtr, ReadOnlySpan<byte> ascii, nuint size, double fp, uint precision)
		{
			fixed (byte* pascii = ascii)
			{
				AsciiFromFpNative(pngPtr, (byte*)pascii, size, fp, precision);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFp(PngStruct* pngPtr, string ascii, nuint size, double fp, uint precision)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ascii != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ascii);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ascii, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AsciiFromFpNative(pngPtr, pStr0, size, fp, precision);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AsciiFromFixedNative(PngStruct* pngPtr, byte* ascii, nuint size, int fp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, nuint, int, void>)funcTable[363])(pngPtr, ascii, size, fp);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nuint, int, void>)funcTable[363])((nint)pngPtr, (nint)ascii, size, fp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFixed(PngStruct* pngPtr, byte* ascii, nuint size, int fp)
		{
			AsciiFromFixedNative(pngPtr, ascii, size, fp);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFixed(PngStruct* pngPtr, ReadOnlySpan<byte> ascii, nuint size, int fp)
		{
			fixed (byte* pascii = ascii)
			{
				AsciiFromFixedNative(pngPtr, (byte*)pascii, size, fp);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AsciiFromFixed(PngStruct* pngPtr, string ascii, nuint size, int fp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ascii != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ascii);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ascii, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AsciiFromFixedNative(pngPtr, pStr0, size, fp);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CheckFpNumberNative(byte* str, nuint size, int* statep, nuint* whereami)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, int*, nuint*, int>)funcTable[364])(str, size, statep, whereami);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, nint, nint, int>)funcTable[364])((nint)str, size, (nint)statep, (nint)whereami);
			#endif
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(byte* str, nuint size, int* statep, nuint* whereami)
		{
			int ret = CheckFpNumberNative(str, size, statep, whereami);
			return ret;
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(ReadOnlySpan<byte> str, nuint size, int* statep, nuint* whereami)
		{
			fixed (byte* pstr = str)
			{
				int ret = CheckFpNumberNative((byte*)pstr, size, statep, whereami);
				return ret;
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(string str, nuint size, int* statep, nuint* whereami)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = CheckFpNumberNative(pStr0, size, statep, whereami);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(byte* str, nuint size, ref int statep, nuint* whereami)
		{
			fixed (int* pstatep = &statep)
			{
				int ret = CheckFpNumberNative(str, size, (int*)pstatep, whereami);
				return ret;
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(ReadOnlySpan<byte> str, nuint size, ref int statep, nuint* whereami)
		{
			fixed (byte* pstr = str)
			{
				fixed (int* pstatep = &statep)
				{
					int ret = CheckFpNumberNative((byte*)pstr, size, (int*)pstatep, whereami);
					return ret;
				}
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(string str, nuint size, ref int statep, nuint* whereami)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pstatep = &statep)
			{
				int ret = CheckFpNumberNative(pStr0, size, (int*)pstatep, whereami);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(byte* str, nuint size, int* statep, ref nuint whereami)
		{
			fixed (nuint* pwhereami = &whereami)
			{
				int ret = CheckFpNumberNative(str, size, statep, (nuint*)pwhereami);
				return ret;
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(ReadOnlySpan<byte> str, nuint size, int* statep, ref nuint whereami)
		{
			fixed (byte* pstr = str)
			{
				fixed (nuint* pwhereami = &whereami)
				{
					int ret = CheckFpNumberNative((byte*)pstr, size, statep, (nuint*)pwhereami);
					return ret;
				}
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(string str, nuint size, int* statep, ref nuint whereami)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pwhereami = &whereami)
			{
				int ret = CheckFpNumberNative(pStr0, size, statep, (nuint*)pwhereami);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(byte* str, nuint size, ref int statep, ref nuint whereami)
		{
			fixed (int* pstatep = &statep)
			{
				fixed (nuint* pwhereami = &whereami)
				{
					int ret = CheckFpNumberNative(str, size, (int*)pstatep, (nuint*)pwhereami);
					return ret;
				}
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(ReadOnlySpan<byte> str, nuint size, ref int statep, ref nuint whereami)
		{
			fixed (byte* pstr = str)
			{
				fixed (int* pstatep = &statep)
				{
					fixed (nuint* pwhereami = &whereami)
					{
						int ret = CheckFpNumberNative((byte*)pstr, size, (int*)pstatep, (nuint*)pwhereami);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// The actual parser.  This can be called repeatedly. It updates<br/>
		/// the index into the string and the state variable (which must<br/>
		/// be initialized to 0).  It returns a result code, as above.  There<br/>
		/// is no point calling the parser any more if it fails to advance to<br/>
		/// the end of the string - it is stuck on an invalid character (or<br/>
		/// terminated by '<br/>
		/// \<br/>
		/// 0').<br/>
		/// Note that the pointer will consume an E or even an E+ and then leave<br/>
		/// a 'maybe' state even though a preceding integer.fraction is valid.<br/>
		/// The PNG_FP_WAS_VALID flag indicates that a preceding substring was<br/>
		/// a valid number.  It's possible to recover from this by calling<br/>
		/// the parser again (from the start, with state 0) but with a string<br/>
		/// that omits the last character (i.e. set the size to the index of<br/>
		/// the problem character.)  This has not been tested within libpng.<br/>
		/// </summary>
		public static int CheckFpNumber(string str, nuint size, ref int statep, ref nuint whereami)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pstatep = &statep)
			{
				fixed (nuint* pwhereami = &whereami)
				{
					int ret = CheckFpNumberNative(pStr0, size, (int*)pstatep, (nuint*)pwhereami);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This is the same but it checks a complete string and returns true<br/>
		/// only if it just contains a floating point number.  As of 1.5.4 this<br/>
		/// function also returns the state at the end of parsing the number if<br/>
		/// it was valid (otherwise it returns 0.)  This can be used for testing<br/>
		/// for negative or zero values using the sticky flag.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CheckFpStringNative(byte* str, nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, int>)funcTable[365])(str, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nuint, int>)funcTable[365])((nint)str, size);
			#endif
		}

		/// <summary>
		/// This is the same but it checks a complete string and returns true<br/>
		/// only if it just contains a floating point number.  As of 1.5.4 this<br/>
		/// function also returns the state at the end of parsing the number if<br/>
		/// it was valid (otherwise it returns 0.)  This can be used for testing<br/>
		/// for negative or zero values using the sticky flag.<br/>
		/// </summary>
		public static int CheckFpString(byte* str, nuint size)
		{
			int ret = CheckFpStringNative(str, size);
			return ret;
		}

		/// <summary>
		/// This is the same but it checks a complete string and returns true<br/>
		/// only if it just contains a floating point number.  As of 1.5.4 this<br/>
		/// function also returns the state at the end of parsing the number if<br/>
		/// it was valid (otherwise it returns 0.)  This can be used for testing<br/>
		/// for negative or zero values using the sticky flag.<br/>
		/// </summary>
		public static int CheckFpString(ReadOnlySpan<byte> str, nuint size)
		{
			fixed (byte* pstr = str)
			{
				int ret = CheckFpStringNative((byte*)pstr, size);
				return ret;
			}
		}

		/// <summary>
		/// This is the same but it checks a complete string and returns true<br/>
		/// only if it just contains a floating point number.  As of 1.5.4 this<br/>
		/// function also returns the state at the end of parsing the number if<br/>
		/// it was valid (otherwise it returns 0.)  This can be used for testing<br/>
		/// for negative or zero values using the sticky flag.<br/>
		/// </summary>
		public static int CheckFpString(string str, nuint size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = CheckFpStringNative(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Added at libpng version 1.5.0 <br/>
		/// This is a utility to provide a*times/div (rounded) and indicate<br/>
		/// if there is an overflow.  The result is a boolean - false (0)<br/>
		/// for overflow, true (1) if no overflow, in which case *res<br/>
		/// holds the result.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MuldivNative(int* res, int a, int multipliedBy, int dividedBy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int*, int, int, int, int>)funcTable[366])(res, a, multipliedBy, dividedBy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int, int>)funcTable[366])((nint)res, a, multipliedBy, dividedBy);
			#endif
		}

		/// <summary>
		/// Added at libpng version 1.5.0 <br/>
		/// This is a utility to provide a*times/div (rounded) and indicate<br/>
		/// if there is an overflow.  The result is a boolean - false (0)<br/>
		/// for overflow, true (1) if no overflow, in which case *res<br/>
		/// holds the result.<br/>
		/// </summary>
		public static int Muldiv(int* res, int a, int multipliedBy, int dividedBy)
		{
			int ret = MuldivNative(res, a, multipliedBy, dividedBy);
			return ret;
		}

		/// <summary>
		/// Calculate a reciprocal - used for gamma values.  This returns<br/>
		/// 0 if the argument is 0 in order to maintain an undefined value;<br/>
		/// there are no warnings.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReciprocalNative(int a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[367])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[367])(a);
			#endif
		}

		/// <summary>
		/// Calculate a reciprocal - used for gamma values.  This returns<br/>
		/// 0 if the argument is 0 in order to maintain an undefined value;<br/>
		/// there are no warnings.<br/>
		/// </summary>
		public static int Reciprocal(int a)
		{
			int ret = ReciprocalNative(a);
			return ret;
		}

		/// <summary>
		/// The same but gives a reciprocal of the product of two fixed point<br/>
		/// values.  Accuracy is suitable for gamma calculations but this is<br/>
		/// not exact - use png_muldiv for that.  Only required at present on read.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Reciprocal2Native(int a, int b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[368])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[368])(a, b);
			#endif
		}

		/// <summary>
		/// The same but gives a reciprocal of the product of two fixed point<br/>
		/// values.  Accuracy is suitable for gamma calculations but this is<br/>
		/// not exact - use png_muldiv for that.  Only required at present on read.<br/>
		/// </summary>
		public static int Reciprocal2(int a, int b)
		{
			int ret = Reciprocal2Native(a, b);
			return ret;
		}

		/// <summary>
		/// Return true if the gamma value is significantly different from 1.0 <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GammaSignificantNative(int gammaValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[369])(gammaValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[369])(gammaValue);
			#endif
		}

		/// <summary>
		/// Return true if the gamma value is significantly different from 1.0 <br/>
		/// </summary>
		public static int GammaSignificant(int gammaValue)
		{
			int ret = GammaSignificantNative(gammaValue);
			return ret;
		}

		/// <summary>
		/// PNGv3: 'resolve' the file gamma according to the new PNGv3 rules for colour<br/>
		/// space information.<br/>
		/// NOTE: this uses precisely those chunks that libpng supports.  For example it<br/>
		/// doesn't use iCCP and it can only use cICP for known and manageable<br/>
		/// transforms.  For this reason a gamma specified by png_set_gamma always takes<br/>
		/// precedence.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ResolveFileGammaNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, int>)funcTable[370])(pngPtr);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[370])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// PNGv3: 'resolve' the file gamma according to the new PNGv3 rules for colour<br/>
		/// space information.<br/>
		/// NOTE: this uses precisely those chunks that libpng supports.  For example it<br/>
		/// doesn't use iCCP and it can only use cICP for known and manageable<br/>
		/// transforms.  For this reason a gamma specified by png_set_gamma always takes<br/>
		/// precedence.<br/>
		/// </summary>
		public static int ResolveFileGamma(PngStruct* pngPtr)
		{
			int ret = ResolveFileGammaNative(pngPtr);
			return ret;
		}

		/// <summary>
		/// Internal fixed point gamma correction.  These APIs are called as<br/>
		/// required to convert single values - they don't need to be fast,<br/>
		/// they are not used when processing image pixel values.<br/>
		/// While the input is an 'unsigned' value it must actually be the<br/>
		/// correct bit value - 0..255 or 0..65535 as required.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GammaCorrectNative(PngStruct* pngPtr, uint value, int gammaValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, uint, int, ushort>)funcTable[371])(pngPtr, value, gammaValue);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<nint, uint, int, ushort>)funcTable[371])((nint)pngPtr, value, gammaValue);
			#endif
		}

		/// <summary>
		/// Internal fixed point gamma correction.  These APIs are called as<br/>
		/// required to convert single values - they don't need to be fast,<br/>
		/// they are not used when processing image pixel values.<br/>
		/// While the input is an 'unsigned' value it must actually be the<br/>
		/// correct bit value - 0..255 or 0..65535 as required.<br/>
		/// </summary>
		public static ushort GammaCorrect(PngStruct* pngPtr, uint value, int gammaValue)
		{
			ushort ret = GammaCorrectNative(pngPtr, value, gammaValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort Gamma16BitCorrectNative(uint value, int gammaValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, ushort>)funcTable[372])(value, gammaValue);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<uint, int, ushort>)funcTable[372])(value, gammaValue);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ushort Gamma16BitCorrect(uint value, int gammaValue)
		{
			ushort ret = Gamma16BitCorrectNative(value, gammaValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte Gamma8BitCorrectNative(uint value, int gammaValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, byte>)funcTable[373])(value, gammaValue);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, int, byte>)funcTable[373])(value, gammaValue);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte Gamma8BitCorrect(uint value, int gammaValue)
		{
			byte ret = Gamma8BitCorrectNative(value, gammaValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyGammaTableNative(PngStruct* pngPtr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, void>)funcTable[374])(pngPtr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[374])((nint)pngPtr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DestroyGammaTable(PngStruct* pngPtr)
		{
			DestroyGammaTableNative(pngPtr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BuildGammaTableNative(PngStruct* pngPtr, int bitDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, int, void>)funcTable[375])(pngPtr, bitDepth);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[375])((nint)pngPtr, bitDepth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void BuildGammaTable(PngStruct* pngPtr, int bitDepth)
		{
			BuildGammaTableNative(pngPtr, bitDepth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int XYZFromXyNative(PngXYZ* xyz, PngXy* xy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngXYZ*, PngXy*, int>)funcTable[376])(xyz, xy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[376])((nint)xyz, (nint)xy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XYZFromXy(PngXYZ* xyz, PngXy* xy)
		{
			int ret = XYZFromXyNative(xyz, xy);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XYZFromXy(ref PngXYZ xyz, PngXy* xy)
		{
			fixed (PngXYZ* pxyz = &xyz)
			{
				int ret = XYZFromXyNative((PngXYZ*)pxyz, xy);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XYZFromXy(PngXYZ* xyz, ref PngXy xy)
		{
			fixed (PngXy* pxy = &xy)
			{
				int ret = XYZFromXyNative(xyz, (PngXy*)pxy);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XYZFromXy(ref PngXYZ xyz, ref PngXy xy)
		{
			fixed (PngXYZ* pxyz = &xyz)
			{
				fixed (PngXy* pxy = &xy)
				{
					int ret = XYZFromXyNative((PngXYZ*)pxyz, (PngXy*)pxy);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int XyFromXYZNative(PngXy* xy, PngXYZ* xyz)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngXy*, PngXYZ*, int>)funcTable[377])(xy, xyz);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[377])((nint)xy, (nint)xyz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XyFromXYZ(PngXy* xy, PngXYZ* xyz)
		{
			int ret = XyFromXYZNative(xy, xyz);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XyFromXYZ(ref PngXy xy, PngXYZ* xyz)
		{
			fixed (PngXy* pxy = &xy)
			{
				int ret = XyFromXYZNative((PngXy*)pxy, xyz);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XyFromXYZ(PngXy* xy, ref PngXYZ xyz)
		{
			fixed (PngXYZ* pxyz = &xyz)
			{
				int ret = XyFromXYZNative(xy, (PngXYZ*)pxyz);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int XyFromXYZ(ref PngXy xy, ref PngXYZ xyz)
		{
			fixed (PngXy* pxy = &xy)
			{
				fixed (PngXYZ* pxyz = &xyz)
				{
					int ret = XyFromXYZNative((PngXy*)pxy, (PngXYZ*)pxyz);
					return ret;
				}
			}
		}

		/// <summary>
		/// Utility to safely execute a piece of libpng code catching and logging any<br/>
		/// errors that might occur.  Returns true on success, false on failure (either<br/>
		/// of the function or as a result of a png_error.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SafeErrorNative(PngStruct* pngPtr, byte* errorMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[378])(pngPtr, errorMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[378])((nint)pngPtr, (nint)errorMessage);
			#endif
		}

		/// <summary>
		/// Utility to safely execute a piece of libpng code catching and logging any<br/>
		/// errors that might occur.  Returns true on success, false on failure (either<br/>
		/// of the function or as a result of a png_error.)<br/>
		/// </summary>
		public static void SafeError(PngStruct* pngPtr, byte* errorMessage)
		{
			SafeErrorNative(pngPtr, errorMessage);
		}

		/// <summary>
		/// Utility to safely execute a piece of libpng code catching and logging any<br/>
		/// errors that might occur.  Returns true on success, false on failure (either<br/>
		/// of the function or as a result of a png_error.)<br/>
		/// </summary>
		public static void SafeError(PngStruct* pngPtr, ReadOnlySpan<byte> errorMessage)
		{
			fixed (byte* perrorMessage = errorMessage)
			{
				SafeErrorNative(pngPtr, (byte*)perrorMessage);
			}
		}

		/// <summary>
		/// Utility to safely execute a piece of libpng code catching and logging any<br/>
		/// errors that might occur.  Returns true on success, false on failure (either<br/>
		/// of the function or as a result of a png_error.)<br/>
		/// </summary>
		public static void SafeError(PngStruct* pngPtr, string errorMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errorMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errorMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errorMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SafeErrorNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SafeWarningNative(PngStruct* pngPtr, byte* warningMessage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<PngStruct*, byte*, void>)funcTable[379])(pngPtr, warningMessage);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[379])((nint)pngPtr, (nint)warningMessage);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SafeWarning(PngStruct* pngPtr, byte* warningMessage)
		{
			SafeWarningNative(pngPtr, warningMessage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SafeWarning(PngStruct* pngPtr, ReadOnlySpan<byte> warningMessage)
		{
			fixed (byte* pwarningMessage = warningMessage)
			{
				SafeWarningNative(pngPtr, (byte*)pwarningMessage);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SafeWarning(PngStruct* pngPtr, string warningMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (warningMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(warningMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(warningMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SafeWarningNative(pngPtr, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SafeExecuteNative(PngImage* image, delegate*<void*, int> function, void* arg)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, delegate*<void*, int>, void*, int>)funcTable[380])(image, function, arg);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[380])((nint)image, (nint)function, (nint)arg);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int SafeExecute(PngImage* image, delegate*<void*, int> function, void* arg)
		{
			int ret = SafeExecuteNative(image, function, arg);
			return ret;
		}

		/// <summary>
		/// Utility to log an error; this also cleans up the png_image; the function<br/>
		/// always returns 0 (false).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImageErrorNative(PngImage* image, byte* errorMessage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngImage*, byte*, int>)funcTable[381])(image, errorMessage);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[381])((nint)image, (nint)errorMessage);
			#endif
		}

		/// <summary>
		/// Utility to log an error; this also cleans up the png_image; the function<br/>
		/// always returns 0 (false).<br/>
		/// </summary>
		public static int ImageError(PngImage* image, byte* errorMessage)
		{
			int ret = ImageErrorNative(image, errorMessage);
			return ret;
		}

		/// <summary>
		/// Utility to log an error; this also cleans up the png_image; the function<br/>
		/// always returns 0 (false).<br/>
		/// </summary>
		public static int ImageError(PngImage* image, ReadOnlySpan<byte> errorMessage)
		{
			fixed (byte* perrorMessage = errorMessage)
			{
				int ret = ImageErrorNative(image, (byte*)perrorMessage);
				return ret;
			}
		}

		/// <summary>
		/// Utility to log an error; this also cleans up the png_image; the function<br/>
		/// always returns 0 (false).<br/>
		/// </summary>
		public static int ImageError(PngImage* image, string errorMessage)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errorMessage != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errorMessage);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errorMessage, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImageErrorNative(image, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CheckKeywordNative(PngStruct* pngPtr, byte* key, byte* newKey)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<PngStruct*, byte*, byte*, uint>)funcTable[382])(pngPtr, key, newKey);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[382])((nint)pngPtr, (nint)key, (nint)newKey);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, byte* key, byte* newKey)
		{
			uint ret = CheckKeywordNative(pngPtr, key, newKey);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, ReadOnlySpan<byte> key, byte* newKey)
		{
			fixed (byte* pkey = key)
			{
				uint ret = CheckKeywordNative(pngPtr, (byte*)pkey, newKey);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, string key, byte* newKey)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = CheckKeywordNative(pngPtr, pStr0, newKey);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, byte* key, ReadOnlySpan<byte> newKey)
		{
			fixed (byte* pnewKey = newKey)
			{
				uint ret = CheckKeywordNative(pngPtr, key, (byte*)pnewKey);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, byte* key, string newKey)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newKey != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newKey);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newKey, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = CheckKeywordNative(pngPtr, key, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, ReadOnlySpan<byte> key, ReadOnlySpan<byte> newKey)
		{
			fixed (byte* pkey = key)
			{
				fixed (byte* pnewKey = newKey)
				{
					uint ret = CheckKeywordNative(pngPtr, (byte*)pkey, (byte*)pnewKey);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CheckKeyword(PngStruct* pngPtr, string key, string newKey)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (key != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(key);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(key, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newKey != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newKey);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newKey, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = CheckKeywordNative(pngPtr, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

	}
}
