// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Hexa.NET.ZLib;

namespace Hexa.NET.Libpng
{
	#if NET5_0_OR_GREATER
	/// <summary>
	/// setjmp non-local goto function. <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void LongjmpFn();

	#else
	/// <summary>
	/// setjmp non-local goto function. <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void LongjmpFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for printing errors and aborting <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ErrorFn();

	#else
	/// <summary>
	/// function for printing errors and aborting <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ErrorFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for printing warnings <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WarningFn();

	#else
	/// <summary>
	/// function for printing warnings <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WarningFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for writing output data <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteDataFn();

	#else
	/// <summary>
	/// function for writing output data <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteDataFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for reading input data <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadDataFn();

	#else
	/// <summary>
	/// function for reading input data <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadDataFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// user read transform <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadUserTransformFn();

	#else
	/// <summary>
	/// user read transform <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadUserTransformFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// user write transform <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteUserTransformFn();

	#else
	/// <summary>
	/// user write transform <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteUserTransformFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// Function for flushing output <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void OutputFlushFn();

	#else
	/// <summary>
	/// Function for flushing output <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void OutputFlushFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// called after each row is decoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadRowFn();

	#else
	/// <summary>
	/// called after each row is decoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void ReadRowFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// called after each row is encoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteRowFn();

	#else
	/// <summary>
	/// called after each row is encoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void WriteRowFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// called after header data fully read <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void InfoFn();

	#else
	/// <summary>
	/// called after header data fully read <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void InfoFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// called after a prog. row is decoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void RowFn();

	#else
	/// <summary>
	/// called after a prog. row is decoded <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void RowFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// called after image is complete <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void EndFn();

	#else
	/// <summary>
	/// called after image is complete <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void EndFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// user read chunk handler <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int ReadUserChunkFn();

	#else
	/// <summary>
	/// user read chunk handler <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int ReadUserChunkFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for allocating memory <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* MallocFn();

	#else
	/// <summary>
	/// function for allocating memory <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint MallocFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// function for freeing memory <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void FreeFn();

	#else
	/// <summary>
	/// function for freeing memory <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void FreeFn();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// These are the function types for the I/O functions and for the functions<br/>
	/// that allow the user to override the default I/O functions with his or her<br/>
	/// own.  The png_error_ptr type should match that of user-supplied warning<br/>
	/// and error functions, while the png_rw_ptr type should match that of the<br/>
	/// user read/write data functions.  Note that the 'write' function must not<br/>
	/// modify the buffer it is passed. The 'read' function, on the other hand, is<br/>
	/// expected to return the read data in the buffer.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngErrorPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_const_charp")] byte* unknown1);

	#else
	/// <summary>
	/// These are the function types for the I/O functions and for the functions<br/>
	/// that allow the user to override the default I/O functions with his or her<br/>
	/// own.  The png_error_ptr type should match that of user-supplied warning<br/>
	/// and error functions, while the png_rw_ptr type should match that of the<br/>
	/// user read/write data functions.  Note that the 'write' function must not<br/>
	/// modify the buffer it is passed. The 'read' function, on the other hand, is<br/>
	/// expected to return the read data in the buffer.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngErrorPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_const_charp")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngRwPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] byte* unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "size_t")] nuint unknown2);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngRwPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] nint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "size_t")] nuint unknown2);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngFlushPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngFlushPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngReadStatusPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown2);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngReadStatusPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown2);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngWriteStatusPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown2);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngWriteStatusPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown2);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveInfoPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_infop")] PngInfo* unknown1);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveInfoPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_infop")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveEndPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_infop")] PngInfo* unknown1);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveEndPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_infop")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// The following callback receives png_uint_32 row_number, int pass for the<br/>
	/// png_bytep data of the row.  When transforming an interlaced image the<br/>
	/// row number is the row number within the sub-image of the interlace pass, so<br/>
	/// the value will increase to the height of the sub-image (not the full image)<br/>
	/// then reset to 0 for the next pass.<br/>
	/// Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to<br/>
	/// find the output pixel (x,y) given an interlaced sub-image pixel<br/>
	/// (row,col,pass).  (See below for these macros.)<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveRowPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] byte* unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown2, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown3);

	#else
	/// <summary>
	/// The following callback receives png_uint_32 row_number, int pass for the<br/>
	/// png_bytep data of the row.  When transforming an interlaced image the<br/>
	/// row number is the row number within the sub-image of the interlace pass, so<br/>
	/// the value will increase to the height of the sub-image (not the full image)<br/>
	/// then reset to 0 for the next pass.<br/>
	/// Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to<br/>
	/// find the output pixel (x,y) given an interlaced sub-image pixel<br/>
	/// (row,col,pass).  (See below for these macros.)<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngProgressiveRowPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] nint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_uint_32")] uint unknown2, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown3);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngUserTransformPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_row_infop")] PngRowInfo* unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] byte* unknown2);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngUserTransformPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_row_infop")] nint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_bytep")] nint unknown2);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int PngUserChunkPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_unknown_chunkp")] PngUnknownChunk* unknown1);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int PngUserChunkPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_unknown_chunkp")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// This must match the function definition in <br/>
	/// <setjmp<br/>
	/// .h>, and the application<br/>
	/// must include this before png.h to obtain the definition of jmp_buf.  The<br/>
	/// function is required to be PNG_NORETURN, but this is not checked.  If the<br/>
	/// function does return the application will crash via an abort() or similar<br/>
	/// system level call.<br/>
	/// If you get a warning here while building the library you may need to make<br/>
	/// changes to ensure that pnglibconf.h records the calling convention used by<br/>
	/// your compiler.  This may be very difficult - try using a different compiler<br/>
	/// to build the library!<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngLongjmpPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "jmp_buf")] JmpBuf unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown1);

	#else
	/// <summary>
	/// This must match the function definition in <br/>
	/// <setjmp<br/>
	/// .h>, and the application<br/>
	/// must include this before png.h to obtain the definition of jmp_buf.  The<br/>
	/// function is required to be PNG_NORETURN, but this is not checked.  If the<br/>
	/// function does return the application will crash via an abort() or similar<br/>
	/// system level call.<br/>
	/// If you get a warning here while building the library you may need to make<br/>
	/// changes to ensure that pnglibconf.h records the calling convention used by<br/>
	/// your compiler.  This may be very difficult - try using a different compiler<br/>
	/// to build the library!<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngLongjmpPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "jmp_buf")] JmpBuf unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "int")] int unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// NOTE: prior to 1.5 these functions had no 'API' style declaration,<br/>
	/// this allowed the zlib default functions to be used on Windows<br/>
	/// platforms.  In 1.5 the zlib default malloc (which just calls malloc and<br/>
	/// ignores the first argument) should be completely compatible with the<br/>
	/// following.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* PngMallocPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_alloc_size_t")] nint unknown1);

	#else
	/// <summary>
	/// NOTE: prior to 1.5 these functions had no 'API' style declaration,<br/>
	/// this allowed the zlib default functions to be used on Windows<br/>
	/// platforms.  In 1.5 the zlib default malloc (which just calls malloc and<br/>
	/// ignores the first argument) should be completely compatible with the<br/>
	/// following.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint PngMallocPtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_alloc_size_t")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngFreePtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] PngStruct* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_voidp")] void* unknown1);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void PngFreePtr([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_structp")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "png_voidp")] nint unknown1);

	#endif

}
